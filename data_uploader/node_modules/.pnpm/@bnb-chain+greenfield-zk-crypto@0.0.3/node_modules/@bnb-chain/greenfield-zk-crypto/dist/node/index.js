/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/node/index.js":
/*!***************************!*\
  !*** ./src/node/index.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eddsaSign: () => (/* binding */ eddsaSign),\n/* harmony export */   getEddsaCompressedPublicKey: () => (/* binding */ getEddsaCompressedPublicKey),\n/* harmony export */   startRunningService: () => (/* binding */ startRunningService)\n/* harmony export */ });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _wasm_zk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wasm/zk-crypto.wasm */ \"./src/wasm/zk-crypto.wasm\");\n/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ \"./src/node/init.js\");\n\n\n\n\n// 1. modify method of `exports` and `globalThis` export.\nconst startRunningService = async () => {\n  // `wasm.default` is `cross-wasm.wasm`\n  const wasmPath = path__WEBPACK_IMPORTED_MODULE_0___default().resolve(__dirname, _wasm_zk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__);\n  await (0,_init__WEBPACK_IMPORTED_MODULE_2__.instantiateWASM)(wasmPath);\n  // const exports = module.instance.exports;\n\n  // `exports` is a map to `//export` way of TinyGo way.\n  // const { add } = exports;\n\n  // `globalThis` is a map to complex way of `syscall/js` way.\n  const { getEddsaCompressedPublicKey, eddsaSign } = globalThis;\n\n  return {\n    getEddsaCompressedPublicKey,\n    eddsaSign,\n  };\n};\n\n// 2. wasm export function:\nconst eddsaSign = async (seed, message) => {\n  const service = await (0,_init__WEBPACK_IMPORTED_MODULE_2__.getService)();\n  return service.eddsaSign(seed, message);\n};\n\nconst getEddsaCompressedPublicKey = async (seed) => {\n  const service = await (0,_init__WEBPACK_IMPORTED_MODULE_2__.getService)();\n  return service.getEddsaCompressedPublicKey(seed);\n};\n\n\n//# sourceURL=webpack://@bnb-chain/greenfield-zk-crypto/./src/node/index.js?");

/***/ }),

/***/ "./src/node/init.js":
/*!**************************!*\
  !*** ./src/node/init.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getService: () => (/* binding */ getService),\n/* harmony export */   instantiateWASM: () => (/* binding */ instantiateWASM)\n/* harmony export */ });\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! . */ \"./src/node/index.js\");\n/* harmony import */ var _wasm_exec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wasm_exec */ \"./src/node/wasm_exec.js\");\n/* harmony import */ var _wasm_exec__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_wasm_exec__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nlet longLivedService;\n\nconst getService = () => {\n  if (!longLivedService) {\n    longLivedService = (0,___WEBPACK_IMPORTED_MODULE_1__.startRunningService)().catch((err) => {\n      // Let the caller try again if this fails.\n      longLivedService = void 0;\n      // But still, throw the error back up the caller.\n      throw err;\n    });\n  }\n  return longLivedService;\n};\n\nconst instantiateWASM = async (wasmPath) => {\n  let response = undefined;\n\n  const fetchAndInstantiateTask = async () => {\n    const buf = node_fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(wasmPath);\n    const go = new (_wasm_exec__WEBPACK_IMPORTED_MODULE_2___default())();\n    const module = await WebAssembly.instantiate(new Uint8Array(buf), go.importObject);\n\n    go.run(module.instance);\n    return module;\n  };\n  response = await fetchAndInstantiateTask();\n\n  return response;\n};\n\n\n//# sourceURL=webpack://@bnb-chain/greenfield-zk-crypto/./src/node/init.js?");

/***/ }),

/***/ "./src/node/wasm_exec.js":
/*!*******************************!*\
  !*** ./src/node/wasm_exec.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/* eslint-disable */\n// @ts-nocheck\n// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n//\n// This file has been modified for use by the TinyGo compiler.\n\n// Map multiple JavaScript environments to a single common API,\n// preferring web standards over Node.js API.\n//\n// Environments considered:\n// - Browsers\n// - Node.js\n// - Electron\n// - Parcel\n\nif (typeof global !== 'undefined') {\n  // global already exists\n} else if (typeof window !== 'undefined') {\n  window.global = window;\n} else if (typeof self !== 'undefined') {\n  self.global = self;\n} else {\n  throw new Error('cannot export Go (neither global, window nor self is defined)');\n}\n\nif (!global.require && \"function\" !== 'undefined') {\n  global.require = __webpack_require__(\"./src/node sync recursive\");\n}\n\nif (!global.fs && global.require) {\n  global.fs = __webpack_require__(/*! fs */ \"fs\");\n}\n\nconst enosys = () => {\n  const err = new Error('not implemented');\n  err.code = 'ENOSYS';\n  return err;\n};\n\nif (!global.fs) {\n  let outputBuf = '';\n  global.fs = {\n    constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 }, // unused\n    writeSync(fd, buf) {\n      outputBuf += decoder.decode(buf);\n      const nl = outputBuf.lastIndexOf('\\n');\n      if (nl != -1) {\n        console.log(outputBuf.substr(0, nl));\n        outputBuf = outputBuf.substr(nl + 1);\n      }\n      return buf.length;\n    },\n    write(fd, buf, offset, length, position, callback) {\n      if (offset !== 0 || length !== buf.length || position !== null) {\n        callback(enosys());\n        return;\n      }\n      const n = this.writeSync(fd, buf);\n      callback(null, n);\n    },\n    chmod(path, mode, callback) {\n      callback(enosys());\n    },\n    chown(path, uid, gid, callback) {\n      callback(enosys());\n    },\n    close(fd, callback) {\n      callback(enosys());\n    },\n    fchmod(fd, mode, callback) {\n      callback(enosys());\n    },\n    fchown(fd, uid, gid, callback) {\n      callback(enosys());\n    },\n    fstat(fd, callback) {\n      callback(enosys());\n    },\n    fsync(fd, callback) {\n      callback(null);\n    },\n    ftruncate(fd, length, callback) {\n      callback(enosys());\n    },\n    lchown(path, uid, gid, callback) {\n      callback(enosys());\n    },\n    link(path, link, callback) {\n      callback(enosys());\n    },\n    lstat(path, callback) {\n      callback(enosys());\n    },\n    mkdir(path, perm, callback) {\n      callback(enosys());\n    },\n    open(path, flags, mode, callback) {\n      callback(enosys());\n    },\n    read(fd, buffer, offset, length, position, callback) {\n      callback(enosys());\n    },\n    readdir(path, callback) {\n      callback(enosys());\n    },\n    readlink(path, callback) {\n      callback(enosys());\n    },\n    rename(from, to, callback) {\n      callback(enosys());\n    },\n    rmdir(path, callback) {\n      callback(enosys());\n    },\n    stat(path, callback) {\n      callback(enosys());\n    },\n    symlink(path, link, callback) {\n      callback(enosys());\n    },\n    truncate(path, length, callback) {\n      callback(enosys());\n    },\n    unlink(path, callback) {\n      callback(enosys());\n    },\n    utimes(path, atime, mtime, callback) {\n      callback(enosys());\n    },\n  };\n}\n\nif (!global.process) {\n  global.process = {\n    getuid() {\n      return -1;\n    },\n    getgid() {\n      return -1;\n    },\n    geteuid() {\n      return -1;\n    },\n    getegid() {\n      return -1;\n    },\n    getgroups() {\n      throw enosys();\n    },\n    pid: -1,\n    ppid: -1,\n    umask() {\n      throw enosys();\n    },\n    cwd() {\n      throw enosys();\n    },\n    chdir() {\n      throw enosys();\n    },\n  };\n}\n\nif (!global.crypto) {\n  const nodeCrypto = __webpack_require__(/*! crypto */ \"crypto\");\n  global.crypto = {\n    getRandomValues(b) {\n      nodeCrypto.randomFillSync(b);\n    },\n  };\n}\n\nif (!global.performance) {\n  global.performance = {\n    now() {\n      const [sec, nsec] = process.hrtime();\n      return sec * 1000 + nsec / 1000000;\n    },\n  };\n}\n\nif (!global.TextEncoder) {\n  global.TextEncoder = (__webpack_require__(/*! util */ \"util\").TextEncoder);\n}\n\nif (!global.TextDecoder) {\n  global.TextDecoder = (__webpack_require__(/*! util */ \"util\").TextDecoder);\n}\n\n// End of polyfills for common API.\n\nconst encoder = new TextEncoder('utf-8');\nconst decoder = new TextDecoder('utf-8');\nlet reinterpretBuf = new DataView(new ArrayBuffer(8));\nvar logLine = [];\n\nmodule.exports = class Go {\n  constructor() {\n    this._callbackTimeouts = new Map();\n    this._nextCallbackTimeoutID = 1;\n\n    const mem = () => {\n      // The buffer may change when requesting more memory.\n      return new DataView(this._inst.exports.memory.buffer);\n    };\n\n    const unboxValue = (v_ref) => {\n      reinterpretBuf.setBigInt64(0, v_ref, true);\n      const f = reinterpretBuf.getFloat64(0, true);\n      if (f === 0) {\n        return undefined;\n      }\n      if (!isNaN(f)) {\n        return f;\n      }\n\n      const id = v_ref & 0xffffffffn;\n      return this._values[id];\n    };\n\n    const loadValue = (addr) => {\n      let v_ref = mem().getBigUint64(addr, true);\n      return unboxValue(v_ref);\n    };\n\n    const boxValue = (v) => {\n      const nanHead = 0x7ff80000n;\n\n      if (typeof v === 'number') {\n        if (isNaN(v)) {\n          return nanHead << 32n;\n        }\n        if (v === 0) {\n          return (nanHead << 32n) | 1n;\n        }\n        reinterpretBuf.setFloat64(0, v, true);\n        return reinterpretBuf.getBigInt64(0, true);\n      }\n\n      switch (v) {\n        case undefined:\n          return 0n;\n        case null:\n          return (nanHead << 32n) | 2n;\n        case true:\n          return (nanHead << 32n) | 3n;\n        case false:\n          return (nanHead << 32n) | 4n;\n      }\n\n      let id = this._ids.get(v);\n      if (id === undefined) {\n        id = this._idPool.pop();\n        if (id === undefined) {\n          id = BigInt(this._values.length);\n        }\n        this._values[id] = v;\n        this._goRefCounts[id] = 0;\n        this._ids.set(v, id);\n      }\n      this._goRefCounts[id]++;\n      let typeFlag = 1n;\n      switch (typeof v) {\n        case 'string':\n          typeFlag = 2n;\n          break;\n        case 'symbol':\n          typeFlag = 3n;\n          break;\n        case 'function':\n          typeFlag = 4n;\n          break;\n      }\n      return id | ((nanHead | typeFlag) << 32n);\n    };\n\n    const storeValue = (addr, v) => {\n      let v_ref = boxValue(v);\n      mem().setBigUint64(addr, v_ref, true);\n    };\n\n    const loadSlice = (array, len, cap) => {\n      return new Uint8Array(this._inst.exports.memory.buffer, array, len);\n    };\n\n    const loadSliceOfValues = (array, len, cap) => {\n      const a = new Array(len);\n      for (let i = 0; i < len; i++) {\n        a[i] = loadValue(array + i * 8);\n      }\n      return a;\n    };\n\n    const loadString = (ptr, len) => {\n      return decoder.decode(new DataView(this._inst.exports.memory.buffer, ptr, len));\n    };\n\n    const timeOrigin = Date.now() - performance.now();\n    this.importObject = {\n      wasi_snapshot_preview1: {\n        // https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md#fd_write\n        fd_write: function (fd, iovs_ptr, iovs_len, nwritten_ptr) {\n          let nwritten = 0;\n          if (fd == 1) {\n            for (let iovs_i = 0; iovs_i < iovs_len; iovs_i++) {\n              let iov_ptr = iovs_ptr + iovs_i * 8; // assuming wasm32\n              let ptr = mem().getUint32(iov_ptr + 0, true);\n              let len = mem().getUint32(iov_ptr + 4, true);\n              nwritten += len;\n              for (let i = 0; i < len; i++) {\n                let c = mem().getUint8(ptr + i);\n                if (c == 13) {\n                  // CR\n                  // ignore\n                } else if (c == 10) {\n                  // LF\n                  // write line\n                  let line = decoder.decode(new Uint8Array(logLine));\n                  logLine = [];\n                  console.log(line);\n                } else {\n                  logLine.push(c);\n                }\n              }\n            }\n          } else {\n            console.error('invalid file descriptor:', fd);\n          }\n          mem().setUint32(nwritten_ptr, nwritten, true);\n          return 0;\n        },\n        fd_close: () => 0, // dummy\n        fd_fdstat_get: () => 0, // dummy\n        fd_seek: () => 0, // dummy\n        proc_exit: (code) => {\n          if (global.process) {\n            // Node.js\n            process.exit(code);\n          } else {\n            // Can't exit in a browser.\n            throw 'trying to exit with code ' + code;\n          }\n        },\n        random_get: (bufPtr, bufLen) => {\n          crypto.getRandomValues(loadSlice(bufPtr, bufLen));\n          return 0;\n        },\n      },\n      gojs: {\n        // func ticks() float64\n        'runtime.ticks': () => {\n          return timeOrigin + performance.now();\n        },\n\n        // func sleepTicks(timeout float64)\n        'runtime.sleepTicks': (timeout) => {\n          // Do not sleep, only reactivate scheduler after the given timeout.\n          setTimeout(this._inst.exports.go_scheduler, timeout);\n        },\n\n        // func finalizeRef(v ref)\n        'syscall/js.finalizeRef': (v_ref) => {\n          const id = mem().getUint32(unboxValue(v_ref), true);\n          this._goRefCounts[id]--;\n          if (this._goRefCounts[id] === 0) {\n            const v = this._values[id];\n            this._values[id] = null;\n            this._ids.delete(v);\n            this._idPool.push(id);\n          }\n        },\n\n        // func stringVal(value string) ref\n        'syscall/js.stringVal': (value_ptr, value_len) => {\n          const s = loadString(value_ptr, value_len);\n          return boxValue(s);\n        },\n\n        // func valueGet(v ref, p string) ref\n        'syscall/js.valueGet': (v_ref, p_ptr, p_len) => {\n          let prop = loadString(p_ptr, p_len);\n          let v = unboxValue(v_ref);\n          let result = Reflect.get(v, prop);\n          return boxValue(result);\n        },\n\n        // func valueSet(v ref, p string, x ref)\n        'syscall/js.valueSet': (v_ref, p_ptr, p_len, x_ref) => {\n          const v = unboxValue(v_ref);\n          const p = loadString(p_ptr, p_len);\n          const x = unboxValue(x_ref);\n          Reflect.set(v, p, x);\n        },\n\n        // func valueDelete(v ref, p string)\n        'syscall/js.valueDelete': (v_ref, p_ptr, p_len) => {\n          const v = unboxValue(v_ref);\n          const p = loadString(p_ptr, p_len);\n          Reflect.deleteProperty(v, p);\n        },\n\n        // func valueIndex(v ref, i int) ref\n        'syscall/js.valueIndex': (v_ref, i) => {\n          return boxValue(Reflect.get(unboxValue(v_ref), i));\n        },\n\n        // valueSetIndex(v ref, i int, x ref)\n        'syscall/js.valueSetIndex': (v_ref, i, x_ref) => {\n          Reflect.set(unboxValue(v_ref), i, unboxValue(x_ref));\n        },\n\n        // func valueCall(v ref, m string, args []ref) (ref, bool)\n        'syscall/js.valueCall': (ret_addr, v_ref, m_ptr, m_len, args_ptr, args_len, args_cap) => {\n          const v = unboxValue(v_ref);\n          const name = loadString(m_ptr, m_len);\n          const args = loadSliceOfValues(args_ptr, args_len, args_cap);\n          try {\n            const m = Reflect.get(v, name);\n            storeValue(ret_addr, Reflect.apply(m, v, args));\n            mem().setUint8(ret_addr + 8, 1);\n          } catch (err) {\n            storeValue(ret_addr, err);\n            mem().setUint8(ret_addr + 8, 0);\n          }\n        },\n\n        // func valueInvoke(v ref, args []ref) (ref, bool)\n        'syscall/js.valueInvoke': (ret_addr, v_ref, args_ptr, args_len, args_cap) => {\n          try {\n            const v = unboxValue(v_ref);\n            const args = loadSliceOfValues(args_ptr, args_len, args_cap);\n            storeValue(ret_addr, Reflect.apply(v, undefined, args));\n            mem().setUint8(ret_addr + 8, 1);\n          } catch (err) {\n            storeValue(ret_addr, err);\n            mem().setUint8(ret_addr + 8, 0);\n          }\n        },\n\n        // func valueNew(v ref, args []ref) (ref, bool)\n        'syscall/js.valueNew': (ret_addr, v_ref, args_ptr, args_len, args_cap) => {\n          const v = unboxValue(v_ref);\n          const args = loadSliceOfValues(args_ptr, args_len, args_cap);\n          try {\n            storeValue(ret_addr, Reflect.construct(v, args));\n            mem().setUint8(ret_addr + 8, 1);\n          } catch (err) {\n            storeValue(ret_addr, err);\n            mem().setUint8(ret_addr + 8, 0);\n          }\n        },\n\n        // func valueLength(v ref) int\n        'syscall/js.valueLength': (v_ref) => {\n          return unboxValue(v_ref).length;\n        },\n\n        // valuePrepareString(v ref) (ref, int)\n        'syscall/js.valuePrepareString': (ret_addr, v_ref) => {\n          const s = String(unboxValue(v_ref));\n          const str = encoder.encode(s);\n          storeValue(ret_addr, str);\n          mem().setInt32(ret_addr + 8, str.length, true);\n        },\n\n        // valueLoadString(v ref, b []byte)\n        'syscall/js.valueLoadString': (v_ref, slice_ptr, slice_len, slice_cap) => {\n          const str = unboxValue(v_ref);\n          loadSlice(slice_ptr, slice_len, slice_cap).set(str);\n        },\n\n        // func valueInstanceOf(v ref, t ref) bool\n        'syscall/js.valueInstanceOf': (v_ref, t_ref) => {\n          return unboxValue(v_ref) instanceof unboxValue(t_ref);\n        },\n\n        // func copyBytesToGo(dst []byte, src ref) (int, bool)\n        'syscall/js.copyBytesToGo': (ret_addr, dest_addr, dest_len, dest_cap, src_ref) => {\n          let num_bytes_copied_addr = ret_addr;\n          let returned_status_addr = ret_addr + 4; // Address of returned boolean status variable\n\n          const dst = loadSlice(dest_addr, dest_len);\n          const src = unboxValue(src_ref);\n          if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n            mem().setUint8(returned_status_addr, 0); // Return \"not ok\" status\n            return;\n          }\n          const toCopy = src.subarray(0, dst.length);\n          dst.set(toCopy);\n          mem().setUint32(num_bytes_copied_addr, toCopy.length, true);\n          mem().setUint8(returned_status_addr, 1); // Return \"ok\" status\n        },\n\n        // copyBytesToJS(dst ref, src []byte) (int, bool)\n        // Originally copied from upstream Go project, then modified:\n        //   https://github.com/golang/go/blob/3f995c3f3b43033013013e6c7ccc93a9b1411ca9/misc/wasm/wasm_exec.js#L404-L416\n        'syscall/js.copyBytesToJS': (ret_addr, dst_ref, src_addr, src_len, src_cap) => {\n          let num_bytes_copied_addr = ret_addr;\n          let returned_status_addr = ret_addr + 4; // Address of returned boolean status variable\n\n          const dst = unboxValue(dst_ref);\n          const src = loadSlice(src_addr, src_len);\n          if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n            mem().setUint8(returned_status_addr, 0); // Return \"not ok\" status\n            return;\n          }\n          const toCopy = src.subarray(0, dst.length);\n          dst.set(toCopy);\n          mem().setUint32(num_bytes_copied_addr, toCopy.length, true);\n          mem().setUint8(returned_status_addr, 1); // Return \"ok\" status\n        },\n      },\n    };\n\n    // Go 1.20 uses 'env'. Go 1.21 uses 'gojs'.\n    // For compatibility, we use both as long as Go 1.20 is supported.\n    this.importObject.env = this.importObject.gojs;\n  }\n\n  async run(instance) {\n    this._inst = instance;\n    this._values = [\n      // JS values that Go currently has references to, indexed by reference id\n      NaN,\n      0,\n      null,\n      true,\n      false,\n      global,\n      this,\n    ];\n    this._goRefCounts = []; // number of references that Go has to a JS value, indexed by reference id\n    this._ids = new Map(); // mapping from JS values to reference ids\n    this._idPool = []; // unused ids that have been garbage collected\n    this.exited = false; // whether the Go program has exited\n\n    const mem = new DataView(this._inst.exports.memory.buffer);\n\n    while (true) {\n      const callbackPromise = new Promise((resolve) => {\n        this._resolveCallbackPromise = () => {\n          if (this.exited) {\n            throw new Error('bad callback: Go program has already exited');\n          }\n          setTimeout(resolve, 0); // make sure it is asynchronous\n        };\n      });\n      this._inst.exports._start();\n      if (this.exited) {\n        break;\n      }\n      await callbackPromise;\n    }\n  }\n\n  _resume() {\n    if (this.exited) {\n      throw new Error('Go program has already exited');\n    }\n    this._inst.exports.resume();\n    if (this.exited) {\n      this._resolveExitPromise();\n    }\n  }\n\n  _makeFuncWrapper(id) {\n    const go = this;\n    return function () {\n      const event = { id: id, this: this, args: arguments };\n      go._pendingEvent = event;\n      go._resume();\n      return event.result;\n    };\n  }\n};\n\nif (\n  global.require &&\n  global.require.main === module &&\n  global.process &&\n  global.process.versions &&\n  !global.process.versions.electron\n) {\n  if (process.argv.length != 3) {\n    console.error('usage: go_js_wasm_exec [wasm binary] [arguments]');\n    process.exit(1);\n  }\n\n  const go = new Go();\n  WebAssembly.instantiate(fs.readFileSync(process.argv[2]), go.importObject)\n    .then((result) => {\n      return go.run(result.instance);\n    })\n    .catch((err) => {\n      console.error(err);\n      process.exit(1);\n    });\n}\n\n\n//# sourceURL=webpack://@bnb-chain/greenfield-zk-crypto/./src/node/wasm_exec.js?");

/***/ }),

/***/ "./src/node sync recursive":
/*!************************!*\
  !*** ./src/node/ sync ***!
  \************************/
/***/ ((module) => {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./src/node sync recursive\";\nmodule.exports = webpackEmptyContext;\n\n//# sourceURL=webpack://@bnb-chain/greenfield-zk-crypto/./src/node/_sync?");

/***/ }),

/***/ "./src/wasm/zk-crypto.wasm":
/*!*********************************!*\
  !*** ./src/wasm/zk-crypto.wasm ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"zk-crypto.wasm\";\n\n//# sourceURL=webpack://@bnb-chain/greenfield-zk-crypto/./src/wasm/zk-crypto.wasm?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "";
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/node/index.js");
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;