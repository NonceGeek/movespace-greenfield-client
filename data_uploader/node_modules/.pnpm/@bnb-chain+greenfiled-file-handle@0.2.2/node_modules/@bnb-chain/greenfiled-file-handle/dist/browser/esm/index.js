/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/browser/index.js":
/*!******************************!*\
  !*** ./src/browser/index.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCheckSums: () => (/* binding */ getCheckSums),\n/* harmony export */   startRunningService: () => (/* binding */ startRunningService)\n/* harmony export */ });\n/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init */ \"./src/browser/init.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ \"./src/constants.js\");\n\n\n\n// 1. modify method of `exports` and `globalThis` export.\nconst startRunningService = async (wasmURL) => {\n  const module = await (0,_init__WEBPACK_IMPORTED_MODULE_0__.instantiateWASM)(wasmURL);\n  module.instance.exports;\n\n  // `exports` is a map to `//export` way of TinyGo way.\n  // const { add } = exports;\n\n  // `globalThis` is a map to complex way of `syscall/js` way.\n  const { getCheckSums } = globalThis;\n\n  return {\n    getCheckSums,\n  };\n};\n\nconst getCheckSums = async (\n  bytes,\n  segmentSize = _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SEGMENT_SIZE,\n  dataBlocks = _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_DATA_BLOCKS,\n  parityBlocks = _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_PARITY_BLOCKS,\n) => {\n  await (0,_init__WEBPACK_IMPORTED_MODULE_0__.initialize)();\n  return (0,_init__WEBPACK_IMPORTED_MODULE_0__.ensureServiceIsRunning)().getCheckSums(bytes, segmentSize, dataBlocks, parityBlocks);\n};\n\n\n//# sourceURL=webpack://@bnb-chain/greenfiled-file-handle/./src/browser/index.js?");

/***/ }),

/***/ "./src/browser/init.js":
/*!*****************************!*\
  !*** ./src/browser/init.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureServiceIsRunning: () => (/* binding */ ensureServiceIsRunning),\n/* harmony export */   initialize: () => (/* binding */ initialize),\n/* harmony export */   instantiateWASM: () => (/* binding */ instantiateWASM)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ \"./src/browser/index.js\");\n/* harmony import */ var _wasm_exec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wasm_exec.js */ \"./src/browser/wasm_exec.js\");\n\n\n\nconst initialize = async () => {\n  if (!initializePromise) {\n    const input = window.__PUBLIC_FILE_HANDLE_WASM_PATH__;\n    initializePromise = (0,___WEBPACK_IMPORTED_MODULE_0__.startRunningService)(input).catch((err) => {\n      // Let the caller try again if this fails.\n      initializePromise = void 0;\n      // But still, throw the error back up the caller.\n      throw err;\n    });\n  }\n  longLivedService = longLivedService || (await initializePromise);\n};\n\nconst instantiateWASM = async (wasmURL) => {\n  let module = undefined;\n  const go = new _wasm_exec_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n\n  if (!WebAssembly.instantiateStreaming) {\n    WebAssembly.instantiateStreaming = async (resp, importObject) => {\n      const source = await (await resp).arrayBuffer();\n      return await WebAssembly.instantiate(source, importObject);\n    };\n  }\n\n  const fetchAndInstantiateTask = async () => {\n    return WebAssembly.instantiateStreaming(fetch(wasmURL), go.importObject);\n  };\n  module = await fetchAndInstantiateTask();\n  go.run(module.instance);\n\n  return module;\n};\n\nlet initializePromise;\nlet longLivedService;\n\nconst ensureServiceIsRunning = () => {\n  if (!initializePromise) throw new Error('You need to call \"initialize\" before calling this');\n  if (!longLivedService)\n    throw new Error(\n      'You need to wait for the promise returned from \"initialize\" to be resolved before calling this',\n    );\n  return longLivedService;\n};\n\n\n//# sourceURL=webpack://@bnb-chain/greenfiled-file-handle/./src/browser/init.js?");

/***/ }),

/***/ "./src/browser/wasm_exec.js":
/*!**********************************!*\
  !*** ./src/browser/wasm_exec.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Go)\n/* harmony export */ });\n/* eslint-disable */\n// @ts-nocheck\n// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n//\n// This file has been modified for use by the TinyGo compiler.\n\n// Map multiple JavaScript environments to a single common API,\n// preferring web standards over Node.js API.\n//\n// Environments considered:\n// - Browsers\n// - Node.js\n// - Electron\n// - Parcel\n\nif (typeof __webpack_require__.g !== 'undefined') {\n  // global already exists\n} else if (typeof window !== 'undefined') {\n  window.global = window;\n} else if (typeof self !== 'undefined') {\n  self.global = self;\n} else {\n  throw new Error('cannot export Go (neither global, window nor self is defined)');\n}\n\nif (!__webpack_require__.g.require && \"function\" !== 'undefined') {\n  __webpack_require__.g.require = __webpack_require__(\"./src/browser sync recursive\");\n}\n\nif (!__webpack_require__.g.fs && __webpack_require__.g.require) {\n  __webpack_require__.g.fs = __webpack_require__(/*! fs */ \"?e3b2\");\n}\n\nconst enosys = () => {\n  const err = new Error('not implemented');\n  err.code = 'ENOSYS';\n  return err;\n};\n\nif (!__webpack_require__.g.fs) {\n  let outputBuf = '';\n  __webpack_require__.g.fs = {\n    constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 }, // unused\n    writeSync(fd, buf) {\n      outputBuf += decoder.decode(buf);\n      const nl = outputBuf.lastIndexOf('\\n');\n      if (nl != -1) {\n        console.log(outputBuf.substr(0, nl));\n        outputBuf = outputBuf.substr(nl + 1);\n      }\n      return buf.length;\n    },\n    write(fd, buf, offset, length, position, callback) {\n      if (offset !== 0 || length !== buf.length || position !== null) {\n        callback(enosys());\n        return;\n      }\n      const n = this.writeSync(fd, buf);\n      callback(null, n);\n    },\n    chmod(path, mode, callback) {\n      callback(enosys());\n    },\n    chown(path, uid, gid, callback) {\n      callback(enosys());\n    },\n    close(fd, callback) {\n      callback(enosys());\n    },\n    fchmod(fd, mode, callback) {\n      callback(enosys());\n    },\n    fchown(fd, uid, gid, callback) {\n      callback(enosys());\n    },\n    fstat(fd, callback) {\n      callback(enosys());\n    },\n    fsync(fd, callback) {\n      callback(null);\n    },\n    ftruncate(fd, length, callback) {\n      callback(enosys());\n    },\n    lchown(path, uid, gid, callback) {\n      callback(enosys());\n    },\n    link(path, link, callback) {\n      callback(enosys());\n    },\n    lstat(path, callback) {\n      callback(enosys());\n    },\n    mkdir(path, perm, callback) {\n      callback(enosys());\n    },\n    open(path, flags, mode, callback) {\n      callback(enosys());\n    },\n    read(fd, buffer, offset, length, position, callback) {\n      callback(enosys());\n    },\n    readdir(path, callback) {\n      callback(enosys());\n    },\n    readlink(path, callback) {\n      callback(enosys());\n    },\n    rename(from, to, callback) {\n      callback(enosys());\n    },\n    rmdir(path, callback) {\n      callback(enosys());\n    },\n    stat(path, callback) {\n      callback(enosys());\n    },\n    symlink(path, link, callback) {\n      callback(enosys());\n    },\n    truncate(path, length, callback) {\n      callback(enosys());\n    },\n    unlink(path, callback) {\n      callback(enosys());\n    },\n    utimes(path, atime, mtime, callback) {\n      callback(enosys());\n    },\n  };\n}\n\nif (!__webpack_require__.g.process) {\n  __webpack_require__.g.process = {\n    getuid() {\n      return -1;\n    },\n    getgid() {\n      return -1;\n    },\n    geteuid() {\n      return -1;\n    },\n    getegid() {\n      return -1;\n    },\n    getgroups() {\n      throw enosys();\n    },\n    pid: -1,\n    ppid: -1,\n    umask() {\n      throw enosys();\n    },\n    cwd() {\n      throw enosys();\n    },\n    chdir() {\n      throw enosys();\n    },\n  };\n}\n\nif (!__webpack_require__.g.crypto) {\n  const nodeCrypto = __webpack_require__(/*! crypto */ \"?49bc\");\n  __webpack_require__.g.crypto = {\n    getRandomValues(b) {\n      nodeCrypto.randomFillSync(b);\n    },\n  };\n}\n\nif (!__webpack_require__.g.performance) {\n  __webpack_require__.g.performance = {\n    now() {\n      const [sec, nsec] = process.hrtime();\n      return sec * 1000 + nsec / 1000000;\n    },\n  };\n}\n\nif (!__webpack_require__.g.TextEncoder) {\n  __webpack_require__.g.TextEncoder = (__webpack_require__(/*! util */ \"?a672\").TextEncoder);\n}\n\nif (!__webpack_require__.g.TextDecoder) {\n  __webpack_require__.g.TextDecoder = (__webpack_require__(/*! util */ \"?a672\").TextDecoder);\n}\n\n// End of polyfills for common API.\n\nconst encoder = new TextEncoder('utf-8');\nconst decoder = new TextDecoder('utf-8');\nvar logLine = [];\n\nclass Go {\n  importObject;\n  constructor() {\n    this._callbackTimeouts = new Map();\n    this._nextCallbackTimeoutID = 1;\n\n    const mem = () => {\n      // The buffer may change when requesting more memory.\n      return new DataView(this._inst.exports.memory.buffer);\n    };\n\n    const setInt64 = (addr, v) => {\n      mem().setUint32(addr + 0, v, true);\n      mem().setUint32(addr + 4, Math.floor(v / 4294967296), true);\n    };\n\n    const getInt64 = (addr) => {\n      const low = mem().getUint32(addr + 0, true);\n      const high = mem().getInt32(addr + 4, true);\n      return low + high * 4294967296;\n    };\n\n    const loadValue = (addr) => {\n      const f = mem().getFloat64(addr, true);\n      if (f === 0) {\n        return undefined;\n      }\n      if (!isNaN(f)) {\n        return f;\n      }\n\n      const id = mem().getUint32(addr, true);\n      return this._values[id];\n    };\n\n    const storeValue = (addr, v) => {\n      const nanHead = 0x7ff80000;\n\n      if (typeof v === 'number') {\n        if (isNaN(v)) {\n          mem().setUint32(addr + 4, nanHead, true);\n          mem().setUint32(addr, 0, true);\n          return;\n        }\n        if (v === 0) {\n          mem().setUint32(addr + 4, nanHead, true);\n          mem().setUint32(addr, 1, true);\n          return;\n        }\n        mem().setFloat64(addr, v, true);\n        return;\n      }\n\n      switch (v) {\n        case undefined:\n          mem().setFloat64(addr, 0, true);\n          return;\n        case null:\n          mem().setUint32(addr + 4, nanHead, true);\n          mem().setUint32(addr, 2, true);\n          return;\n        case true:\n          mem().setUint32(addr + 4, nanHead, true);\n          mem().setUint32(addr, 3, true);\n          return;\n        case false:\n          mem().setUint32(addr + 4, nanHead, true);\n          mem().setUint32(addr, 4, true);\n          return;\n      }\n\n      let id = this._ids.get(v);\n      if (id === undefined) {\n        id = this._idPool.pop();\n        if (id === undefined) {\n          id = this._values.length;\n        }\n        this._values[id] = v;\n        this._goRefCounts[id] = 0;\n        this._ids.set(v, id);\n      }\n      this._goRefCounts[id]++;\n      let typeFlag = 1;\n      switch (typeof v) {\n        case 'string':\n          typeFlag = 2;\n          break;\n        case 'symbol':\n          typeFlag = 3;\n          break;\n        case 'function':\n          typeFlag = 4;\n          break;\n      }\n      mem().setUint32(addr + 4, nanHead | typeFlag, true);\n      mem().setUint32(addr, id, true);\n    };\n\n    const loadSlice = (array, len, cap) => {\n      return new Uint8Array(this._inst.exports.memory.buffer, array, len);\n    };\n\n    const loadSliceOfValues = (array, len, cap) => {\n      const a = new Array(len);\n      for (let i = 0; i < len; i++) {\n        a[i] = loadValue(array + i * 8);\n      }\n      return a;\n    };\n\n    const loadString = (ptr, len) => {\n      return decoder.decode(new DataView(this._inst.exports.memory.buffer, ptr, len));\n    };\n\n    const timeOrigin = Date.now() - performance.now();\n    this.importObject = {\n      wasi_snapshot_preview1: {\n        // https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md#fd_write\n        fd_write: function (fd, iovs_ptr, iovs_len, nwritten_ptr) {\n          let nwritten = 0;\n          if (fd == 1) {\n            for (let iovs_i = 0; iovs_i < iovs_len; iovs_i++) {\n              let iov_ptr = iovs_ptr + iovs_i * 8; // assuming wasm32\n              let ptr = mem().getUint32(iov_ptr + 0, true);\n              let len = mem().getUint32(iov_ptr + 4, true);\n              nwritten += len;\n              for (let i = 0; i < len; i++) {\n                let c = mem().getUint8(ptr + i);\n                if (c == 13) {\n                  // CR\n                  // ignore\n                } else if (c == 10) {\n                  // LF\n                  // write line\n                  let line = decoder.decode(new Uint8Array(logLine));\n                  logLine = [];\n                  console.log(line);\n                } else {\n                  logLine.push(c);\n                }\n              }\n            }\n          } else {\n            console.error('invalid file descriptor:', fd);\n          }\n          mem().setUint32(nwritten_ptr, nwritten, true);\n          return 0;\n        },\n        fd_close: () => 0, // dummy\n        fd_fdstat_get: () => 0, // dummy\n        fd_seek: () => 0, // dummy\n        proc_exit: (code) => {\n          if (__webpack_require__.g.process) {\n            // Node.js\n            process.exit(code);\n          } else {\n            // Can't exit in a browser.\n            throw 'trying to exit with code ' + code;\n          }\n        },\n        random_get: (bufPtr, bufLen) => {\n          crypto.getRandomValues(loadSlice(bufPtr, bufLen));\n          return 0;\n        },\n      },\n      env: {\n        // func ticks() float64\n        'runtime.ticks': () => {\n          return timeOrigin + performance.now();\n        },\n\n        // func sleepTicks(timeout float64)\n        'runtime.sleepTicks': (timeout) => {\n          // Do not sleep, only reactivate scheduler after the given timeout.\n          setTimeout(this._inst.exports.go_scheduler, timeout);\n        },\n\n        // func finalizeRef(v ref)\n        'syscall/js.finalizeRef': (v_addr) => {\n          // Note: TinyGo does not support finalizers so this is only called\n          // for one specific case, by js.go:jsString.\n          const id = mem().getUint32(v_addr, true);\n          this._goRefCounts[id]--;\n          if (this._goRefCounts[id] === 0) {\n            const v = this._values[id];\n            this._values[id] = null;\n            this._ids.delete(v);\n            this._idPool.push(id);\n          }\n        },\n\n        // func stringVal(value string) ref\n        'syscall/js.stringVal': (ret_ptr, value_ptr, value_len) => {\n          const s = loadString(value_ptr, value_len);\n          storeValue(ret_ptr, s);\n        },\n\n        // func valueGet(v ref, p string) ref\n        'syscall/js.valueGet': (retval, v_addr, p_ptr, p_len) => {\n          let prop = loadString(p_ptr, p_len);\n          let value = loadValue(v_addr);\n          let result = Reflect.get(value, prop);\n          storeValue(retval, result);\n        },\n\n        // func valueSet(v ref, p string, x ref)\n        'syscall/js.valueSet': (v_addr, p_ptr, p_len, x_addr) => {\n          const v = loadValue(v_addr);\n          const p = loadString(p_ptr, p_len);\n          const x = loadValue(x_addr);\n          Reflect.set(v, p, x);\n        },\n\n        // func valueDelete(v ref, p string)\n        'syscall/js.valueDelete': (v_addr, p_ptr, p_len) => {\n          const v = loadValue(v_addr);\n          const p = loadString(p_ptr, p_len);\n          Reflect.deleteProperty(v, p);\n        },\n\n        // func valueIndex(v ref, i int) ref\n        'syscall/js.valueIndex': (ret_addr, v_addr, i) => {\n          storeValue(ret_addr, Reflect.get(loadValue(v_addr), i));\n        },\n\n        // valueSetIndex(v ref, i int, x ref)\n        'syscall/js.valueSetIndex': (v_addr, i, x_addr) => {\n          Reflect.set(loadValue(v_addr), i, loadValue(x_addr));\n        },\n\n        // func valueCall(v ref, m string, args []ref) (ref, bool)\n        'syscall/js.valueCall': (ret_addr, v_addr, m_ptr, m_len, args_ptr, args_len, args_cap) => {\n          const v = loadValue(v_addr);\n          const name = loadString(m_ptr, m_len);\n          const args = loadSliceOfValues(args_ptr, args_len, args_cap);\n          try {\n            const m = Reflect.get(v, name);\n            storeValue(ret_addr, Reflect.apply(m, v, args));\n            mem().setUint8(ret_addr + 8, 1);\n          } catch (err) {\n            storeValue(ret_addr, err);\n            mem().setUint8(ret_addr + 8, 0);\n          }\n        },\n\n        // func valueInvoke(v ref, args []ref) (ref, bool)\n        'syscall/js.valueInvoke': (ret_addr, v_addr, args_ptr, args_len, args_cap) => {\n          try {\n            const v = loadValue(v_addr);\n            const args = loadSliceOfValues(args_ptr, args_len, args_cap);\n            storeValue(ret_addr, Reflect.apply(v, undefined, args));\n            mem().setUint8(ret_addr + 8, 1);\n          } catch (err) {\n            storeValue(ret_addr, err);\n            mem().setUint8(ret_addr + 8, 0);\n          }\n        },\n\n        // func valueNew(v ref, args []ref) (ref, bool)\n        'syscall/js.valueNew': (ret_addr, v_addr, args_ptr, args_len, args_cap) => {\n          const v = loadValue(v_addr);\n          const args = loadSliceOfValues(args_ptr, args_len, args_cap);\n          try {\n            storeValue(ret_addr, Reflect.construct(v, args));\n            mem().setUint8(ret_addr + 8, 1);\n          } catch (err) {\n            storeValue(ret_addr, err);\n            mem().setUint8(ret_addr + 8, 0);\n          }\n        },\n\n        // func valueLength(v ref) int\n        'syscall/js.valueLength': (v_addr) => {\n          return loadValue(v_addr).length;\n        },\n\n        // valuePrepareString(v ref) (ref, int)\n        'syscall/js.valuePrepareString': (ret_addr, v_addr) => {\n          const s = String(loadValue(v_addr));\n          const str = encoder.encode(s);\n          storeValue(ret_addr, str);\n          setInt64(ret_addr + 8, str.length);\n        },\n\n        // valueLoadString(v ref, b []byte)\n        'syscall/js.valueLoadString': (v_addr, slice_ptr, slice_len, slice_cap) => {\n          const str = loadValue(v_addr);\n          loadSlice(slice_ptr, slice_len, slice_cap).set(str);\n        },\n\n        // func valueInstanceOf(v ref, t ref) bool\n        'syscall/js.valueInstanceOf': (v_addr, t_addr) => {\n          return loadValue(v_addr) instanceof loadValue(t_addr);\n        },\n\n        // func copyBytesToGo(dst []byte, src ref) (int, bool)\n        'syscall/js.copyBytesToGo': (ret_addr, dest_addr, dest_len, dest_cap, source_addr) => {\n          let num_bytes_copied_addr = ret_addr;\n          let returned_status_addr = ret_addr + 4; // Address of returned boolean status variable\n\n          const dst = loadSlice(dest_addr, dest_len);\n          const src = loadValue(source_addr);\n          if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n            mem().setUint8(returned_status_addr, 0); // Return \"not ok\" status\n            return;\n          }\n          const toCopy = src.subarray(0, dst.length);\n          dst.set(toCopy);\n          setInt64(num_bytes_copied_addr, toCopy.length);\n          mem().setUint8(returned_status_addr, 1); // Return \"ok\" status\n        },\n\n        // copyBytesToJS(dst ref, src []byte) (int, bool)\n        // Originally copied from upstream Go project, then modified:\n        //   https://github.com/golang/go/blob/3f995c3f3b43033013013e6c7ccc93a9b1411ca9/misc/wasm/wasm_exec.js#L404-L416\n        'syscall/js.copyBytesToJS': (ret_addr, dest_addr, source_addr, source_len, source_cap) => {\n          let num_bytes_copied_addr = ret_addr;\n          let returned_status_addr = ret_addr + 4; // Address of returned boolean status variable\n\n          const dst = loadValue(dest_addr);\n          const src = loadSlice(source_addr, source_len);\n          if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n            mem().setUint8(returned_status_addr, 0); // Return \"not ok\" status\n            return;\n          }\n          const toCopy = src.subarray(0, dst.length);\n          dst.set(toCopy);\n          setInt64(num_bytes_copied_addr, toCopy.length);\n          mem().setUint8(returned_status_addr, 1); // Return \"ok\" status\n        },\n      },\n    };\n  }\n\n  async run(instance) {\n    this._inst = instance;\n    this._values = [\n      // JS values that Go currently has references to, indexed by reference id\n      NaN,\n      0,\n      null,\n      true,\n      false,\n      __webpack_require__.g,\n      this,\n    ];\n    this._goRefCounts = []; // number of references that Go has to a JS value, indexed by reference id\n    this._ids = new Map(); // mapping from JS values to reference ids\n    this._idPool = []; // unused ids that have been garbage collected\n    this.exited = false; // whether the Go program has exited\n\n    const mem = new DataView(this._inst.exports.memory.buffer);\n\n    while (true) {\n      const callbackPromise = new Promise((resolve) => {\n        this._resolveCallbackPromise = () => {\n          if (this.exited) {\n            throw new Error('bad callback: Go program has already exited');\n          }\n          setTimeout(resolve, 0); // make sure it is asynchronous\n        };\n      });\n      this._inst.exports._start();\n      if (this.exited) {\n        break;\n      }\n      await callbackPromise;\n    }\n  }\n\n  _resume() {\n    if (this.exited) {\n      throw new Error('Go program has already exited');\n    }\n    this._inst.exports.resume();\n    if (this.exited) {\n      this._resolveExitPromise();\n    }\n  }\n\n  _makeFuncWrapper(id) {\n    const go = this;\n    return function () {\n      const event = { id: id, this: this, args: arguments };\n      go._pendingEvent = event;\n      go._resume();\n      return event.result;\n    };\n  }\n}\n\n// if (\n// \tglobal.require &&\n// \tglobal.require.main === module &&\n// \tglobal.process &&\n// \tglobal.process.versions &&\n// \t!global.process.versions.electron\n// ) {\n// \tif (process.argv.length != 3) {\n// \t\tconsole.error(\"usage: go_js_wasm_exec [wasm binary] [arguments]\");\n// \t\tprocess.exit(1);\n// \t}\n\n// \tconst go = new Go();\n// \tWebAssembly.instantiate(fs.readFileSync(process.argv[2]), go.importObject).then((result) => {\n// \t\treturn go.run(result.instance);\n// \t}).catch((err) => {\n// \t\tconsole.error(err);\n// \t\tprocess.exit(1);\n// \t});\n// }\n\n\n//# sourceURL=webpack://@bnb-chain/greenfiled-file-handle/./src/browser/wasm_exec.js?");

/***/ }),

/***/ "./src/browser sync recursive":
/*!***************************!*\
  !*** ./src/browser/ sync ***!
  \***************************/
/***/ ((module) => {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./src/browser sync recursive\";\nmodule.exports = webpackEmptyContext;\n\n//# sourceURL=webpack://@bnb-chain/greenfiled-file-handle/./src/browser/_sync?");

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_DATA_BLOCKS: () => (/* binding */ DEFAULT_DATA_BLOCKS),\n/* harmony export */   DEFAULT_PARITY_BLOCKS: () => (/* binding */ DEFAULT_PARITY_BLOCKS),\n/* harmony export */   DEFAULT_SEGMENT_SIZE: () => (/* binding */ DEFAULT_SEGMENT_SIZE)\n/* harmony export */ });\nconst DEFAULT_SEGMENT_SIZE = 16 * 1024 * 1024;\nconst DEFAULT_DATA_BLOCKS = 4;\nconst DEFAULT_PARITY_BLOCKS = 2;\n\n\n//# sourceURL=webpack://@bnb-chain/greenfiled-file-handle/./src/constants.js?");

/***/ }),

/***/ "?49bc":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://@bnb-chain/greenfiled-file-handle/crypto_(ignored)?");

/***/ }),

/***/ "?e3b2":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://@bnb-chain/greenfiled-file-handle/fs_(ignored)?");

/***/ }),

/***/ "?a672":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://@bnb-chain/greenfiled-file-handle/util_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/browser/index.js");
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;