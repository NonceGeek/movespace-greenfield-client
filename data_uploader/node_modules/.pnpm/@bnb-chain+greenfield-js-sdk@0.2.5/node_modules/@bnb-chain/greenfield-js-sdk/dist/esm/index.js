import 'reflect-metadata';
import { injectable, inject, container, delay as delay$1 } from 'tsyringe';
import { Any } from '@bnb-chain/greenfield-cosmos-types/google/protobuf/any';
import mapValues from 'lodash.mapvalues';
import sortBy from 'lodash.sortby';
import { arrayify, hexlify, joinSignature } from '@ethersproject/bytes';
import { TypedDataUtils, SignTypedDataVersion, signTypedData } from '@metamask/eth-sig-util';
import { publicKeyCreate } from 'ethereum-cryptography/secp256k1-compat';
import { ServiceClientImpl as ServiceClientImpl$1 } from '@bnb-chain/greenfield-cosmos-types/cosmos/base/tendermint/v1beta1/query';
import Long from 'long';
export { default as Long } from 'long';
import { QueryClientImpl } from '@bnb-chain/greenfield-cosmos-types/cosmos/auth/v1beta1/query';
import { QueryClientImpl as QueryClientImpl$1 } from '@bnb-chain/greenfield-cosmos-types/cosmos/bank/v1beta1/query';
import { QueryClientImpl as QueryClientImpl$6 } from '@bnb-chain/greenfield-cosmos-types/cosmos/crosschain/v1/query';
import { MsgClientImpl, MsgSetWithdrawAddress, MsgWithdrawValidatorCommission, MsgWithdrawDelegatorReward, MsgFundCommunityPool } from '@bnb-chain/greenfield-cosmos-types/cosmos/distribution/v1beta1/tx';
import { QueryClientImpl as QueryClientImpl$9 } from '@bnb-chain/greenfield-cosmos-types/cosmos/feegrant/v1beta1/query';
import { QueryClientImpl as QueryClientImpl$a } from '@bnb-chain/greenfield-cosmos-types/cosmos/gashub/v1beta1/query';
import { QueryClientImpl as QueryClientImpl$7 } from '@bnb-chain/greenfield-cosmos-types/cosmos/oracle/v1/query';
import { QueryClientImpl as QueryClientImpl$c } from '@bnb-chain/greenfield-cosmos-types/cosmos/staking/v1beta1/query';
import { QueryClientImpl as QueryClientImpl$8 } from '@bnb-chain/greenfield-cosmos-types/greenfield/bridge/query';
import { QueryClientImpl as QueryClientImpl$5 } from '@bnb-chain/greenfield-cosmos-types/greenfield/challenge/query';
import { QueryClientImpl as QueryClientImpl$2 } from '@bnb-chain/greenfield-cosmos-types/greenfield/payment/query';
import { QueryClientImpl as QueryClientImpl$4 } from '@bnb-chain/greenfield-cosmos-types/greenfield/sp/query';
import { QueryClientImpl as QueryClientImpl$3 } from '@bnb-chain/greenfield-cosmos-types/greenfield/storage/query';
import { QueryClientImpl as QueryClientImpl$b } from '@bnb-chain/greenfield-cosmos-types/greenfield/virtualgroup/query';
import { QueryClient, setupAuthExtension, setupAuthzExtension, setupBankExtension, setupDistributionExtension, setupFeegrantExtension, setupGovExtension, setupIbcExtension, setupMintExtension, setupSlashingExtension, setupStakingExtension, setupTxExtension, createProtobufRpcClient, StargateClient } from '@cosmjs/stargate';
import { Tendermint37Client } from '@cosmjs/tendermint-rpc';
import { toUtf8Bytes } from '@ethersproject/strings';
import { getEddsaCompressedPublicKey, eddsaSign } from '@bnb-chain/greenfield-zk-crypto';
import fetch$1, { Headers as Headers$1 } from 'cross-fetch';
import { XMLParser } from 'fast-xml-parser';
import { recoverPublicKey, computePublicKey, SigningKey } from '@ethersproject/signing-key';
import { keccak256 } from 'ethereum-cryptography/keccak.js';
import { utf8ToBytes } from 'ethereum-cryptography/utils.js';
import { toHex as toHex$1, utf8ToBytes as utf8ToBytes$1, bytesToUtf8, hexToBytes as hexToBytes$1 } from 'ethereum-cryptography/utils';
import { BasicAllowance, AllowedMsgAllowance } from '@bnb-chain/greenfield-cosmos-types/cosmos/feegrant/v1beta1/feegrant';
import { MsgSubmit, MsgAttest } from '@bnb-chain/greenfield-cosmos-types/greenfield/challenge/tx';
import { MsgClaim } from '@bnb-chain/greenfield-cosmos-types/cosmos/oracle/v1/tx';
import { MsgTransferOut } from '@bnb-chain/greenfield-cosmos-types/greenfield/bridge/tx';
import { MsgPutPolicy, MsgDeletePolicy, MsgCreateBucket, MsgDeleteBucket, MsgUpdateBucketInfo, MsgMigrateBucket, MsgMirrorGroup, MsgMirrorBucket, MsgMirrorObject, MsgCreateGroup, MsgDeleteGroup, MsgUpdateGroupMember, MsgUpdateGroupExtra, MsgLeaveGroup, MsgCreateObject, MsgCancelCreateObject, MsgDeleteObject, MsgUpdateObjectInfo } from '@bnb-chain/greenfield-cosmos-types/greenfield/storage/tx';
import { MsgGrantAllowance, MsgRevokeAllowance } from '@bnb-chain/greenfield-cosmos-types/cosmos/feegrant/v1beta1/tx';
import { fromTimestamp, bytesFromBase64, base64FromBytes } from '@bnb-chain/greenfield-cosmos-types/helpers';
export * from '@bnb-chain/greenfield-cosmos-types/helpers';
import cloneDeep from 'lodash.clonedeep';
import { ResourceType } from '@bnb-chain/greenfield-cosmos-types/greenfield/resource/types';
import { MsgCreatePaymentAccount, MsgDeposit, MsgWithdraw, MsgDisableRefund } from '@bnb-chain/greenfield-cosmos-types/greenfield/payment/tx';
import { voteOptionToJSON } from '@bnb-chain/greenfield-cosmos-types/cosmos/gov/v1/gov';
import { MsgVote } from '@bnb-chain/greenfield-cosmos-types/cosmos/gov/v1/tx';
import { actionTypeFromJSON, principalTypeFromJSON } from '@bnb-chain/greenfield-cosmos-types/greenfield/permission/common';
import * as common$1 from '@bnb-chain/greenfield-cosmos-types/greenfield/permission/common';
export { common$1 as PermissionTypes };
import { Status } from '@bnb-chain/greenfield-cosmos-types/greenfield/sp/types';
import { MsgSettle } from '@bnb-chain/greenfield-cosmos-types/greenfield/virtualgroup/tx';
import { MsgEditValidator } from '@bnb-chain/greenfield-cosmos-types/cosmos/staking/v1beta1/tx';
import { PubKey } from '@bnb-chain/greenfield-cosmos-types/cosmos/crypto/secp256k1/keys';
import { visibilityTypeFromJSON, redundancyTypeFromJSON } from '@bnb-chain/greenfield-cosmos-types/greenfield/storage/common';
import * as common from '@bnb-chain/greenfield-cosmos-types/greenfield/storage/common';
export { common as StorageEnums };
import * as timestamp from '@bnb-chain/greenfield-cosmos-types/google/protobuf/timestamp';
export { timestamp as TimestampTypes };
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import timezone from 'dayjs/plugin/timezone';
import { formatEther } from '@ethersproject/units';
import { UInt64Value } from '@bnb-chain/greenfield-cosmos-types/greenfield/common/wrapper';
import { ServiceClientImpl, SimulateRequest } from '@bnb-chain/greenfield-cosmos-types/cosmos/tx/v1beta1/service';
import { TxRaw, TxBody, Tx, AuthInfo } from '@bnb-chain/greenfield-cosmos-types/cosmos/tx/v1beta1/tx';
import { makeAuthInfoBytes } from '@cosmjs/proto-signing';
import { BaseAccount } from '@bnb-chain/greenfield-cosmos-types/cosmos/auth/v1beta1/auth';
import { MsgMultiSend, MsgSend } from '@bnb-chain/greenfield-cosmos-types/cosmos/bank/v1beta1/tx';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

const typeWrapper = (type, msg) => {
    return {
        ...msg,
        type,
    };
};
const generateMsg = (typeUrl, msgBytes) => {
    return Any.fromPartial({
        typeUrl,
        value: msgBytes,
    });
};
const createEIP712 = (types, chainId, message) => {
    return {
        types,
        primaryType: 'Tx',
        domain: {
            name: 'Greenfield Tx',
            version: '1.0.0',
            chainId,
            verifyingContract: 'greenfield',
            salt: '0',
        },
        message,
    };
};
const generateMessage = (accountNumber, sequence, chainCosmosId, memo, fee, msg, timeoutHeight) => {
    let res = {
        account_number: accountNumber,
        chain_id: chainCosmosId,
        sequence,
        memo,
        fee,
        timeout_height: timeoutHeight,
    };
    if (msg.hasOwnProperty('msg1')) {
        res = {
            ...res,
            ...msg,
        };
    }
    else {
        res.msg1 = msg;
    }
    return res;
};
const generateTypes = (newTypes) => {
    const types = {
        Coin: [
            { name: 'denom', type: 'string' },
            { name: 'amount', type: 'uint256' },
        ],
        EIP712Domain: [
            { name: 'name', type: 'string' },
            { name: 'version', type: 'string' },
            { name: 'chainId', type: 'uint256' },
            { name: 'verifyingContract', type: 'string' },
            { name: 'salt', type: 'string' },
        ],
        Fee: [
            { name: 'amount', type: 'Coin[]' },
            { name: 'gas_limit', type: 'uint256' },
            { name: 'payer', type: 'string' },
            { name: 'granter', type: 'string' },
        ],
        Tx: [
            {
                name: 'account_number',
                type: 'uint256',
            },
            {
                name: 'chain_id',
                type: 'uint256',
            },
            {
                name: 'fee',
                type: 'Fee',
            },
            {
                name: 'memo',
                type: 'string',
            },
            {
                name: 'sequence',
                type: 'uint256',
            },
            {
                name: 'timeout_height',
                type: 'uint256',
            },
        ],
    };
    if (Array.isArray(newTypes)) {
        for (let i = 0; i < newTypes.length; i++) {
            types.Tx.push({
                name: `msg${i + 1}`,
                type: `Msg${i + 1}`,
            });
        }
        Object.assign(types, ...newTypes);
    }
    else {
        types.Tx.push({
            name: 'msg1',
            type: 'Msg1',
        });
        Object.assign(types, newTypes);
    }
    return mapValues(types, (o) => {
        return sortBy(o, ['name']);
    });
};
const generateFee = (amount, denom, gas_limit, payer, granter) => {
    return {
        amount: [
            {
                amount,
                denom,
            },
        ],
        gas_limit,
        payer,
        granter,
    };
};
const mergeMultiEip712 = (eip712s) => {
    const res = [];
    eip712s.forEach((eip712, index) => {
        if (index === 0) {
            res.push(eip712);
        }
        else {
            const str = JSON.stringify(eip712);
            const reStr = str.replaceAll('Msg1', `Msg${index + 1}`);
            res.push(JSON.parse(reStr));
        }
    });
    return res;
};
const mergeMultiMessage = (txs) => {
    const msgs = txs.map((tx) => tx.MsgSDK);
    const res = {};
    msgs.forEach((msg, index) => {
        res[`msg${index + 1}`] = {
            ...msg,
            type: txs[index].typeUrl,
        };
    });
    return res;
};

/**
 * @priKey 0x prefix
 */
const getPubKeyByPriKey = (priKey) => {
    const privateKeyBytes = arrayify(priKey);
    const publicKeyBytes = publicKeyCreate(privateKeyBytes);
    const pk = hexlify(arrayify(publicKeyBytes));
    const pubKey = makeCosmsPubKey(pk);
    return pubKey;
};

/**
 * recover public key from signature
 *
 * @messageHash message hash
 * @signature message signature
 *
 * @returns uncompressed public key
 */
const recoverPk = ({ messageHash, signature }) => {
    const uncompressedPubKey = recoverPublicKey(messageHash, signature);
    return computePublicKey(uncompressedPubKey, true);
};
/**
 * @pk compressed public key from signature
 * @return eg. { typeUrl: '/ethermint.crypto.v1.ethsecp256k1.PubKey', value: 'CiEC+hp2uVKio9T7x0goOPyHgwUYiRsZ8MeYUrfRX8MxrzM=' }
 */
const makeCosmsPubKey = (pk) => {
    const pubKey = PubKey.fromPartial({
        key: arrayify(pk),
    });
    return {
        typeUrl: '/cosmos.crypto.eth.ethsecp256k1.PubKey',
        value: PubKey.encode(pubKey).finish(),
    };
};
const eip712Hash = (message) => {
    return TypedDataUtils.eip712Hash(JSON.parse(message), SignTypedDataVersion.V4);
};

/**
 * @addr wallet address
 * @message sign typed v4 data
 */
const sign712Tx = async (addr, message) => {
    // TODO: eth-sig-utils
    /* eslint-disable @typescript-eslint/no-explicit-any */
    const signature = await window.ethereum?.request({
        method: 'eth_signTypedData_v4',
        params: [addr, message],
    });
    const messageHash = eip712Hash(message);
    return {
        signature,
        messageHash,
    };
};
const defaultSignTypedData = async (addr, message) => {
    const signature = await window.ethereum?.request({
        method: 'eth_signTypedData_v4',
        params: [addr, message],
    });
    return signature;
};

const getGasFeeBySimulate = (simulateTxInfo, denom = 'BNB') => {
    if (!simulateTxInfo.gasInfo)
        throw new Error('gasInfo not found');
    const gasLimit = BigInt(simulateTxInfo.gasInfo?.gasUsed.toNumber());
    const gasPrice = simulateTxInfo.gasInfo?.minGasPrice.replace(denom, '');
    const gasFee = gasLimit * BigInt(gasPrice);
    return {
        gasLimit,
        gasPrice,
        gasFee: formatEther(String(gasFee)),
    };
};

let RpcQueryClient = class RpcQueryClient {
    constructor(rpcUrl) {
        this.rpcUrl = rpcUrl;
        this.rpcClient = null;
        this.txQueryClient = null;
        this.rpcUrl = rpcUrl;
    }
    async getRpcClient() {
        if (!this.rpcClient) {
            this.rpcClient = await makeRpcClient(this.rpcUrl);
        }
        return this.rpcClient;
    }
    async getQueryClient() {
        if (!this.txQueryClient) {
            const [client] = await makeClientWithExtension(this.rpcUrl);
            this.txQueryClient = client;
        }
        return this.txQueryClient;
    }
    async getAuthQueryClient() {
        const rpcClient = await this.getRpcClient();
        return new QueryClientImpl(rpcClient);
    }
    async getBankQueryClient() {
        const rpcClient = await this.getRpcClient();
        return new QueryClientImpl$1(rpcClient);
    }
    async getPaymentQueryClient() {
        const rpcClient = await this.getRpcClient();
        return new QueryClientImpl$2(rpcClient);
    }
    async getBucketQueryClient() {
        const rpcClient = await this.getRpcClient();
        return new QueryClientImpl$3(rpcClient);
    }
    async getSpQueryClient() {
        const rpcClient = await this.getRpcClient();
        return new QueryClientImpl$4(rpcClient);
    }
    async getChallengeQueryClient() {
        const rpcClient = await this.getRpcClient();
        return new QueryClientImpl$5(rpcClient);
    }
    async getCrosschainQueryClient() {
        const rpcClient = await this.getRpcClient();
        return new QueryClientImpl$6(rpcClient);
    }
    async getOracleQueryClient() {
        const rpcClient = await this.getRpcClient();
        return new QueryClientImpl$7(rpcClient);
    }
    async getBridgeQueryClient() {
        const rpcClient = await this.getRpcClient();
        return new QueryClientImpl$8(rpcClient);
    }
    async getFeeGrantQueryClient() {
        const rpcClient = await this.getRpcClient();
        return new QueryClientImpl$9(rpcClient);
    }
    async getStorageQueryClient() {
        const rpcClient = await this.getRpcClient();
        return new QueryClientImpl$3(rpcClient);
    }
    async getMsgClient() {
        const rpcClient = await this.getRpcClient();
        return new MsgClientImpl(rpcClient);
    }
    async getGashubClient() {
        const rpcClient = await this.getRpcClient();
        return new QueryClientImpl$a(rpcClient);
    }
    async getVirtualGroupClient() {
        const rpcClient = await this.getRpcClient();
        return new QueryClientImpl$b(rpcClient);
    }
    async getStakingClient() {
        const rpcClient = await this.getRpcClient();
        return new QueryClientImpl$c(rpcClient);
    }
};
RpcQueryClient = __decorate([
    injectable(),
    __param(0, inject('RPC_URL')),
    __metadata("design:paramtypes", [String])
], RpcQueryClient);
const makeClientWithExtension = async (rpcUrl) => {
    const tmClient = await Tendermint37Client.connect(rpcUrl);
    return [
        QueryClient.withExtensions(tmClient, setupAuthExtension, setupAuthzExtension, setupBankExtension, setupDistributionExtension, setupFeegrantExtension, setupGovExtension, setupIbcExtension, setupMintExtension, setupSlashingExtension, setupStakingExtension, setupTxExtension),
        tmClient,
    ];
};
const makeRpcClient = async (rpcUrl) => {
    const [, tmClient] = await makeClientWithExtension(rpcUrl);
    const rpc = createProtobufRpcClient(new QueryClient(tmClient));
    return rpc;
};

const MsgSendTypeUrl = '/cosmos.bank.v1beta1.MsgSend';
const MsgMultiSendTypeUrl = '/cosmos.bank.v1beta1.MsgMultiSend';
const MsgClaimTypeUrl = '/cosmos.oracle.v1.MsgClaim';
const MsgGrantAllowanceTypeUrl = '/cosmos.feegrant.v1beta1.MsgGrantAllowance';
const MsgRevokeAllowanceTypeUrl = '/cosmos.feegrant.v1beta1.MsgRevokeAllowance';
const MsgTransferOutTypeUrl = '/greenfield.bridge.MsgTransferOut';
const MsgAttestTypeUrl = '/greenfield.challenge.MsgAttest';
const MsgSubmitTypeUrl = '/greenfield.challenge.MsgSubmit';
const MsgCreatePaymentAccountTypeUrl = '/greenfield.payment.MsgCreatePaymentAccount';
const MsgDepositTypeUrl = '/greenfield.payment.MsgDeposit';
const MsgDisableRefundTypeUrl = '/greenfield.payment.MsgDisableRefund';
const MsgWithdrawTypeUrl = '/greenfield.payment.MsgWithdraw';
const MsgCancelCreateObjectTypeUrl = '/greenfield.storage.MsgCancelCreateObject';
const MsgMigrateBucketTypeUrl = '/greenfield.storage.MsgMigrateBucket';
const MsgCreateBucketTypeUrl = '/greenfield.storage.MsgCreateBucket';
const MsgCreateGroupTypeUrl = '/greenfield.storage.MsgCreateGroup';
const MsgCreateObjectTypeUrl = '/greenfield.storage.MsgCreateObject';
const MsgDeleteBucketTypeUrl = '/greenfield.storage.MsgDeleteBucket';
const MsgDeleteGroupTypeUrl = '/greenfield.storage.MsgDeleteGroup';
const MsgDeleteObjectTypeUrl = '/greenfield.storage.MsgDeleteObject';
const MsgDeletePolicyTypeUrl = '/greenfield.storage.MsgDeletePolicy';
const MsgLeaveGroupTypeUrl = '/greenfield.storage.MsgLeaveGroup';
const MsgMirrorBucketTypeUrl = '/greenfield.storage.MsgMirrorBucket';
const MsgMirrorGroupTypeUrl = '/greenfield.storage.MsgMirrorGroup';
const MsgMirrorObjectTypeUrl = '/greenfield.storage.MsgMirrorObject';
const MsgPutPolicyTypeUrl = '/greenfield.storage.MsgPutPolicy';
const MsgUpdateBucketInfoTypeUrl = '/greenfield.storage.MsgUpdateBucketInfo';
const MsgUpdateGroupExtraTypeUrl = '/greenfield.storage.MsgUpdateGroupExtra';
const MsgUpdateGroupMemberTypeUrl = '/greenfield.storage.MsgUpdateGroupMember';
const MsgUpdateObjectInfoTypeUrl = '/greenfield.storage.MsgUpdateObjectInfo';
const BasicAllowanceTypeUrl = '/cosmos.feegrant.v1beta1.BasicAllowance';
const AllowedMsgAllowanceTypeUrl = '/cosmos.feegrant.v1beta1.AllowedMsgAllowance';
const MsgEditValidatorTypeUrl = '/cosmos.staking.v1beta1.MsgEditValidator';
const MsgCreateValidatorTypeUrl = '/cosmos.staking.v1beta1.MsgCreateValidator';
const MsgVoteTypeUrl = '/cosmos.gov.v1.MsgVote';
const MsgWithdrawDelegatorRewardTypeUrl = '/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward';
const MsgSetWithdrawAddressTypeUrl = '/cosmos.distribution.v1beta1.MsgSetWithdrawAddress';
const MsgWithdrawValidatorCommissionTypeUrl = '/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission';
const MsgFundCommunityPoolTypeUrl = '/cosmos.distribution.v1beta1.MsgFundCommunityPool';
const MsgSettleTypeUrl = '/greenfield.virtualgroup.MsgSettle';

const EMPTY_STRING_SHA256 = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';
const MOCK_SIGNATURE = '1234567812345678123456781234567812345678123456781234567812345678';
const NORMAL_ERROR_CODE = 404;
const METHOD_GET = 'GET';
const METHOD_POST = 'POST';
const METHOD_PUT = 'PUT';

const ZERO_PUBKEY = '0x000000000000000000000000000000000000000000000000000000000000000000';
const DEFAULT_DENOM = 'BNB';

let TxClient = class TxClient {
    constructor(rpcUrl, chainId) {
        this.account = container.resolve(Account);
        this.rpcQueryClient = container.resolve(RpcQueryClient);
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
    }
    async tx(typeUrl, address, MsgSDKTypeEIP712, MsgSDK, msgBytes) {
        const txBodyBytes = this.getBodyBytes([
            {
                typeUrl,
                msgBytes,
            },
        ]);
        const tx = await this.multiTx([
            {
                metaTxInfo: {
                    typeUrl,
                    address,
                    MsgSDKTypeEIP712,
                    MsgSDK,
                    msgBytes,
                    bodyBytes: txBodyBytes,
                },
            },
        ]);
        return {
            simulate: tx.simulate,
            broadcast: tx.broadcast,
            metaTxInfo: {
                typeUrl,
                address,
                MsgSDKTypeEIP712,
                MsgSDK,
                msgBytes,
                bodyBytes: txBodyBytes,
            },
        };
    }
    async txRaw({ address, txRawHex, eip712MsgType, msgData, }) {
        const accountInfo = await this.account.getAccount(address);
        const txRawBytes = arrayify(txRawHex);
        const txRawP = TxRaw.decode(txRawBytes);
        return {
            simulate: async (opts) => {
                return await this.simulateRawTx(txRawP.bodyBytes, accountInfo, opts);
            },
            broadcast: async (opts) => {
                const { denom, gasLimit, gasPrice, payer, granter, privateKey, signTypedDataCallback = defaultSignTypedData, } = opts;
                const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), payer, granter);
                const wrapperTypes = generateTypes(eip712MsgType);
                const messages = generateMessage(accountInfo.accountNumber.toString(), accountInfo.sequence.toString(), this.chainId, '', fee, msgData, '0');
                const eip712 = createEIP712(wrapperTypes, this.chainId, messages);
                // console.log('eip712', eip712);
                const { pubKey, signature } = privateKey
                    ? this.getSignByPriKey(eip712, privateKey)
                    : await this.getSignByWallet(eip712, accountInfo.address, signTypedDataCallback);
                const authInfoBytes = this.getAuthInfoBytes({
                    denom,
                    sequence: accountInfo.sequence + '',
                    gasLimit,
                    gasPrice,
                    pubKey,
                    granter,
                    payer,
                });
                const txRaw = TxRaw.fromPartial({
                    bodyBytes: txRawP.bodyBytes,
                    authInfoBytes,
                    signatures: [arrayify(signature)],
                });
                const txBytes = TxRaw.encode(txRaw).finish();
                // console.log('txBytes', hexlify(txBytes));
                return await this.broadcastRawTx(txBytes);
            },
        };
    }
    getBodyBytes(params) {
        const multiMsgBytes = params.map((tx) => {
            return generateMsg(tx.typeUrl, tx.msgBytes);
        });
        const txBody = TxBody.fromPartial({
            messages: multiMsgBytes,
        });
        const txBodyBytes = TxBody.encode(txBody).finish();
        return txBodyBytes;
    }
    getSignByPriKey(eip712, privateKey) {
        const pubKey = getPubKeyByPriKey(privateKey);
        const signature = signTypedData({
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            data: eip712,
            version: SignTypedDataVersion.V4,
            privateKey: Buffer.from(arrayify(privateKey)),
        });
        return {
            pubKey,
            signature,
        };
    }
    async getSignByWallet(eip712, address, signTypedDataCallback) {
        const signature = await signTypedDataCallback(address, JSON.stringify(eip712));
        const messageHash = eip712Hash(JSON.stringify(eip712));
        const pk = recoverPk({
            signature,
            messageHash,
        });
        const pubKey = makeCosmsPubKey(pk);
        return {
            pubKey,
            signature,
        };
    }
    getAuthInfoBytes(params) {
        const { pubKey, denom = DEFAULT_DENOM, sequence, gasLimit, gasPrice, granter, payer } = params;
        if (!pubKey)
            throw new Error('pubKey is required');
        const feeAmount = [
            {
                denom,
                amount: String(BigInt(gasLimit) * BigInt(gasPrice)),
            },
        ];
        const authInfoBytes = makeAuthInfoBytes([{ pubkey: pubKey, sequence: Number(sequence) }], feeAmount, gasLimit, granter, payer, 712);
        return authInfoBytes;
    }
    async simulateRawTx(txBodyBytes, accountInfo, options) {
        const rpcClient = await this.rpcQueryClient.getRpcClient();
        const rpc = new ServiceClientImpl(rpcClient);
        const { denom } = options;
        const authInfoBytes = this.getAuthInfoBytes({
            sequence: accountInfo.sequence + '',
            denom,
            gasLimit: 0,
            gasPrice: '0',
            pubKey: makeCosmsPubKey(ZERO_PUBKEY),
            granter: '',
            payer: '',
        });
        const tx = Tx.fromPartial({
            authInfo: AuthInfo.decode(authInfoBytes),
            body: TxBody.decode(txBodyBytes),
            signatures: [Uint8Array.from([])],
        });
        const request = SimulateRequest.fromPartial({
            txBytes: Tx.encode(tx).finish(),
        });
        const res = await rpc.Simulate(request);
        return getGasFeeBySimulate(res, denom);
    }
    async broadcastRawTx(txRawBytes) {
        const tmClient = await Tendermint37Client.connect(this.rpcUrl);
        const client = await StargateClient.create(tmClient);
        return await client.broadcastTx(txRawBytes);
    }
    async multiTx(txResList) {
        const txs = txResList.map((txRes) => txRes.metaTxInfo);
        const accountInfo = await this.account.getAccount(txs[0].address);
        const txBodyBytes = this.getBodyBytes(txs);
        return {
            simulate: async (opts) => {
                return await this.simulateRawTx(txBodyBytes, accountInfo, opts);
            },
            broadcast: async (opts) => {
                const { denom, gasLimit, gasPrice, payer, granter, privateKey, signTypedDataCallback = defaultSignTypedData, } = opts;
                const types = mergeMultiEip712(txs.map((tx) => tx.MsgSDKTypeEIP712));
                const fee = generateFee(String(BigInt(gasLimit) * BigInt(gasPrice)), denom, String(gasLimit), payer, granter);
                const wrapperTypes = generateTypes(types);
                const multiMessages = mergeMultiMessage(txs);
                const messages = generateMessage(accountInfo.accountNumber.toString(), accountInfo.sequence.toString(), this.chainId, '', fee, multiMessages, '0');
                const eip712 = createEIP712(wrapperTypes, this.chainId, messages);
                const { pubKey, signature } = privateKey
                    ? this.getSignByPriKey(eip712, privateKey)
                    : await this.getSignByWallet(eip712, accountInfo.address, signTypedDataCallback);
                const authInfoBytes = this.getAuthInfoBytes({
                    denom,
                    sequence: accountInfo.sequence + '',
                    gasLimit,
                    gasPrice,
                    pubKey,
                    granter,
                    payer,
                });
                const txRaw = TxRaw.fromPartial({
                    bodyBytes: txBodyBytes,
                    authInfoBytes,
                    signatures: [arrayify(signature)],
                });
                const txBytes = TxRaw.encode(txRaw).finish();
                // console.log('txBytes', hexlify(txBytes));
                return await this.broadcastRawTx(txBytes);
            },
        };
    }
};
TxClient = __decorate([
    injectable(),
    __param(0, inject('RPC_URL')),
    __param(1, inject('CHAIN_ID')),
    __metadata("design:paramtypes", [String, String])
], TxClient);

const MsgMultiSendSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'inputs',
            type: 'TypeMsg1Inputs[]',
        },
        {
            name: 'outputs',
            type: 'TypeMsg1Outputs[]',
        },
    ],
    TypeMsg1Inputs: [
        {
            name: 'address',
            type: 'string',
        },
        {
            name: 'coins',
            type: 'TypeMsg1InputsCoins[]',
        },
    ],
    TypeMsg1InputsCoins: [
        {
            name: 'denom',
            type: 'string',
        },
        {
            name: 'amount',
            type: 'string',
        },
    ],
    TypeMsg1Outputs: [
        {
            name: 'address',
            type: 'string',
        },
        {
            name: 'coins',
            type: 'TypeMsg1OutputsCoins[]',
        },
    ],
    TypeMsg1OutputsCoins: [
        {
            name: 'denom',
            type: 'string',
        },
        {
            name: 'amount',
            type: 'string',
        },
    ],
};

const MsgSendSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'from_address',
            type: 'string',
        },
        {
            name: 'to_address',
            type: 'string',
        },
        {
            name: 'amount',
            type: 'TypeMsg1Amount[]',
        },
    ],
    TypeMsg1Amount: [
        {
            name: 'denom',
            type: 'string',
        },
        {
            name: 'amount',
            type: 'string',
        },
    ],
};

const MsgCreatePaymentAccountSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'creator',
            type: 'string',
        },
    ],
};

let Account = class Account {
    constructor(txClient) {
        this.txClient = txClient;
        this.queryClient = container.resolve(RpcQueryClient);
    }
    async multiTransfer(address, msg) {
        return await this.txClient.tx(MsgMultiSendTypeUrl, address, MsgMultiSendSDKTypeEIP712, MsgMultiSend.toSDK(msg), MsgMultiSend.encode(msg).finish());
    }
    async createPaymentAccount(msg) {
        return await this.txClient.tx(MsgCreatePaymentAccountTypeUrl, msg.creator, MsgCreatePaymentAccountSDKTypeEIP712, MsgCreatePaymentAccount.toSDK(msg), MsgCreatePaymentAccount.encode(msg).finish());
    }
    async getPaymentAccountsByOwner(owner) {
        const rpc = await this.queryClient.getPaymentQueryClient();
        return await rpc.PaymentAccountsByOwner({
            owner,
        });
    }
    async getModuleAccountByName(name) {
        const rpc = await this.queryClient.getAuthQueryClient();
        return rpc.ModuleAccountByName({
            name,
        });
    }
    async getModuleAccounts() {
        const rpc = await this.queryClient.getAuthQueryClient();
        return await rpc.ModuleAccounts();
    }
    async getAccountBalance(request) {
        const rpc = await this.queryClient.getBankQueryClient();
        return await rpc.Balance(request);
    }
    async getAccount(address) {
        const client = await this.queryClient.getQueryClient();
        const account = await client.auth.account(address);
        if (!account)
            return BaseAccount.fromJSON({});
        return BaseAccount.toJSON(BaseAccount.decode(account.value));
    }
    async transfer(msg) {
        return await this.txClient.tx(MsgSendTypeUrl, msg.fromAddress, MsgSendSDKTypeEIP712, MsgSend.toSDK(msg), MsgSend.encode(msg).finish());
    }
};
Account = __decorate([
    injectable(),
    __param(0, inject(delay$1(() => TxClient))),
    __metadata("design:paramtypes", [TxClient])
], Account);

let Basic = class Basic {
    constructor() {
        this.rpcQueryClient = container.resolve(RpcQueryClient);
    }
    async getNodeInfo() {
        const rpcClient = await this.rpcQueryClient.getRpcClient();
        const rpc = new ServiceClientImpl$1(rpcClient);
        return await rpc.GetNodeInfo();
    }
    async getLatestBlock() {
        const rpcClient = await this.rpcQueryClient.getRpcClient();
        const rpc = new ServiceClientImpl$1(rpcClient);
        return await rpc.GetLatestBlock();
    }
    async getLatestBlockHeight() {
        const latestBlock = await this.getLatestBlock();
        const height = latestBlock.sdkBlock?.header?.height;
        if (!height)
            return 0;
        return height.toNumber();
    }
    async getSyncing() {
        const rpcClient = await this.rpcQueryClient.getRpcClient();
        const rpc = new ServiceClientImpl$1(rpcClient);
        const syncing = await rpc.GetSyncing();
        return syncing.syncing;
    }
    async getBlockByHeight(height) {
        const rpcClient = await this.rpcQueryClient.getRpcClient();
        const rpc = new ServiceClientImpl$1(rpcClient);
        return await rpc.GetBlockByHeight({
            height: Long.fromInt(height),
        });
    }
    async GetLatestValidatorSet(request) {
        const rpcClient = await this.rpcQueryClient.getRpcClient();
        const rpc = new ServiceClientImpl$1(rpcClient);
        const validatorSet = await rpc.GetLatestValidatorSet(request);
        return validatorSet.blockHeight.toNumber();
    }
};
Basic = __decorate([
    injectable()
], Basic);

const getCurrentAccountPublicKey = async (seedString) => {
    if (window.getEddsaCompressedPublicKey) {
        return window.getEddsaCompressedPublicKey(seedString);
    }
    return await getEddsaCompressedPublicKey(seedString);
};
const signSignatureByEddsa = async (seedString, message) => {
    if (window.eddsaSign) {
        return window.eddsaSign(seedString, message);
    }
    return await eddsaSign(seedString, message);
};
const signMessagePersonalAPI = async (provider, message, address) => {
    return provider.send('personal_sign', [hexlify(message), address]).then((sign) => sign, (err) => {
        throw err;
    });
};
const generateSeed = async ({ message, address }, provider) => {
    const signedBytes = typeof message === 'string' ? toUtf8Bytes(message) : arrayify(message);
    const res = (await signMessagePersonalAPI(provider, signedBytes, address));
    const seed = arrayify(res?.result);
    return { seed };
};
const getCurrentSeedString = async ({ message, address, chainId, provider, }) => {
    const seedKey = `${chainId}-${address}`;
    const seeds = {};
    if (!seeds[seedKey]) {
        seeds[seedKey] = await generateSeed({ message, address }, provider);
        seeds[seedKey].seed = seeds[seedKey].seed
            .toString()
            .split(',')
            .map((x) => +x);
    }
    seeds[seedKey].seed = Uint8Array.from(seeds[seedKey].seed);
    return seeds[seedKey].seed;
};

function delayMs(duration) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(new Error('request time out'));
        }, duration);
    });
}
const fetchWithTimeout = async (fetchUrl = '', fetchOptions = {}, duration = 30000) => {
    try {
        const response = (await Promise.race([
            delayMs(duration),
            fetch$1(fetchUrl, fetchOptions),
        ]));
        return response;
    }
    catch (error) {
        return Promise.reject(error);
    }
};

// https://docs.bnbchain.org/greenfield-docs/docs/api/storgae-provider-rest/get_nonce
const getNonce = async ({ spEndpoint, spName, spAddress, address, domain, }) => {
    let result;
    let res;
    const url = `${spEndpoint}/auth/request_nonce`;
    const headers = new Headers$1({
        'X-Gnfd-User-Address': address,
        'X-Gnfd-App-Domain': domain,
    });
    try {
        result = await fetchWithTimeout(url, {
            headers,
        });
        if (!result.ok) {
            return { code: -1, nonce: null };
        }
        const data = await result.text();
        const xmlParser = new XMLParser({
            parseTagValue: false,
        });
        res = xmlParser.parse(data);
    }
    catch (error) {
        return { code: -1, nonce: null };
    }
    return {
        endpoint: spEndpoint,
        address: spAddress,
        name: spName,
        nonce: res.RequestNonceResp.NextNonce,
    };
};

const updateUserAccountKey = async ({ address, domain, sp, pubKey, expireDate, authorization, }) => {
    let result;
    const url = `${sp.endpoint}/auth/update_key`;
    const nonce = sp.nonce + '';
    const headers = new Headers$1({
        'X-Gnfd-User-Address': address,
        'X-Gnfd-App-Domain': domain,
        'X-Gnfd-App-Reg-Nonce': nonce,
        'X-Gnfd-App-Reg-Public-Key': pubKey,
        'X-Gnfd-Expiry-Timestamp': expireDate,
        Authorization: authorization,
    });
    try {
        result = await fetchWithTimeout(url, {
            headers,
            method: 'POST',
        });
        if (!result.ok) {
            return { code: -1, data: { address }, message: 'upload sp pubKey error.' };
        }
    }
    catch (error) {
        return { code: -1, data: { address }, message: 'upload sp pubKey error.' };
    }
    return {
        code: 0,
        data: {
            ...sp,
        },
    };
};

const delay = (ms, value) => new Promise((resolve) => setTimeout(() => resolve(value), ms));
const promiseRaceAll = async (promises, timeout = 3000, timeoutValue = { code: -1 }) => {
    return Promise.all(promises.map((p) => {
        return Promise.race([p, delay(timeout, timeoutValue)]);
    }));
};
const genLocalSignMsg = (sps, domain) => {
    const spMsg = sps
        .map((sp) => {
        return `- SP ${sp.endpoint} (name:${sp.name || ''}) with nonce:${sp.nonce}`;
    })
        .join('\n');
    const firstSign = `Sign this message to let dapp ${domain} access the following SPs:
    ${spMsg}`;
    return firstSign;
};
const fetchNonces = async ({ sps, address, domain }) => {
    const promises = sps.map((sp) => getNonce({
        spEndpoint: sp.endpoint,
        spAddress: sp.address,
        spName: sp.name,
        address,
        domain,
    }));
    const res = await promiseRaceAll(promises, 3000, { code: -1, nonce: null });
    return res;
};
const updateSpsPubKey = async ({ address, sps, domain, pubKey, expireDate, authorization, }) => {
    const promises = sps.map((sp) => updateUserAccountKey({
        address,
        domain,
        sp,
        pubKey,
        expireDate,
        authorization,
    }));
    const res = await promiseRaceAll(promises, 3000);
    return res;
};
const genSecondSignMsg = ({ domain, address, pubKey, chainId, issuedDate, expireDate, sps, }) => {
    let resourceList = '';
    const spsMsg = [];
    sps.forEach((sp) => {
        const spMsg = `- SP ${sp.address} (name: ${sp.name || ''}) with nonce: ${sp.nonce}`;
        spsMsg.push(spMsg);
    });
    resourceList = spsMsg.join('\n');
    // NOTICE: DO NOT CHANGE THE TEMPLATE FORMAT
    const unSignedContentTemplate = `${domain} wants you to sign in with your BNB Greenfield account:${address}
Register your identity public key ${pubKey}
URI: ${domain}
Version: 1
Chain ID: ${chainId}
Issued At: ${issuedDate}
Expiration Time: ${expireDate}
Resources:
${resourceList}`;
    return unSignedContentTemplate;
};
const personalSign = async ({ message, address, provider }) => {
    const sign = await provider.request({
        method: 'personal_sign',
        params: [message, address],
    });
    return sign;
};

const getCanonicalHeaders = (reqMeta, reqHeaders) => {
    const sortedHeaders = getSortedHeaders(reqHeaders, SUPPORTED_HEADERS);
    const res = [];
    sortedHeaders.forEach((k) => {
        const v = reqHeaders.get(k);
        res.push(`${k}:${v}`);
    });
    if (reqMeta.url && reqMeta.url.hostname) {
        res.push(reqMeta.url.hostname);
    }
    res.push('');
    return res.join('\n');
};
const getSortedHeaders = (reqHeaders, supportHeaders) => {
    const signedHeaders = [];
    reqHeaders.forEach((v, k) => {
        if (supportHeaders.includes(k)) {
            signedHeaders.push(k);
        }
    });
    return signedHeaders.sort();
};
const getSignedHeaders = (reqHeaders) => {
    const sortedHeaders = getSortedHeaders(reqHeaders, SUPPORTED_HEADERS);
    return sortedHeaders.join(';');
};
const getAuthorization = async (reqMeta, reqHeaders, authType) => {
    const canonicalHeaders = getCanonicalHeaders(reqMeta, reqHeaders);
    const signedHeaders = getSignedHeaders(reqHeaders);
    const canonicalRequestArr = [
        reqMeta.method,
        reqMeta.url?.path,
        reqMeta.url?.query,
        canonicalHeaders,
        signedHeaders,
    ];
    const canonicalRequest = canonicalRequestArr.join('\n');
    // console.log('canonicalRequest', canonicalRequest);
    const unsignedMsg = getMsgToSign(utf8ToBytes(canonicalRequest));
    let authorization = '';
    if (authType.type === 'ECDSA') {
        const sig = secpSign(unsignedMsg, authType.privateKey);
        authorization = `GNFD1-ECDSA, Signature=${sig.slice(2)}`;
    }
    else {
        const sig = await signSignatureByEddsa(authType.seed, hexlify(unsignedMsg).slice(2));
        authorization = `GNFD1-EDDSA,Signature=${sig}`;
    }
    return authorization;
};
const newRequestHeadersByMeta = (meta) => {
    const headers = new Headers$1();
    if (meta.contentType) {
        headers.set(HTTPHeaderContentType.toLocaleLowerCase(), meta.contentType);
    }
    if (meta.txnHash && meta.txnHash !== '') {
        headers.set(HTTPHeaderTransactionHash.toLocaleLowerCase(), meta.txnHash);
    }
    if (meta.contentSHA256) {
        headers.set(HTTPHeaderContentSHA256.toLocaleLowerCase(), meta.contentSHA256);
    }
    if (meta.unsignMsg) {
        headers.set(HTTPHeaderUnsignedMsg.toLocaleLowerCase(), meta.unsignMsg);
    }
    if (meta.userAddress) {
        headers.set(HTTPHeaderUserAddress, meta.userAddress);
    }
    const date = new Date();
    if (meta.date) {
        headers.set(HTTPHeaderDate.toLocaleLowerCase(), formatDate(meta.date));
    }
    else {
        headers.set(HTTPHeaderDate.toLocaleLowerCase(), formatDate(date));
    }
    if (meta.expiryTimestamp) {
        headers.set(HTTPHeaderExpiryTimestamp.toLocaleLowerCase(), formatDate(meta.expiryTimestamp));
    }
    else {
        date.setHours(date.getHours() + 2);
        headers.set(HTTPHeaderExpiryTimestamp.toLocaleLowerCase(), formatDate(date));
    }
    return headers;
};
function formatDate(date) {
    const res = date.toISOString();
    return res.replace(/\.\d{3}/gi, '');
}
const HTTPHeaderAuthorization = 'Authorization';
const HTTPHeaderContentSHA256 = 'X-Gnfd-Content-Sha256';
const HTTPHeaderTransactionHash = 'X-Gnfd-Txn-Hash';
const HTTPHeaderObjectID = 'X-Gnfd-Object-ID';
const HTTPHeaderRedundancyIndex = 'X-Gnfd-Redundancy-Index';
const HTTPHeaderResource = 'X-Gnfd-Resource';
const HTTPHeaderDate = 'X-Gnfd-Date';
const HTTPHeaderExpiryTimestamp = 'X-Gnfd-Expiry-Timestamp';
const HTTPHeaderRange = 'Range';
const HTTPHeaderPieceIndex = 'X-Gnfd-Piece-Index';
const HTTPHeaderContentType = 'Content-Type';
const HTTPHeaderContentMD5 = 'Content-MD5';
const HTTPHeaderUnsignedMsg = 'X-Gnfd-Unsigned-Msg';
const HTTPHeaderUserAddress = 'X-Gnfd-User-Address';
const HTTPHeaderAppDomain = 'X-Gnfd-App-Domain';
const SUPPORTED_HEADERS = [
    HTTPHeaderContentSHA256.toLocaleLowerCase(),
    HTTPHeaderTransactionHash.toLocaleLowerCase(),
    HTTPHeaderObjectID.toLocaleLowerCase(),
    HTTPHeaderRedundancyIndex.toLocaleLowerCase(),
    HTTPHeaderResource.toLocaleLowerCase(),
    HTTPHeaderDate.toLocaleLowerCase(),
    HTTPHeaderExpiryTimestamp.toLocaleLowerCase(),
    HTTPHeaderRange.toLocaleLowerCase(),
    HTTPHeaderPieceIndex.toLocaleLowerCase(),
    HTTPHeaderContentType.toLocaleLowerCase(),
    HTTPHeaderContentMD5.toLocaleLowerCase(),
    HTTPHeaderUnsignedMsg.toLocaleLowerCase(),
    HTTPHeaderUserAddress.toLocaleLowerCase(),
    // HTTPHeaderAppDomain.toLocaleLowerCase(),
];
// https://github.com/ethers-io/ethers.js/discussions/4339
const secpSign = (digestBz, privateKey) => {
    const signingKey = new SigningKey(privateKey);
    const signature = signingKey.signDigest(digestBz);
    let res = joinSignature(signature);
    const v = res.slice(-2);
    if (v === '1c')
        res = res.slice(0, -2) + '01';
    if (v === '1b')
        res = res.slice(0, -2) + '00';
    return res;
};
const getMsgToSign = (unsignedBytes) => {
    const res = keccak256(unsignedBytes);
    return res;
};
const encodePath = (pathName) => {
    const reservedNames = /^[a-zA-Z0-9-_.~/]+$/;
    if (reservedNames.test(pathName)) {
        return pathName;
    }
    let encodedPathName = '';
    for (let i = 0; i < pathName.length; i++) {
        const s = pathName[i];
        // soft characters
        if (('A' <= s && s <= 'Z') || ('a' <= s && s <= 'z') || ('0' <= s && s <= '9')) {
            encodedPathName += s;
            continue;
        }
        switch (s) {
            // special characters are allowed
            case '-':
            case '_':
            case '.':
            case '~':
            case '/':
                encodedPathName += s;
                continue;
            // others characters need to be encoded
            default:
                // . ! @ # $ % ^ & * ) ( - + = { } [ ] / " , ' < > ~ \ .` ? : ; | \\
                if (/[.!@#\$%\^&\*\)\(\-+=\{\}\[\]\/\",'<>~\·`\?:;|\\]+$/.test(s)) {
                    // english characters
                    const hexStr = s.charCodeAt(0).toString(16);
                    encodedPathName += '%' + hexStr.toUpperCase();
                }
                else {
                    // others characters
                    encodedPathName += encodeURI(s);
                }
        }
    }
    return encodedPathName;
};
const getSortQuery = (queryMap) => {
    const queryParams = new URLSearchParams();
    for (const k in queryMap) {
        queryParams.append(k, queryMap[k]);
    }
    queryParams.sort();
    return queryParams.toString();
};
const getSortQueryParams = (url, queryMap) => {
    // const queryParams = new URLSearchParams();
    for (const k in queryMap) {
        url.searchParams.append(k, queryMap[k]);
    }
    url.searchParams.sort();
    return url;
};

// https://docs.bnbchain.org/greenfield-docs/docs/api/storage-provider-rest/get_approval
const getApprovalMetaInfo = (endpoint, action, msg) => {
    const path = '/greenfield/admin/v1/get-approval';
    const queryMap = {
        action,
    };
    let url = new URL(path, endpoint);
    url = getSortQueryParams(url, queryMap);
    const unSignedMessageInHex = toHex$1(utf8ToBytes$1(JSON.stringify(msg)));
    const reqMeta = {
        contentSHA256: EMPTY_STRING_SHA256,
        unsignMsg: unSignedMessageInHex,
        method: METHOD_GET,
        url: {
            hostname: url.hostname,
            query: url.searchParams.toString(),
            path,
        },
    };
    const optionsWithOutHeaders = {
        method: METHOD_GET,
    };
    return {
        url: url.href,
        optionsWithOutHeaders,
        reqMeta,
    };
};

function formatVGF(vgf) {
    return {
        ...vgf,
        Id: Number(vgf.Id),
        PrimarySpId: Number(vgf.PrimarySpId),
        // GlobalVirtualGroupIds: vgf.GlobalVirtualGroupIds.map((id) => Number(id)),
    };
}
function formatBucketInfo(o) {
    return {
        ...o,
        // PrimarySpId: Number(item.BucketInfo.PrimarySpId),
        BucketStatus: Number(o.BucketStatus),
        ChargedReadQuota: Number(o.ChargedReadQuota),
        CreateAt: Number(o.CreateAt),
        GlobalVirtualGroupFamilyId: Number(o.GlobalVirtualGroupFamilyId),
        SourceType: Number(o.SourceType),
        Visibility: Number(o.Visibility),
    };
}
function formatObjectInfo(o) {
    return {
        ...o,
        CreateAt: Number(o.CreateAt),
        Id: Number(o.Id),
        LocalVirtualGroupId: Number(o.LocalVirtualGroupId),
        ObjectStatus: Number(o.ObjectStatus),
        PayloadSize: Number(o.PayloadSize),
        RedundancyType: Number(o.RedundancyType),
        SourceType: Number(o.SourceType),
        Visibility: Number(o.Visibility),
    };
}
function convertStrToBool(str) {
    return String(str).toLowerCase() === 'true';
}
function formatReadRecord(o) {
    return {
        ...o,
        ReadTimestampUs: Number(o.ReadTimestampUs),
        ReadSize: Number(o.ReadSize),
    };
}
function formatGroupInfo(o) {
    return {
        ...o,
        SourceType: Number(o.SourceType),
        Id: Number(o.Id),
    };
}

// https://docs.bnbchain.org/greenfield-docs/docs/api/storage-provider-rest/get_bucket_meta
const getBucketMetaInfo = (endpoint, params) => {
    const path = `/${params.bucketName}`;
    const queryMap = {
        'bucket-meta': '',
    };
    let url = new URL(path, endpoint);
    url = getSortQueryParams(url, queryMap);
    return {
        url: url.href,
    };
};
const parseGetBucketMetaResponse = async (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    res.GfSpGetBucketMetaResponse.Bucket = {
        ...res.GfSpGetBucketMetaResponse.Bucket,
        BucketInfo: formatBucketInfo(res.GfSpGetBucketMetaResponse.Bucket.BucketInfo),
        DeleteAt: Number(res.GfSpGetBucketMetaResponse.Bucket.DeleteAt),
        UpdateAt: Number(res.GfSpGetBucketMetaResponse.Bucket.UpdateAt),
        UpdateTime: Number(res.GfSpGetBucketMetaResponse.Bucket.UpdateTime),
    };
    return res;
};

// https://docs.bnbchain.org/greenfield-docs/docs/api/storage-provider-rest/get_user_buckets
const getUserBucketMetaInfo = (endpoint) => {
    return {
        url: endpoint,
    };
};
const parseGetUserBucketsResponse = async (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    let Buckets = res.GfSpGetUserBucketsResponse.Buckets || [];
    if (Buckets) {
        if (!Array.isArray(Buckets)) {
            Buckets = [Buckets];
        }
        Buckets = Buckets.map((item) => {
            return {
                ...item,
                BucketInfo: formatBucketInfo(item.BucketInfo),
                // @ts-ignore
                Removed: convertStrToBool(item.Removed),
                DeleteAt: Number(item.DeleteAt),
                UpdateAt: Number(item.UpdateAt),
                UpdateTime: Number(item.UpdateTime),
                Vgf: formatVGF(item.Vgf),
            };
        });
    }
    res.GfSpGetUserBucketsResponse = {
        Buckets,
    };
    return res;
};

const newBasicAllowance = (amount, denom = DEFAULT_DENOM, expirationTime) => {
    return {
        spendLimit: [
            {
                amount,
                denom,
            },
        ],
        expiration: expirationTime,
    };
};
const newAllowedMsgAllowance = (allowedMessages, basicAllowance) => {
    return {
        allowedMessages,
        allowance: Any.fromPartial({
            typeUrl: BasicAllowanceTypeUrl,
            value: BasicAllowance.encode(basicAllowance).finish(),
        }),
    };
};
const newMsgGrantAllowance = (grantee, granter, allowedMsgAllowance) => {
    return {
        grantee,
        granter,
        allowance: Any.fromPartial({
            typeUrl: AllowedMsgAllowanceTypeUrl,
            value: AllowedMsgAllowance.encode(allowedMsgAllowance).finish(),
        }),
    };
};
const newMarshal = (amount, denom = DEFAULT_DENOM, allowed_messages, expirationTime) => {
    return {
        '@type': AllowedMsgAllowanceTypeUrl,
        allowance: {
            '@type': BasicAllowanceTypeUrl,
            expiration: fromTimestamp(expirationTime),
            spend_limit: [
                {
                    amount,
                    denom,
                },
            ],
        },
        allowed_messages,
    };
};

const toHex = (char = '') => {
    return char.charCodeAt(0).toString(16);
};
const encodeToHex = (str = '') => {
    return str.split('').map(toHex).join('');
};
const decodeFromHex = (hex = '') => {
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
        result.push(String.fromCharCode(parseInt(hex.substr(i, 2), 16)));
    }
    return result.join('');
};
const encodeObjectToHexString = (jsonObject) => {
    const utf8Encoder = new TextEncoder();
    const utf8Bytes = utf8Encoder.encode(JSON.stringify(jsonObject));
    return Array.from(utf8Bytes)
        .map((b) => b.toString(16).padStart(2, '0'))
        .join('');
};
const encodeToHexString = (str = '') => {
    const utf8Encoder = new TextEncoder();
    const utf8Bytes = utf8Encoder.encode(str);
    return Array.from(utf8Bytes)
        .map((b) => b.toString(16).padStart(2, '0'))
        .join('');
};
const hexToBytes = (hex = '') => {
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
    }
    return bytes;
};
function uint8ArrayToJson(uint8Array) {
    const decoder = new TextDecoder('utf-8');
    const jsonString = decoder.decode(uint8Array);
    return JSON.parse(jsonString);
}
const decodeObjectFromHexString = (hex = '') => {
    return uint8ArrayToJson(hexToBytes(hex));
};

const BucketTypeAbbr = 'b';
const ObjectTypeAbbr = 'o';
const GroupTypeAbbr = 'g';
const newBucketGRN = (bucketName) => {
    return {
        resType: ResourceType.RESOURCE_TYPE_BUCKET,
        groupOwner: '',
        name: bucketName,
    };
};
const newObjectGRN = (bucketName, objectName) => {
    const name = [bucketName, objectName].join('/');
    return {
        name,
        resType: ResourceType.RESOURCE_TYPE_OBJECT,
        groupOwner: '',
    };
};
const newGroupGRN = (owner, groupName) => {
    return {
        resType: ResourceType.RESOURCE_TYPE_GROUP,
        groupOwner: owner,
        name: groupName,
    };
};
const GRNToString = (grn) => {
    let res = '';
    switch (grn.resType) {
        case ResourceType.RESOURCE_TYPE_BUCKET:
            res = `grn:${BucketTypeAbbr}::${grn.name}`;
            break;
        case ResourceType.RESOURCE_TYPE_OBJECT:
            res = `grn:${ObjectTypeAbbr}::${grn.name}`;
            break;
        case ResourceType.RESOURCE_TYPE_GROUP:
            res = `grn:${GroupTypeAbbr}:${grn.groupOwner}:${grn.name}`;
            break;
        default:
            return '';
    }
    return res.trim();
};

const IP_REGEX = /^(\d+\.){3}\d+$/g;
const ALLOW_REGEX = /^[a-z0-9][a-z0-9.\-]{1,61}[a-z0-9]$/g;
const dotdotComponent = '..';
const dotComponent = '.';
const slashSeparator = '/';
const isValidBucketName = (bucketName) => {
    if (!bucketName) {
        throw new Error('Bucket name is empty, please check.');
    }
    const length = bucketName.length;
    if (length < 3 || length > 63) {
        throw new Error(`Bucket name length is required to be between 3~63, please check.`);
    }
    if (bucketName.match(IP_REGEX)) {
        throw new Error('The bucket name %s cannot be formatted as an IP address, please check.');
    }
    if (bucketName.includes('..') || bucketName.includes('.-') || bucketName.includes('-.')) {
        throw new Error('Bucket name contains invalid characters, please check.');
    }
    if (!bucketName.match(ALLOW_REGEX)) {
        throw new Error('Bucket name can only include lowercase letters, numbers, commas and hyphen, please check.');
    }
    if (bucketName[0] === '-' ||
        bucketName[length - 1] === '-' ||
        bucketName[0] === '.' ||
        bucketName[length - 1] === '.') {
        throw new Error('Bucket name %must start and end with a lowercase letter or number, please check.');
    }
    return true;
};
const hasBadPathComponent = (path) => {
    const newPath = path.trim();
    for (const p of newPath.split(slashSeparator)) {
        switch (p.trim()) {
            case dotdotComponent:
            case dotComponent:
                return true;
        }
    }
    return false;
};
const isUTF8 = (str) => {
    try {
        new TextDecoder('utf-8').decode(new TextEncoder().encode(str));
        return true;
    }
    catch {
        return false;
    }
};
const isValidObjectName = (objectName) => {
    if (!objectName) {
        throw new Error('Object name is empty, please check.');
    }
    if (objectName.length > 1024) {
        throw new Error('Object name is limited to 1024 at most, please check.');
    }
    if (hasBadPathComponent(objectName)) {
        throw new Error('Object name error, please check.');
    }
    if (!isUTF8(objectName)) {
        throw new Error('Object name is not in UTF-8 format, please check.');
    }
    if (objectName.includes(`//`)) {
        throw new Error(`Object name that contains a "//" is not supported`);
    }
    return true;
};
const isValidAddress = (address) => {
    if (!address) {
        throw new Error('Address is empty, please check.');
    }
    if (address.length > 1024) {
        throw new Error('Address is limited to 1024 at most, please check.');
    }
    return true;
};
const isValidUrl = (url) => {
    if (!url || url.length === 0)
        return false;
    const pattern = new RegExp('^(https?:\\/\\/)?' + // 协议
        '((([a-zA-Z\\d]([a-zA-Z\\d-]{0,61}[a-zA-Z\\d])?)\\.)+' + // 域名
        '[a-zA-Z]{2,13})' + // 顶级域名
        '(\\:\\d{1,5})?' + // 端口号
        '(\\/[-a-zA-Z\\d%_.~+]*)*' + // 路径
        '(\\?[;&a-zA-Z\\d%_.~+=-]*)?' + // 查询字符串
        '(\\#[-a-zA-Z\\d_]*)?$', 'i'); // 锚点
    return pattern.test(url);
};
// remove specified from prefix and suffix of a string
const trimString = (originString, deleteString) => {
    const delStrLength = deleteString.length;
    if (originString.startsWith(deleteString)) {
        originString = originString.substring(delStrLength);
    }
    if (originString.endsWith(deleteString)) {
        originString = originString.substring(0, originString.length - delStrLength);
    }
    return originString;
};
const generateUrlByBucketName = (endpoint = '', bucketName) => {
    if (!isValidUrl(endpoint)) {
        throw new Error('Invalid endpoint');
    }
    if (!isValidBucketName(bucketName)) ;
    const { protocol } = new URL(endpoint);
    return endpoint.replace(`${protocol}//`, `${protocol}//${bucketName}.`);
};

const getUtcZeroTimestamp = () => {
    dayjs.extend(utc);
    return dayjs().utc().valueOf();
};
const convertTimeStampToDate = (utcTimestamp) => {
    dayjs.extend(utc);
    dayjs.extend(timezone);
    // utc-0 timezone
    const tz = 'Iceland';
    return dayjs(utcTimestamp).tz(tz).format();
};

// https://docs.bnbchain.org/greenfield-docs/docs/api/storage-provider-rest/list_bucket_read_records
const getListBucketReadRecordMetaInfo = (endpoint, params) => {
    const { bucketName, endTimeStamp, maxRecords, startTimeStamp } = params;
    const path = '/';
    const queryMap = {
        'list-read-record': 'null',
        'end-timestamp': String(endTimeStamp),
        'max-records': String(maxRecords),
        'start-timestamp': String(startTimeStamp),
    };
    let url = new URL(path, generateUrlByBucketName(endpoint, bucketName));
    url = getSortQueryParams(url, queryMap);
    const reqMeta = {
        contentSHA256: EMPTY_STRING_SHA256,
        method: METHOD_GET,
        url: {
            hostname: url.hostname,
            query: url.searchParams.toString(),
            path,
        },
    };
    const optionsWithOutHeaders = {
        method: METHOD_GET,
    };
    return {
        url: url.href,
        optionsWithOutHeaders,
        reqMeta,
    };
};
const parseListBucketReadRecordResponse = async (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    let readRecords = res.GetBucketReadQuotaResult?.ReadRecords || [];
    if (readRecords) {
        if (!Array.isArray(readRecords)) {
            readRecords = [readRecords];
        }
        readRecords = readRecords.map((readRecord) => formatReadRecord(readRecord));
    }
    res.GetBucketReadQuotaResult = {
        ...res.GetBucketReadQuotaResult,
        ReadRecords: readRecords,
    };
    return res;
};

// https://docs.bnbchain.org/greenfield-docs/docs/api/storage-provider-rest/list_buckets_by_ids
const getListBucketsByIDsMetaInfo = (endpoint, params) => {
    const path = '/';
    const queryMap = {
        ids: params.ids.join(','),
        'buckets-query': 'null',
    };
    let url = new URL(path, endpoint);
    url = getSortQueryParams(url, queryMap);
    return {
        url: url.href,
    };
};
const parseListBucketsByIdsResponse = async (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    let BucketEntry = res.GfSpListBucketsByIDsResponse.BucketEntry || [];
    if (BucketEntry) {
        if (!Array.isArray(BucketEntry)) {
            BucketEntry = [BucketEntry];
        }
        BucketEntry = BucketEntry.map((item) => {
            let Value = item.Value;
            if (Value) {
                Value = {
                    ...item.Value,
                    BucketInfo: formatBucketInfo(item.Value.BucketInfo),
                    // @ts-ignore
                    Removed: convertStrToBool(item.Value.Removed),
                    UpdateAt: Number(item.Value.UpdateAt),
                    DeleteAt: Number(item.Value.DeleteAt),
                };
            }
            return {
                ...item,
                Id: Number(item.Id),
                Value,
            };
        });
    }
    res.GfSpListBucketsByIDsResponse = {
        ...res.GfSpListBucketsByIDsResponse,
        BucketEntry,
    };
    return res;
};

const getListBucketByPaymentMetaInfo = (endpoint, params) => {
    const path = '/';
    const queryMap = {
        'payment-buckets': 'null',
        'payment-account': params.paymentAccount,
    };
    let url = new URL(path, endpoint);
    url = getSortQueryParams(url, queryMap);
    return {
        url: url.href,
    };
};
const parseListBucketByPaymentResponse = (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    let Buckets = res.GfSpListPaymentAccountStreamsResponse.Buckets || [];
    if (Buckets) {
        if (!Array.isArray(Buckets)) {
            Buckets = [Buckets];
        }
        Buckets = Buckets.map((item) => {
            return {
                ...item,
                BucketInfo: formatBucketInfo(item.BucketInfo),
                // @ts-ignore
                Removed: convertStrToBool(item.Removed),
                DeleteAt: Number(item.DeleteAt),
                UpdateAt: Number(item.UpdateAt),
                UpdateTime: Number(item.UpdateTime),
            };
        });
    }
    res.GfSpListPaymentAccountStreamsResponse = {
        Buckets,
    };
    return res;
};

const parseError = async (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    return {
        code: res.Error.Code,
        message: res.Error.Message,
    };
};

// https://docs.bnbchain.org/greenfield-docs/docs/api/storage-provider-rest/query_bucket_read_quota
const getQueryBucketReadQuotaMetaInfo = async (endpoint, params) => {
    const { year, month, bucketName } = params;
    const currentDate = new Date();
    const finalYear = year ? year : currentDate.getFullYear();
    const finalMonth = month ? month : currentDate.getMonth() + 1;
    // format month to 2 digits, like "01"
    const formattedMonth = finalMonth.toString().padStart(2, '0');
    const path = '/';
    const queryMap = {
        'year-month': `${finalYear}-${formattedMonth}`,
        'read-quota': 'null',
    };
    const query = getSortQuery(queryMap);
    const url = `${generateUrlByBucketName(endpoint, bucketName)}${path}?${query}`;
    const reqMeta = {
        contentSHA256: EMPTY_STRING_SHA256,
        method: METHOD_GET,
        url: {
            hostname: new URL(url).hostname,
            query,
            path,
        },
    };
    const optionsWithOutHeaders = {
        method: METHOD_GET,
    };
    return {
        url,
        optionsWithOutHeaders,
        reqMeta,
    };
};
const parseReadQuotaResponse = async (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    return res;
};

const MsgCreateBucketSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'charged_read_quota',
            type: 'uint64',
        },
        {
            name: 'creator',
            type: 'string',
        },
        {
            name: 'payment_address',
            type: 'string',
        },
        {
            name: 'primary_sp_address',
            type: 'string',
        },
        {
            name: 'primary_sp_approval',
            type: 'TypeMsg1PrimarySpApproval',
        },
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'visibility',
            type: 'string',
        },
    ],
    TypeMsg1PrimarySpApproval: [
        {
            name: 'expired_height',
            type: 'uint64',
        },
        {
            name: 'global_virtual_group_family_id',
            type: 'uint32',
        },
        {
            name: 'sig',
            type: 'bytes',
        },
    ],
};

const MsgDeleteBucketSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
    ],
};

const MsgMigrateBucketSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'dst_primary_sp_approval',
            type: 'TypeMsg1DstPrimarySpApproval',
        },
        {
            name: 'dst_primary_sp_id',
            type: 'uint32',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'type',
            type: 'string',
        },
    ],
    TypeMsg1DstPrimarySpApproval: [
        {
            name: 'expired_height',
            type: 'uint64',
        },
        {
            name: 'global_virtual_group_family_id',
            type: 'uint32',
        },
        {
            name: 'sig',
            type: 'bytes',
        },
    ],
};

const MsgUpdateBucketInfoSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'charged_read_quota',
            type: 'TypeMsg1ChargedReadQuota',
        },
        {
            name: 'payment_address',
            type: 'string',
        },
        {
            name: 'visibility',
            type: 'string',
        },
    ],
    TypeMsg1ChargedReadQuota: [
        {
            name: 'value',
            type: 'uint64',
        },
    ],
};

// https://docs.bnbchain.org/greenfield-docs/docs/api/storage-provider-rest/get_object
const getGetObjectMetaInfo = async (endpoint, params) => {
    const { bucketName, objectName } = params;
    const path = `/${encodePath(objectName)}`;
    const query = '';
    const url = new URL(path, generateUrlByBucketName(endpoint, bucketName));
    const reqMeta = {
        contentSHA256: EMPTY_STRING_SHA256,
        method: METHOD_GET,
        url: {
            hostname: new URL(url).hostname,
            query,
            path,
        },
        contentType: 'application/octet-stream',
    };
    const optionsWithOutHeaders = {
        method: METHOD_GET,
    };
    return {
        url: url.href,
        optionsWithOutHeaders,
        reqMeta,
    };
};

// https://docs.bnbchain.org/greenfield-docs/docs/api/storage-provider-rest/put_object
const getPutObjectMetaInfo = async (endpoint, params) => {
    const { bucketName, objectName, txnHash, contentType, body } = params;
    const path = `/${encodePath(objectName)}`;
    const query = '';
    const url = new URL(path, generateUrlByBucketName(endpoint, bucketName));
    const reqMeta = {
        contentSHA256: EMPTY_STRING_SHA256,
        txnHash: txnHash,
        method: METHOD_PUT,
        url: {
            hostname: url.hostname,
            query,
            path,
        },
        contentType,
    };
    const optionsWithOutHeaders = {
        method: METHOD_PUT,
        body,
    };
    return {
        url: url.href,
        optionsWithOutHeaders,
        reqMeta,
    };
};

let SpClient = class SpClient {
    async callApi(url, options, timeout = 30000, customError) {
        try {
            const controller = new AbortController();
            const _id = setTimeout(() => controller.abort(), timeout);
            const response = await fetch(url, {
                ...options,
                signal: controller.signal,
            });
            clearTimeout(_id);
            const { status } = response;
            if (!response.ok) {
                const xmlError = await response.text();
                const { code, message } = await parseError(xmlError);
                throw {
                    code: code || customError?.code,
                    message: message || customError?.message,
                    statusCode: status,
                };
            }
            return response;
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    async signHeaders(reqMeta, authType) {
        const metaHeaders = newRequestHeadersByMeta(reqMeta);
        if (authType.type === 'EDDSA') {
            const { domain, address } = authType;
            metaHeaders.set(HTTPHeaderUserAddress, address);
            metaHeaders.set(HTTPHeaderAppDomain, domain);
        }
        const auth = await getAuthorization(reqMeta, metaHeaders, authType);
        metaHeaders.set(HTTPHeaderAuthorization, auth);
        return metaHeaders;
    }
    getMetaInfo() {
        return {
            PUT_OBJECT: getPutObjectMetaInfo,
            GET_OBJECT: getGetObjectMetaInfo,
        };
    }
};
SpClient = __decorate([
    injectable()
], SpClient);

// https://docs.bnbchain.org/greenfield-docs/docs/api/storage-provider-rest/get_group_list
const getListGroupMetaInfo = (endpoint, params) => {
    const { name, prefix, sourceType, limit, offset } = params;
    const path = '/';
    const queryMap = {
        'group-query': 'null',
        name,
        prefix,
        'source-type': sourceType,
        limit: String(limit),
        offset: String(offset),
    };
    let url = new URL(path, endpoint);
    url = getSortQueryParams(url, queryMap);
    return {
        url: url.href,
    };
};
const parseListGroupsResponse = async (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    let Groups = res.GfSpGetGroupListResponse.Groups || [];
    if (Groups) {
        if (!Array.isArray(Groups)) {
            Groups = [Groups];
        }
        Groups = Groups.map((item) => {
            return {
                ...item,
                CreateAt: Number(item.CreateAt),
                CreateTime: Number(item.CreateTime),
                UpdateAt: Number(item.UpdateAt),
                UpdateTime: Number(item.UpdateTime),
                // @ts-ignore
                Removed: convertStrToBool(item.Removed),
                Group: formatGroupInfo(item.Group),
            };
        });
    }
    res.GfSpGetGroupListResponse = {
        Groups: Groups,
        Count: Number(res.GfSpGetGroupListResponse.Count),
    };
    return res;
};

// https://docs.bnbchain.org/greenfield-docs/docs/api/storage-provider-rest/list_group_members
const parseListGroupsMembersResponse = async (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    let Groups = res.GfSpGetGroupMembersResponse.Groups || [];
    if (Groups) {
        if (!Array.isArray(Groups)) {
            Groups = [Groups];
        }
        Groups = Groups.map((item) => {
            return {
                ...item,
                CreateAt: Number(item.CreateAt),
                CreateTime: Number(item.CreateTime),
                UpdateAt: Number(item.UpdateAt),
                UpdateTime: Number(item.UpdateTime),
                // @ts-ignore
                Removed: convertStrToBool(item.Removed),
                Group: formatGroupInfo(item.Group),
            };
        });
    }
    return res;
};

// https://docs.bnbchain.org/greenfield-docs/docs/api/storgae-provider-rest/list_user_groups
const parseListUserGroupsResponse = async (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    let Groups = res.GfSpGetUserGroupsResponse.Groups || [];
    if (Groups) {
        if (!Array.isArray(Groups)) {
            Groups = [Groups];
        }
        Groups = Groups.map((item) => {
            return {
                ...item,
                CreateAt: Number(item.CreateAt),
                CreateTime: Number(item.CreateTime),
                UpdateAt: Number(item.UpdateAt),
                UpdateTime: Number(item.UpdateTime),
                // @ts-ignore
                Removed: convertStrToBool(item.Removed),
                Group: formatGroupInfo(item.Group),
            };
        });
    }
    res.GfSpGetUserGroupsResponse = {
        Groups: Groups,
    };
    return res;
};

// https://docs.bnbchain.org/greenfield-docs/docs/api/storgae-provider-rest/list_user_owned_groups
const parseListUserOwnedGroupsResponse = async (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    let Groups = res.GfSpGetUserOwnedGroupsResponse.Groups || [];
    if (Groups) {
        if (!Array.isArray(Groups)) {
            Groups = [Groups];
        }
        Groups = Groups.map((item) => {
            return {
                ...item,
                CreateAt: Number(item.CreateAt),
                CreateTime: Number(item.CreateTime),
                UpdateAt: Number(item.UpdateAt),
                UpdateTime: Number(item.UpdateTime),
                // @ts-ignore
                Removed: convertStrToBool(item.Removed),
                Group: formatGroupInfo(item.Group),
            };
        });
    }
    res.GfSpGetUserOwnedGroupsResponse = {
        Groups: Groups,
    };
    return res;
};

// https://docs.bnbchain.org/greenfield-docs/docs/api/storgae-provider-rest/verify_permission
const parseVerifyPermissionResponse = async (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    res.QueryVerifyPermissionResponse = {
        ...res.QueryVerifyPermissionResponse,
        Effect: Number(res.QueryVerifyPermissionResponse.Effect),
    };
    return res;
};

const MsgSettleSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'global_virtual_group_family_id',
            type: 'uint32',
        },
        {
            name: 'global_virtual_group_ids',
            type: 'uint32[]',
        },
        {
            name: 'storage_provider',
            type: 'string',
        },
        {
            name: 'type',
            type: 'string',
        },
    ],
};

let VirtualGroup = class VirtualGroup {
    constructor(txClient) {
        this.txClient = txClient;
        this.queryClient = container.resolve(RpcQueryClient);
    }
    async params() {
        const rpc = await this.queryClient.getVirtualGroupClient();
        return await rpc.Params();
    }
    async getGlobalVirtualGroup(request) {
        const rpc = await this.queryClient.getVirtualGroupClient();
        return await rpc.GlobalVirtualGroup(request);
    }
    async getGlobalVirtualGroupByFamilyID(request) {
        const rpc = await this.queryClient.getVirtualGroupClient();
        return await rpc.GlobalVirtualGroupByFamilyID(request);
    }
    async getGlobalVirtualGroupFamilies(request) {
        const rpc = await this.queryClient.getVirtualGroupClient();
        return await rpc.GlobalVirtualGroupFamilies(request);
    }
    async getGlobalVirtualGroupFamily(request) {
        const rpc = await this.queryClient.getVirtualGroupClient();
        return await rpc.GlobalVirtualGroupFamily(request);
    }
    async settle(address, msg) {
        return await this.txClient.tx(MsgSettleTypeUrl, address, MsgSettleSDKTypeEIP712, MsgSettle.toSDK(msg), MsgSettle.encode(msg).finish());
    }
};
VirtualGroup = __decorate([
    injectable(),
    __param(0, inject(delay$1(() => TxClient))),
    __metadata("design:paramtypes", [TxClient])
], VirtualGroup);

let Sp = class Sp {
    constructor() {
        this.bucket = container.resolve(Bucket);
        this.queryClient = container.resolve(RpcQueryClient);
        this.virtualGroup = container.resolve(VirtualGroup);
        this.spClient = container.resolve(SpClient);
    }
    async getStorageProviders() {
        const rpc = await this.queryClient.getSpQueryClient();
        const res = await rpc.StorageProviders();
        return res.sps;
    }
    async getStorageProviderInfo(spId) {
        const rpc = await this.queryClient.getSpQueryClient();
        const res = await rpc.StorageProvider({
            id: spId,
        });
        return res.storageProvider;
    }
    async getQuerySpStoragePrice(request) {
        const rpc = await this.queryClient.getSpQueryClient();
        return await rpc.QuerySpStoragePrice(request);
    }
    async getQueryGlobalSpStorePriceByTime(request) {
        const rpc = await this.queryClient.getSpQueryClient();
        return await rpc.QueryGlobalSpStorePriceByTime(request);
    }
    async getStorageProviderByOperatorAddress(request) {
        const rpc = await this.queryClient.getSpQueryClient();
        return await rpc.StorageProviderByOperatorAddress(request);
    }
    async getStorageProviderMaintenanceRecordsByOperatorAddress(request) {
        const rpc = await this.queryClient.getSpQueryClient();
        return await rpc.StorageProviderMaintenanceRecordsByOperatorAddress(request);
    }
    async getSPUrlById(primaryId) {
        const spList = await this.getStorageProviders();
        return spList.filter((sp) => sp.id === primaryId)[0].endpoint;
    }
    async getSPUrlByBucket(bucketName) {
        const { bucketInfo } = await this.bucket.headBucket(bucketName);
        if (!bucketInfo)
            throw new Error('Get bucket info error');
        const familyResp = await this.virtualGroup.getGlobalVirtualGroupFamily({
            familyId: bucketInfo.globalVirtualGroupFamilyId,
        });
        const spList = await this.getStorageProviders();
        const spId = familyResp.globalVirtualGroupFamily?.primarySpId;
        return spList.filter((sp) => sp.id === spId)[0].endpoint;
    }
    async getSPUrlByPrimaryAddr(parimaryAddr) {
        const sps = await this.getStorageProviders();
        return sps.filter((sp) => sp.operatorAddress === parimaryAddr)[0].endpoint;
    }
    async params() {
        const rpc = await this.queryClient.getSpQueryClient();
        return await rpc.Params();
    }
    async getInServiceSP() {
        const sps = await this.getStorageProviders();
        const spList = sps.filter((sp) => sp.status === Status.STATUS_IN_SERVICE);
        if (spList.length === 0)
            throw new Error('No storage provider found');
        return spList[0];
    }
    async listGroups(params) {
        try {
            const { name, prefix } = params;
            let res = {
                GfSpGetGroupListResponse: {
                    Groups: [],
                    Count: 0,
                },
            };
            if (name === '' || prefix === '') {
                return {
                    code: 0,
                    message: 'success',
                    body: res,
                };
            }
            const sp = await this.getInServiceSP();
            const { url } = getListGroupMetaInfo(sp.endpoint, params);
            const result = await this.spClient.callApi(url, {
                headers: {},
                method: METHOD_GET,
            }, 3000);
            const { status } = result;
            if (!result.ok) {
                const xmlError = await result.text();
                const { code, message } = await parseError(xmlError);
                throw {
                    code: code || -1,
                    message: message || 'error',
                    statusCode: status,
                };
            }
            const xmlData = await result.text();
            res = await parseListGroupsResponse(xmlData);
            return {
                code: 0,
                message: 'success',
                statusCode: status,
                body: res,
            };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async verifyPermission(params) {
        try {
            const { action, bucketName, objectName, operator } = params;
            const sp = await this.getInServiceSP();
            let url = `${sp.endpoint}/permission/${operator}/${bucketName}/${actionTypeFromJSON(action)}`;
            if (objectName) {
                url += `?object=${encodePath(objectName)}`;
            }
            const result = await this.spClient.callApi(url, {
                headers: {},
                method: METHOD_GET,
            }, 3000);
            const { status } = result;
            if (!result.ok) {
                const xmlError = await result.text();
                const { code, message } = await parseError(xmlError);
                throw {
                    code: code || -1,
                    message: message || 'error',
                    statusCode: status,
                };
            }
            const xmlData = await result.text();
            const res = await parseVerifyPermissionResponse(xmlData);
            return {
                code: 0,
                message: 'success',
                statusCode: status,
                body: res,
            };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async listGroupsMembers(params) {
        try {
            const { groupId, limit, startAfter } = params;
            const sp = await this.getInServiceSP();
            let url = `${sp.endpoint}?group-members&group-id=${groupId}`;
            if (limit) {
                url += `&limit=${limit}`;
            }
            if (startAfter) {
                url += `&start-after=${startAfter}`;
            }
            const result = await this.spClient.callApi(url, {
                headers: {},
                method: METHOD_GET,
            }, 3000);
            const { status } = result;
            if (!result.ok) {
                const xmlError = await result.text();
                const { code, message } = await parseError(xmlError);
                throw {
                    code: code || -1,
                    message: message || 'error',
                    statusCode: status,
                };
            }
            const xmlData = await result.text();
            const res = await parseListGroupsMembersResponse(xmlData);
            return {
                code: 0,
                message: 'success',
                statusCode: status,
                body: res,
            };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async listUserGroups(params) {
        try {
            const { address, limit, startAfter } = params;
            const sp = await this.getInServiceSP();
            let url = `${sp.endpoint}?user-groups`;
            if (limit) {
                url += `&limit=${limit}`;
            }
            if (startAfter) {
                url += `&start-after=${startAfter}`;
            }
            const headers = new Headers({
                [HTTPHeaderUserAddress]: address,
            });
            const result = await this.spClient.callApi(url, {
                headers,
                method: METHOD_GET,
            }, 3000);
            const { status } = result;
            if (!result.ok) {
                const xmlError = await result.text();
                const { code, message } = await parseError(xmlError);
                throw {
                    code: code || -1,
                    message: message || 'error',
                    statusCode: status,
                };
            }
            const xmlData = await result.text();
            const res = await parseListUserGroupsResponse(xmlData);
            return {
                code: 0,
                message: 'success',
                statusCode: status,
                body: res,
            };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async listUserOwnedGroups(params) {
        try {
            const { address, limit, startAfter } = params;
            const sp = await this.getInServiceSP();
            let url = `${sp.endpoint}?owned-groups`;
            if (limit) {
                url += `&limit=${limit}`;
            }
            if (startAfter) {
                url += `&start-after=${startAfter}`;
            }
            const headers = new Headers({
                [HTTPHeaderUserAddress]: address,
            });
            const result = await this.spClient.callApi(url, {
                headers,
                method: METHOD_GET,
            }, 3000);
            const { status } = result;
            if (!result.ok) {
                const xmlError = await result.text();
                const { code, message } = await parseError(xmlError);
                throw {
                    code: code || -1,
                    message: message || 'error',
                    statusCode: status,
                };
            }
            const xmlData = await result.text();
            const res = await parseListUserOwnedGroupsResponse(xmlData);
            return {
                code: 0,
                message: 'success',
                statusCode: status,
                body: res,
            };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
};
Sp = __decorate([
    injectable()
], Sp);

const MsgTransferOutSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'from',
            type: 'string',
        },
        {
            name: 'to',
            type: 'string',
        },
        {
            name: 'amount',
            type: 'TypeMsg1Amount',
        },
    ],
    TypeMsg1Amount: [
        {
            name: 'denom',
            type: 'string',
        },
        {
            name: 'amount',
            type: 'string',
        },
    ],
};

const MsgAttestSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'submitter',
            type: 'string',
        },
        {
            name: 'challenge_id',
            type: 'uint64',
        },
        {
            name: 'object_id',
            type: 'string',
        },
        {
            name: 'sp_operator_address',
            type: 'string',
        },
        {
            name: 'vote_result',
            type: 'string',
        },
        {
            name: 'challenger_address',
            type: 'string',
        },
    ],
};

const MsgSubmitSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'challenger',
            type: 'string',
        },
        {
            name: 'sp_operator_address',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'object_name',
            type: 'string',
        },
        {
            name: 'segment_index',
            type: 'uint32',
        },
        {
            name: 'random_index',
            type: 'bool',
        },
    ],
};

const MsgDepositSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'creator',
            type: 'string',
        },
        {
            name: 'to',
            type: 'string',
        },
        {
            name: 'amount',
            type: 'string',
        },
    ],
};

const MsgDisableRefundSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'owner',
            type: 'string',
        },
        {
            name: 'addr',
            type: 'string',
        },
    ],
};

const MsgWithdrawSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'creator',
            type: 'string',
        },
        {
            name: 'from',
            type: 'string',
        },
        {
            name: 'amount',
            type: 'string',
        },
    ],
};

const MsgCancelCreateObjectSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'object_name',
            type: 'string',
        },
    ],
};

const MsgCreateGroupSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'creator',
            type: 'string',
        },
        {
            name: 'extra',
            type: 'string',
        },
        {
            name: 'group_name',
            type: 'string',
        },
        {
            name: 'type',
            type: 'string',
        },
    ],
};

const MsgCreateObjectSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'content_type',
            type: 'string',
        },
        {
            name: 'creator',
            type: 'string',
        },
        {
            name: 'expect_checksums',
            type: 'bytes[]',
        },
        {
            name: 'object_name',
            type: 'string',
        },
        {
            name: 'payload_size',
            type: 'uint64',
        },
        {
            name: 'primary_sp_approval',
            type: 'TypeMsg1PrimarySpApproval',
        },
        {
            name: 'redundancy_type',
            type: 'string',
        },
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'visibility',
            type: 'string',
        },
    ],
    TypeMsg1PrimarySpApproval: [
        {
            name: 'expired_height',
            type: 'uint64',
        },
        {
            name: 'global_virtual_group_family_id',
            type: 'uint32',
        },
        {
            name: 'sig',
            type: 'bytes',
        },
    ],
};

const MsgDeleteGroupSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'group_name',
            type: 'string',
        },
    ],
};

const MsgDeleteObjectSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'object_name',
            type: 'string',
        },
    ],
};

const MsgDeletePolicySDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'resource',
            type: 'string',
        },
        {
            name: 'principal',
            type: 'TypeMsg1Principal',
        },
    ],
    TypeMsg1Principal: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'value',
            type: 'string',
        },
    ],
};

const MsgLeaveGroupSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'member',
            type: 'string',
        },
        {
            name: 'group_owner',
            type: 'string',
        },
        {
            name: 'group_name',
            type: 'string',
        },
    ],
};

const MsgMirrorBucketSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'id',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
    ],
};

const MsgMirrorGroupSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'dest_chain_id',
            type: 'uint32',
        },
        {
            name: 'group_name',
            type: 'string',
        },
        {
            name: 'id',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'type',
            type: 'string',
        },
    ],
};

const MsgMirrorObjectSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'id',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'object_name',
            type: 'string',
        },
    ],
};

const getMsgPutPolicySDKTypeEIP712 = (resource) => {
    const res = cloneDeep(MsgPutPolicySDKTypeEIP712);
    if (resource.length !== 0) {
        res.TypeMsg1Statements.push({
            name: 'resources',
            type: 'string[]',
        });
    }
    return res;
};
const MsgPutPolicySDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'principal',
            type: 'TypeMsg1Principal',
        },
        {
            name: 'resource',
            type: 'string',
        },
        {
            name: 'statements',
            type: 'TypeMsg1Statements[]',
        },
        {
            name: 'expiration_time',
            type: 'string',
        },
    ],
    TypeMsg1Principal: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'value',
            type: 'string',
        },
    ],
    TypeMsg1Statements: [
        {
            name: 'actions',
            type: 'string[]',
        },
        {
            name: 'effect',
            type: 'string',
        },
        {
            name: 'expiration_time',
            type: 'string',
        },
        // {
        //   name: 'resources',
        //   type: 'string[]',
        // },
    ],
};

const MsgUpdateGroupExtraSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'group_owner',
            type: 'string',
        },
        {
            name: 'group_name',
            type: 'string',
        },
        {
            name: 'extra',
            type: 'string',
        },
    ],
};

const getMsgUpdateGroupMemberSDKTypeEIP712 = ({ membersToAdd, membersToDelete, }) => {
    const res = cloneDeep(MsgUpdateGroupMemberSDKTypeEIP712);
    if (membersToAdd.length > 0) {
        res.Msg1.push({
            name: 'members_to_add',
            type: 'TypeMsg1MembersToAdd[]',
        });
        res.TypeMsg1MembersToAdd = [
            {
                name: 'expiration_time',
                type: 'string',
            },
            {
                name: 'member',
                type: 'string',
            },
        ];
    }
    if (membersToDelete.length > 0) {
        res.Msg1.push({
            name: 'members_to_delete',
            type: 'string[]',
        });
    }
    return res;
};
const MsgUpdateGroupMemberSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'group_name',
            type: 'string',
        },
        {
            name: 'group_owner',
            type: 'string',
        },
        // {
        //   name: 'members_to_add',
        //   type: 'TypeMsg1MembersToAdd[]',
        // },
        // {
        //   name: 'members_to_delete',
        //   type: 'string[]',
        // },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'type',
            type: 'string',
        },
    ],
    // TypeMsg1MembersToAdd: [
    //   {
    //     name: 'expiration_time',
    //     type: 'string',
    //   },
    //   {
    //     name: 'member',
    //     type: 'string',
    //   },
    // ],
};

const MsgUpdateObjectInfoSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'operator',
            type: 'string',
        },
        {
            name: 'bucket_name',
            type: 'string',
        },
        {
            name: 'object_name',
            type: 'string',
        },
        {
            name: 'visibility',
            type: 'string',
        },
    ],
};

let Storage = class Storage {
    constructor(txClient) {
        this.txClient = txClient;
        this.queryClient = container.resolve(RpcQueryClient);
    }
    async params() {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.Params();
    }
    async putPolicy(msg) {
        const toSdk = MsgPutPolicy.toSDK(msg);
        return await this.txClient.tx(MsgPutPolicyTypeUrl, msg.operator, getMsgPutPolicySDKTypeEIP712(msg.statements[0].resources), {
            ...toSdk,
            expiration_time: msg.expirationTime ? fromTimestamp(msg.expirationTime) : '',
            statements: toSdk.statements.map((e) => {
                // @ts-ignore
                e.expiration_time = '';
                if (e.resources.length == 0) {
                    // @ts-ignore
                    e.resources = null;
                }
                return e;
            }),
        }, MsgPutPolicy.encode(msg).finish());
    }
    async deletePolicy(msg) {
        return await this.txClient.tx(MsgDeletePolicyTypeUrl, msg.operator, MsgDeletePolicySDKTypeEIP712, MsgDeletePolicy.toSDK(msg), MsgDeletePolicy.encode(msg).finish());
    }
    async getPolicyForGroup(request) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.QueryPolicyForGroup(request);
    }
    async getQueryPolicyForAccount(request) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.QueryPolicyForAccount(request);
    }
    async getQueryPolicyForGroup(request) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.QueryPolicyForGroup(request);
    }
    async getQueryPolicyById(request) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.QueryPolicyById(request);
    }
    async queryLockFee(request) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.QueryLockFee(request);
    }
    async queryGroupMembersExist(request) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.QueryGroupMembersExist(request);
    }
    async queryGroupExist(request) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.QueryGroupsExist(request);
    }
    async queryGroupsExistById(request) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.QueryGroupsExistById(request);
    }
};
Storage = __decorate([
    injectable(),
    __param(0, inject(delay$1(() => TxClient))),
    __metadata("design:paramtypes", [TxClient])
], Storage);

let Bucket = class Bucket {
    constructor(txClient, sp, storage) {
        this.txClient = txClient;
        this.sp = sp;
        this.storage = storage;
        this.queryClient = container.resolve(RpcQueryClient);
        this.spClient = container.resolve(SpClient);
    }
    async getCreateBucketApproval(params, authType) {
        const { bucketName, creator, visibility = 'VISIBILITY_TYPE_PUBLIC_READ', chargedReadQuota, spInfo, duration, paymentAddress, } = params;
        try {
            if (!spInfo.primarySpAddress) {
                throw new Error('Primary sp address is missing');
            }
            if (!isValidBucketName(bucketName)) ;
            if (!creator) {
                throw new Error('Empty creator address');
            }
            const endpoint = await this.sp.getSPUrlByPrimaryAddr(spInfo.primarySpAddress);
            const { reqMeta, optionsWithOutHeaders, url } = getApprovalMetaInfo(endpoint, 'CreateBucket', {
                bucket_name: bucketName,
                creator,
                visibility,
                primary_sp_address: spInfo.primarySpAddress,
                primary_sp_approval: {
                    expired_height: '0',
                    sig: '',
                    global_virtual_group_family_id: 0,
                },
                charged_read_quota: chargedReadQuota,
                payment_address: paymentAddress,
            });
            const signHeaders = await this.spClient.signHeaders(reqMeta, authType);
            const requestOptions = {
                ...optionsWithOutHeaders,
                headers: signHeaders,
            };
            const result = await this.spClient.callApi(url, requestOptions, duration, {
                code: -1,
                message: 'Get create bucket approval error.',
            });
            const signedMsgString = result.headers.get('X-Gnfd-Signed-Msg') || '';
            return {
                code: 0,
                message: 'Get create bucket approval success.',
                body: signedMsgString,
                statusCode: result.status,
            };
        }
        catch (error) {
            throw {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async createBucketTx(msg, signedMsg) {
        return await this.txClient.tx(MsgCreateBucketTypeUrl, msg.creator, MsgCreateBucketSDKTypeEIP712, {
            ...signedMsg,
            type: MsgCreateBucketTypeUrl,
            charged_read_quota: signedMsg.charged_read_quota,
            visibility: signedMsg.visibility,
            primary_sp_approval: signedMsg.primary_sp_approval,
        }, MsgCreateBucket.encode(msg).finish());
    }
    async createBucket(params, authType) {
        const { body } = await this.getCreateBucketApproval(params, authType);
        if (!body) {
            throw new Error('Get create bucket approval error');
        }
        const signedMsg = JSON.parse(bytesToUtf8(hexToBytes$1(body)));
        const msg = {
            bucketName: signedMsg.bucket_name,
            creator: signedMsg.creator,
            visibility: visibilityTypeFromJSON(signedMsg.visibility),
            primarySpAddress: signedMsg.primary_sp_address,
            primarySpApproval: {
                expiredHeight: Long.fromString(signedMsg.primary_sp_approval.expired_height),
                sig: bytesFromBase64(signedMsg.primary_sp_approval.sig),
                globalVirtualGroupFamilyId: signedMsg.primary_sp_approval.global_virtual_group_family_id,
            },
            chargedReadQuota: Long.fromString(signedMsg.charged_read_quota),
            paymentAddress: signedMsg.payment_address,
        };
        return await this.createBucketTx(msg, signedMsg);
    }
    async deleteBucket(msg) {
        return await this.txClient.tx(MsgDeleteBucketTypeUrl, msg.operator, MsgDeleteBucketSDKTypeEIP712, MsgDeleteBucket.toSDK(msg), MsgDeleteBucket.encode(msg).finish());
    }
    async headBucket(bucketName) {
        const rpc = await this.queryClient.getBucketQueryClient();
        return await rpc.HeadBucket({
            bucketName,
        });
    }
    async headBucketById(bucketId) {
        const rpc = await this.queryClient.getBucketQueryClient();
        return await rpc.HeadBucketById({
            bucketId,
        });
    }
    async headBucketExtra(bucketName) {
        const rpc = await this.queryClient.getBucketQueryClient();
        return await rpc.HeadBucketExtra({
            bucketName,
        });
    }
    async headBucketNFT(request) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.HeadBucketNFT(request);
    }
    async getVerifyPermission(bucketName, operator, actionType) {
        const rpc = await this.queryClient.getBucketQueryClient();
        return rpc.VerifyPermission({
            bucketName,
            operator,
            objectName: '',
            actionType,
        });
    }
    async listBuckets(configParam) {
        try {
            const { address, duration = 30000, endpoint } = configParam;
            if (!isValidAddress(address)) ;
            if (!isValidUrl(endpoint)) {
                throw new Error('Invalid endpoint');
            }
            const { url } = getUserBucketMetaInfo(endpoint);
            const headers = new Headers$1({
                [HTTPHeaderUserAddress]: address,
            });
            const result = await this.spClient.callApi(url, {
                headers,
                method: METHOD_GET,
            }, duration);
            const { status } = result;
            if (!result.ok) {
                const xmlError = await result.text();
                const { code, message } = await parseError(xmlError);
                throw {
                    code: code || -1,
                    message: message || 'Get bucket error.',
                    statusCode: status,
                };
            }
            const xmlData = await result.text();
            const res = await parseGetUserBucketsResponse(xmlData);
            return {
                code: 0,
                message: 'Get bucket success.',
                statusCode: status,
                body: res.GfSpGetUserBucketsResponse.Buckets,
            };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async getBucketReadQuota(params, authType) {
        try {
            const { bucketName, duration = 30000 } = params;
            if (!isValidBucketName(bucketName)) ;
            let endpoint = params.endpoint;
            if (!endpoint) {
                endpoint = await this.sp.getSPUrlByBucket(bucketName);
            }
            const { url, optionsWithOutHeaders, reqMeta } = await getQueryBucketReadQuotaMetaInfo(endpoint, params);
            const signHeaders = await this.spClient.signHeaders(reqMeta, authType);
            const result = await this.spClient.callApi(url, {
                ...optionsWithOutHeaders,
                headers: signHeaders,
            }, duration, {
                code: -1,
                message: 'Get Bucket Quota error.',
            });
            const xmlData = await result.text();
            const res = await parseReadQuotaResponse(xmlData);
            return {
                code: 0,
                body: {
                    readQuota: Number(res.GetReadQuotaResult.ReadQuotaSize ?? '0'),
                    freeQuota: Number(res.GetReadQuotaResult.SPFreeReadQuotaSize ?? '0'),
                    consumedQuota: Number(res.GetReadQuotaResult.ReadConsumedSize ?? '0'),
                    freeConsumedSize: Number(res.GetReadQuotaResult.FreeConsumedSize ?? '0'),
                },
                message: 'Get bucket read quota.',
                statusCode: result.status,
            };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async updateBucketInfo(srcMsg) {
        const msg = {
            ...srcMsg,
            visibility: visibilityTypeFromJSON(srcMsg.visibility),
            chargedReadQuota: UInt64Value.fromPartial({
                value: Long.fromString(srcMsg.chargedReadQuota),
            }),
        };
        return await this.txClient.tx(MsgUpdateBucketInfoTypeUrl, msg.operator, MsgUpdateBucketInfoSDKTypeEIP712, {
            ...MsgUpdateBucketInfo.toSDK(msg),
            charged_read_quota: {
                value: srcMsg.chargedReadQuota,
            },
        }, MsgUpdateBucketInfo.encode(msg).finish());
    }
    async putBucketPolicy(bucketName, srcMsg) {
        const resource = GRNToString(newBucketGRN(bucketName));
        const msg = {
            ...srcMsg,
            resource,
        };
        return this.storage.putPolicy(msg);
    }
    async deleteBucketPolicy(operator, bucketName, principalAddr, principalType) {
        const resource = GRNToString(newBucketGRN(bucketName));
        const principal = {
            type: principalTypeFromJSON(principalType),
            value: principalAddr,
        };
        const msg = {
            resource,
            principal,
            operator: operator,
        };
        return await this.storage.deletePolicy(msg);
    }
    async getBucketPolicy(request) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return rpc.QueryPolicyForAccount(request);
    }
    async getMigrateBucketApproval(params, authType) {
        const { bucketName, operator, dstPrimarySpId } = params;
        try {
            let endpoint = params.endpoint;
            if (!endpoint) {
                endpoint = await this.sp.getSPUrlById(params.dstPrimarySpId);
            }
            const { reqMeta, optionsWithOutHeaders, url } = getApprovalMetaInfo(endpoint, 'MigrateBucket', {
                operator: operator,
                bucket_name: bucketName,
                dst_primary_sp_id: dstPrimarySpId,
                dst_primary_sp_approval: {
                    expired_height: '0',
                    sig: '',
                    global_virtual_group_family_id: 0,
                },
            });
            const signHeaders = await this.spClient.signHeaders(reqMeta, authType);
            const result = await this.spClient.callApi(url, {
                ...optionsWithOutHeaders,
                headers: signHeaders,
            }, 30000);
            const signedMsgString = result.headers.get('X-Gnfd-Signed-Msg') || '';
            const signedMsg = decodeObjectFromHexString(signedMsgString);
            return {
                code: 0,
                message: 'Get migrate bucket approval success.',
                body: signedMsgString,
                statusCode: result.status,
                signedMsg: signedMsg,
            };
        }
        catch (error) {
            throw {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async migrateBucket(params, authType) {
        const { signedMsg } = await this.getMigrateBucketApproval(params, authType);
        if (!signedMsg) {
            throw new Error('Get migrate bucket approval error');
        }
        const msg = {
            bucketName: signedMsg.bucket_name,
            operator: signedMsg.operator,
            dstPrimarySpId: signedMsg.dst_primary_sp_id,
            dstPrimarySpApproval: {
                expiredHeight: Long.fromString(signedMsg.dst_primary_sp_approval.expired_height),
                globalVirtualGroupFamilyId: signedMsg.dst_primary_sp_approval.global_virtual_group_family_id,
                sig: bytesFromBase64(signedMsg.dst_primary_sp_approval.sig),
            },
        };
        return await this.migrateBucketTx(msg, signedMsg);
    }
    async migrateBucketTx(msg, signedMsg) {
        return await this.txClient.tx(MsgMigrateBucketTypeUrl, msg.operator, MsgMigrateBucketSDKTypeEIP712, {
            ...signedMsg,
            type: MsgMigrateBucketTypeUrl,
            primary_sp_approval: {
                expired_height: signedMsg.dst_primary_sp_approval.expired_height,
                global_virtual_group_family_id: signedMsg.dst_primary_sp_approval.global_virtual_group_family_id,
                sig: signedMsg.dst_primary_sp_approval.sig,
            },
        }, MsgMigrateBucket.encode(msg).finish());
    }
    async getBucketMeta(params) {
        const { bucketName } = params;
        if (!isValidBucketName(bucketName)) ;
        let endpoint = params.endpoint;
        if (!endpoint) {
            endpoint = await this.sp.getSPUrlByBucket(bucketName);
        }
        const { url } = getBucketMetaInfo(endpoint, params);
        const result = await this.spClient.callApi(url, {
            method: METHOD_GET,
        });
        const xml = await result.text();
        const res = await parseGetBucketMetaResponse(xml);
        return {
            code: 0,
            message: 'get bucket meta success.',
            statusCode: result.status,
            body: res,
        };
    }
    async listBucketReadRecords(params, authType) {
        try {
            const { bucketName } = params;
            let endpoint = params.endpoint;
            if (!endpoint) {
                endpoint = await this.sp.getSPUrlByBucket(bucketName);
            }
            if (!isValidUrl(endpoint)) {
                throw new Error('Invalid endpoint');
            }
            const { url, optionsWithOutHeaders, reqMeta } = getListBucketReadRecordMetaInfo(endpoint, params);
            const signHeaders = await this.spClient.signHeaders(reqMeta, authType);
            const result = await this.spClient.callApi(url, {
                ...optionsWithOutHeaders,
                headers: signHeaders,
            }, 3000, {
                code: -1,
                message: 'Get Bucket Quota error.',
            });
            const xmlData = await result.text();
            const res = await parseListBucketReadRecordResponse(xmlData);
            return {
                code: 0,
                body: res,
                message: 'success',
                statusCode: result.status,
            };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async listBucketsByIds(params) {
        try {
            const { ids } = params;
            const sp = await this.sp.getInServiceSP();
            const { url } = getListBucketsByIDsMetaInfo(sp.endpoint, { ids });
            const result = await this.spClient.callApi(url, {
                headers: {},
                method: METHOD_GET,
            }, 3000);
            const { status } = result;
            if (!result.ok) {
                const xmlError = await result.text();
                const { code, message } = await parseError(xmlError);
                throw {
                    code: code || -1,
                    message: message || 'error',
                    statusCode: status,
                };
            }
            const xmlData = await result.text();
            const res = await parseListBucketsByIdsResponse(xmlData);
            return {
                code: 0,
                message: 'success',
                statusCode: status,
                body: res,
            };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async listBucketsByPaymentAccount(params) {
        try {
            const sp = await this.sp.getInServiceSP();
            const { url } = getListBucketByPaymentMetaInfo(sp.endpoint, params);
            const result = await this.spClient.callApi(url, {
                headers: {},
                method: METHOD_GET,
            });
            const xmlData = await result.text();
            const res = parseListBucketByPaymentResponse(xmlData);
            return {
                code: 0,
                message: 'Get bucket success.',
                statusCode: result.status,
                body: res,
            };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
};
Bucket = __decorate([
    injectable(),
    __param(0, inject(delay$1(() => TxClient))),
    __param(1, inject(delay$1(() => Sp))),
    __param(2, inject(delay$1(() => Storage))),
    __metadata("design:paramtypes", [TxClient,
        Sp,
        Storage])
], Bucket);

let Challenge = class Challenge {
    constructor(txClient) {
        this.txClient = txClient;
        this.queryClient = container.resolve(RpcQueryClient);
    }
    async submitChallenge(address, msg) {
        return await this.txClient.tx(MsgSubmitTypeUrl, address, MsgSubmitSDKTypeEIP712, MsgSubmit.toSDK(msg), MsgSubmit.encode(msg).finish());
    }
    async attestChallenge(address, msg) {
        return await this.txClient.tx(MsgAttestTypeUrl, address, MsgAttestSDKTypeEIP712, MsgAttest.toSDK(msg), MsgAttest.encode(msg).finish());
    }
    async latestAttestedChallenges() {
        const rpc = await this.queryClient.getChallengeQueryClient();
        return await rpc.LatestAttestedChallenges();
    }
    async inturnAttestationSubmitter() {
        const rpc = await this.queryClient.getChallengeQueryClient();
        return await rpc.InturnAttestationSubmitter();
    }
    async params() {
        const rpc = await this.queryClient.getChallengeQueryClient();
        return await rpc.Params();
    }
};
Challenge = __decorate([
    injectable(),
    __param(0, inject(delay$1(() => TxClient))),
    __metadata("design:paramtypes", [TxClient])
], Challenge);

const MsgClaimSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'from_address',
            type: 'string',
        },
        {
            name: 'src_chain_id',
            type: 'uint32',
        },
        {
            name: 'dest_chain_id',
            type: 'uint32',
        },
        {
            name: 'sequence',
            type: 'uint64',
        },
        {
            name: 'timestamp',
            type: 'uint64',
        },
    ],
};

let CrossChain = class CrossChain {
    constructor(txClient) {
        this.txClient = txClient;
        this.queryClient = container.resolve(RpcQueryClient);
    }
    async transferOut(msg) {
        return await this.txClient.tx(MsgTransferOutTypeUrl, msg.from, MsgTransferOutSDKTypeEIP712, MsgTransferOut.toSDK(msg), MsgTransferOut.encode(msg).finish());
    }
    async claims(msg) {
        return await this.txClient.tx(MsgClaimTypeUrl, msg.fromAddress, MsgClaimSDKTypeEIP712, MsgClaim.toSDK(msg), MsgClaim.encode(msg).finish());
    }
    async getChannelSendSequence(request) {
        const rpc = await this.queryClient.getCrosschainQueryClient();
        return await rpc.SendSequence(request);
    }
    async getChannelReceiveSequence(request) {
        const rpc = await this.queryClient.getCrosschainQueryClient();
        return await rpc.ReceiveSequence(request);
    }
    async getInturnRelayer() {
        const rpc = await this.queryClient.getOracleQueryClient();
        return await rpc.InturnRelayer();
    }
    async getCrosschainPackage(request) {
        const rpc = await this.queryClient.getCrosschainQueryClient();
        return await rpc.CrossChainPackage(request);
    }
    async mirrorGroup(msg) {
        return await this.txClient.tx(MsgMirrorGroupTypeUrl, msg.operator, MsgMirrorGroupSDKTypeEIP712, MsgMirrorGroup.toSDK(msg), MsgMirrorGroup.encode(msg).finish());
    }
    async mirrorBucket(msg) {
        return await this.txClient.tx(MsgMirrorBucketTypeUrl, msg.operator, MsgMirrorBucketSDKTypeEIP712, MsgMirrorBucket.toSDK(msg), MsgMirrorBucket.encode(msg).finish());
    }
    async mirrorObject(msg) {
        return await this.txClient.tx(MsgMirrorObjectTypeUrl, msg.operator, MsgMirrorObjectSDKTypeEIP712, MsgMirrorObject.toSDK(msg), MsgMirrorObject.encode(msg).finish());
    }
    async getParams() {
        const rpc = await this.queryClient.getBridgeQueryClient();
        return rpc.Params();
    }
};
CrossChain = __decorate([
    injectable(),
    __param(0, inject(delay$1(() => TxClient))),
    __metadata("design:paramtypes", [TxClient])
], CrossChain);

const MsgFundCommunityPoolTypeUrlSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'amount',
            type: 'TypeMsg1Amount[]',
        },
        {
            name: 'depositor',
            type: 'string',
        },
        {
            name: 'type',
            type: 'string',
        },
    ],
    TypeMsg1Amount: [
        {
            name: 'amount',
            type: 'string',
        },
        {
            name: 'denom',
            type: 'string',
        },
    ],
};

const MsgSetWithdrawAddressSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'delegator_address',
            type: 'string',
        },
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'withdraw_address',
            type: 'string',
        },
    ],
};

const MsgWithdrawDelegatorRewardSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'delegator_address',
            type: 'string',
        },
        {
            name: 'validator_address',
            type: 'string',
        },
    ],
};

const MsgWithdrawValidatorCommissionSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'validator_address',
            type: 'string',
        },
    ],
};

let Distribution = class Distribution {
    constructor(txClient) {
        this.txClient = txClient;
    }
    async setWithdrawAddress(msg) {
        return await this.txClient.tx(MsgSetWithdrawAddressTypeUrl, msg.delegatorAddress, MsgSetWithdrawAddressSDKTypeEIP712, MsgSetWithdrawAddress.toSDK(msg), MsgSetWithdrawAddress.encode(msg).finish());
    }
    async withdrawValidatorCommission(address, msg) {
        return await this.txClient.tx(MsgWithdrawValidatorCommissionTypeUrl, address, MsgWithdrawValidatorCommissionSDKTypeEIP712, MsgWithdrawValidatorCommission.toSDK(msg), MsgWithdrawValidatorCommission.encode(msg).finish());
    }
    async withdrawDelegatorReward(msg) {
        return await this.txClient.tx(MsgWithdrawDelegatorRewardTypeUrl, msg.delegatorAddress, MsgWithdrawDelegatorRewardSDKTypeEIP712, MsgWithdrawDelegatorReward.toSDK(msg), MsgWithdrawDelegatorReward.encode(msg).finish());
    }
    async fundCommunityPoolundComm(address, msg) {
        return await this.txClient.tx(MsgFundCommunityPoolTypeUrl, address, MsgFundCommunityPoolTypeUrlSDKTypeEIP712, MsgFundCommunityPool.toSDK(msg), MsgFundCommunityPool.encode(msg).finish());
    }
};
Distribution = __decorate([
    injectable(),
    __param(0, inject(delay$1(() => TxClient))),
    __metadata("design:paramtypes", [TxClient])
], Distribution);

const MsgGrantAllowanceSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'granter',
            type: 'string',
        },
        {
            name: 'grantee',
            type: 'string',
        },
        {
            name: 'allowance',
            type: 'TypeAny',
        },
    ],
    TypeAny: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'value',
            type: 'bytes',
        },
    ],
};

const MsgRevokeAllowanceSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'granter',
            type: 'string',
        },
        {
            name: 'grantee',
            type: 'string',
        },
    ],
};

let FeeGrant = class FeeGrant {
    constructor(txClient) {
        this.txClient = txClient;
        this.queryClient = container.resolve(RpcQueryClient);
    }
    async grantAllowance(params) {
        const { amount, denom, allowedMessages, grantee, granter, expirationTime } = params;
        const basicAllowance = newBasicAllowance(amount, denom, expirationTime);
        const allowedMsgAllowance = newAllowedMsgAllowance(allowedMessages, basicAllowance);
        const grantAllowance = newMsgGrantAllowance(grantee, granter, allowedMsgAllowance);
        const marshal = newMarshal(amount, denom, allowedMessages, expirationTime);
        return await this.txClient.tx(MsgGrantAllowanceTypeUrl, granter, MsgGrantAllowanceSDKTypeEIP712, {
            ...MsgGrantAllowance.toSDK(grantAllowance),
            allowance: {
                type: grantAllowance.allowance?.typeUrl,
                value: base64FromBytes(arrayify('0x' + encodeToHex(JSON.stringify(marshal)))),
            },
        }, MsgGrantAllowance.encode(grantAllowance).finish());
    }
    async revokeAllowance(msg) {
        return await this.txClient.tx(MsgRevokeAllowanceTypeUrl, msg.granter, MsgRevokeAllowanceSDKTypeEIP712, MsgRevokeAllowance.toSDK(msg), MsgRevokeAllowance.encode(msg).finish());
    }
    async getAllowence(request) {
        const rpc = await this.queryClient.getFeeGrantQueryClient();
        return await rpc.Allowance(request);
    }
    async getAllowences(request) {
        const rpc = await this.queryClient.getFeeGrantQueryClient();
        return await rpc.Allowances(request);
    }
};
FeeGrant = __decorate([
    injectable(),
    __param(0, inject(delay$1(() => TxClient))),
    __metadata("design:paramtypes", [TxClient])
], FeeGrant);

let Gashub = class Gashub {
    constructor() {
        this.queryClient = container.resolve(RpcQueryClient);
    }
    async getMsgGasParams(request) {
        const rpc = await this.queryClient.getGashubClient();
        return await rpc.MsgGasParams(request);
    }
    async getParams() {
        const rpc = await this.queryClient.getGashubClient();
        return await rpc.Params();
    }
};
Gashub = __decorate([
    injectable()
], Gashub);

let Group = class Group {
    constructor(txClient, storage) {
        this.txClient = txClient;
        this.storage = storage;
        this.queryClient = container.resolve(RpcQueryClient);
    }
    async createGroup(msg) {
        return await this.txClient.tx(MsgCreateGroupTypeUrl, msg.creator, MsgCreateGroupSDKTypeEIP712, MsgCreateGroup.toSDK(msg), MsgCreateGroup.encode(msg).finish());
    }
    async deleteGroup(msg) {
        return await this.txClient.tx(MsgDeleteGroupTypeUrl, msg.operator, MsgDeleteGroupSDKTypeEIP712, MsgDeleteGroup.toSDK(msg), MsgDeleteGroup.encode(msg).finish());
    }
    async updateGroupMember(msg) {
        if (msg.groupName === '') {
            throw new Error('group name is empty');
        }
        if (msg.membersToAdd.length === 0 && msg.membersToDelete.length === 0) {
            throw new Error('no update member');
        }
        return await this.txClient.tx(MsgUpdateGroupMemberTypeUrl, msg.operator, getMsgUpdateGroupMemberSDKTypeEIP712({
            membersToAdd: msg.membersToAdd,
            membersToDelete: msg.membersToDelete,
        }), {
            ...MsgUpdateGroupMember.toSDK(msg),
            members_to_add: msg.membersToAdd.map((x) => {
                return {
                    member: x.member,
                    expiration_time: fromTimestamp(x.expirationTime),
                };
            }),
        }, MsgUpdateGroupMember.encode(msg).finish());
    }
    async updateGroupExtra(msg) {
        return await this.txClient.tx(MsgUpdateGroupExtraTypeUrl, msg.operator, MsgUpdateGroupExtraSDKTypeEIP712, MsgUpdateGroupExtra.toSDK(msg), MsgUpdateGroupExtra.encode(msg).finish());
    }
    async leaveGroup(address, msg) {
        return await this.txClient.tx(MsgLeaveGroupTypeUrl, address, MsgLeaveGroupSDKTypeEIP712, MsgLeaveGroup.toSDK(msg), MsgLeaveGroup.encode(msg).finish());
    }
    async headGroup(groupName, groupOwner) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.HeadGroup({
            groupName,
            groupOwner,
        });
    }
    async headGroupMember(groupName, groupOwner, member) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.HeadGroupMember({
            groupName,
            groupOwner,
            member,
        });
    }
    async headGroupNFT(request) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.HeadGroupNFT(request);
    }
    async listGroup(request) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.ListGroups(request);
    }
    async getPolicyOfGroup(request) {
        return await this.storage.getPolicyForGroup(request);
    }
    async getBucketPolicyOfGroup(bucketName, groupId) {
        const resource = GRNToString(newBucketGRN(bucketName));
        return await this.storage.getPolicyForGroup({
            resource,
            principalGroupId: groupId.toString(),
        });
    }
    async getObjectPolicyOfGroup(bucketName, objectName, groupId) {
        const resource = GRNToString(newObjectGRN(bucketName, objectName));
        return await this.storage.getPolicyForGroup({
            resource,
            principalGroupId: groupId.toString(),
        });
    }
    async putGroupPolicy(owner, groupName, srcMsg) {
        const resource = GRNToString(newGroupGRN(owner, groupName));
        const msg = {
            ...srcMsg,
            resource,
        };
        return this.storage.putPolicy(msg);
    }
};
Group = __decorate([
    injectable(),
    __param(0, inject(delay$1(() => TxClient))),
    __param(1, inject(delay$1(() => Storage))),
    __metadata("design:paramtypes", [TxClient,
        Storage])
], Group);

// https://docs.bnbchain.org/greenfield-docs/docs/api/storage-provider-rest/get_object_meta
const getObjectMetaInfo = (endpoint, params) => {
    const { objectName, bucketName } = params;
    const path = `${encodePath(objectName)}`;
    const queryMap = {
        'object-meta': '',
    };
    let url = new URL(path, generateUrlByBucketName(endpoint, bucketName));
    url = getSortQueryParams(url, queryMap);
    return {
        url: url.href,
    };
};
const parseGetObjectMetaResponse = async (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    const Object = res.GfSpGetObjectMetaResponse.Object || {};
    if (Object) {
        // @ts-ignore
        Object.Removed = convertStrToBool(Object.Removed);
        Object.UpdateAt = Number(Object.UpdateAt);
        Object.DeleteAt = Number(Object.DeleteAt);
        Object.ObjectInfo = formatObjectInfo(Object.ObjectInfo);
    }
    res.GfSpGetObjectMetaResponse = {
        ...res.GfSpGetObjectMetaResponse,
        Object,
    };
    return res;
};

const getListObjectPoliciesMetaInfo = (endpoint, params) => {
    const { actionType, bucketName, objectName, limit = '10', startAfter = '' } = params;
    const path = `/${encodePath(objectName)}`;
    const queryMap = {
        'object-policies': 'null',
        'start-after': startAfter,
        limit: String(limit),
        'action-type': String(actionTypeFromJSON(actionType)),
    };
    let url = new URL(path, generateUrlByBucketName(endpoint, bucketName));
    url = getSortQueryParams(url, queryMap);
    return {
        url: url.href,
    };
};
const parseGetListObjectPoliciesResponse = (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    let Policies = res.GfSpListObjectPoliciesResponse.Policies || [];
    if (Policies) {
        if (!Array.isArray(Policies)) {
            Policies = [Policies];
        }
        Policies = Policies.map((item) => {
            return {
                ...item,
                PrincipalType: Number(item.ResourceType),
                ResourceType: Number(item.ResourceType),
                CreateTimestamp: Number(item.CreateTimestamp),
                UpdateTimestamp: Number(item.UpdateTimestamp),
                ExpirationTime: Number(item.ExpirationTime),
            };
        });
    }
    res.GfSpListObjectPoliciesResponse = {
        Policies,
    };
    return res;
};

// https://docs.bnbchain.org/greenfield-docs/docs/api/storage-provider-rest/list_objects_by_bucket
const parseListObjectsByBucketNameResponse = async (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    let Objects = res.GfSpListObjectsByBucketNameResponse.Objects || [];
    if (Objects) {
        if (!Array.isArray(Objects)) {
            Objects = [Objects];
        }
        Objects = Objects.map((item) => {
            return {
                ...item,
                // @ts-ignore
                Removed: convertStrToBool(item.Removed),
                UpdateAt: Number(item.UpdateAt),
                DeleteAt: Number(item.DeleteAt),
                ObjectInfo: formatObjectInfo(item.ObjectInfo),
            };
        });
    }
    let CommonPrefixes = res.GfSpListObjectsByBucketNameResponse.CommonPrefixes || [];
    if (CommonPrefixes) {
        if (!Array.isArray(CommonPrefixes)) {
            CommonPrefixes = [CommonPrefixes];
        }
    }
    res.GfSpListObjectsByBucketNameResponse = {
        ...res.GfSpListObjectsByBucketNameResponse,
        Objects,
        CommonPrefixes,
        // @ts-ignore
        IsTruncated: convertStrToBool(res.GfSpListObjectsByBucketNameResponse.IsTruncated),
    };
    return res;
};

// https://docs.bnbchain.org/greenfield-docs/docs/api/storage-provider-rest/list_objects_by_ids
const getListObjectsByIDsMetaInfo = (endpoint, params) => {
    const path = '';
    const queryMap = {
        ids: params.ids.join(','),
        'objects-query': 'null',
    };
    let url = new URL(path, endpoint);
    url = getSortQueryParams(url, queryMap);
    return {
        url: url.href,
    };
};
const parseListObjectsByIdsResponse = async (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    let ObjectEntry = res.GfSpListObjectsByIDsResponse.ObjectEntry;
    if (ObjectEntry) {
        if (!Array.isArray(ObjectEntry)) {
            ObjectEntry = [ObjectEntry];
        }
        ObjectEntry = ObjectEntry.map((item) => {
            let Value = item.Value;
            if (Value) {
                Value = {
                    ...item.Value,
                    ObjectInfo: formatObjectInfo(item.Value.ObjectInfo),
                    // @ts-ignore
                    Removed: convertStrToBool(item.Value.Removed),
                    UpdateAt: Number(item.Value.UpdateAt),
                    DeleteAt: Number(item.Value.DeleteAt),
                };
            }
            return {
                ...item,
                Id: Number(item.Id),
                Value,
            };
        });
    }
    res.GfSpListObjectsByIDsResponse = {
        ...res.GfSpListObjectsByIDsResponse,
        ObjectEntry,
    };
    return res;
};

let Objectt = class Objectt {
    constructor(txClient, storage, sp) {
        this.txClient = txClient;
        this.storage = storage;
        this.sp = sp;
        this.queryClient = container.resolve(RpcQueryClient);
        this.spClient = container.resolve(SpClient);
    }
    async getCreateObjectApproval(params, authType) {
        const { bucketName, creator, objectName, visibility = 'VISIBILITY_TYPE_PUBLIC_READ', duration = 3000, fileType = 'application/octet-stream', redundancyType = 'REDUNDANCY_EC_TYPE', contentLength, expectCheckSums, } = params;
        try {
            if (!isValidBucketName(bucketName)) ;
            if (!isValidObjectName(objectName)) ;
            if (!creator) {
                throw new Error('empty creator address');
            }
            let endpoint = params.endpoint;
            if (!endpoint) {
                endpoint = await this.sp.getSPUrlByBucket(bucketName);
            }
            const { reqMeta, optionsWithOutHeaders, url } = getApprovalMetaInfo(endpoint, 'CreateObject', {
                bucket_name: bucketName,
                content_type: fileType,
                creator: creator,
                expect_checksums: expectCheckSums,
                object_name: objectName,
                payload_size: contentLength.toString(),
                primary_sp_approval: {
                    expired_height: '0',
                    global_virtual_group_family_id: 0,
                    sig: null,
                },
                redundancy_type: redundancyType,
                visibility,
            });
            const signHeaders = await this.spClient.signHeaders(reqMeta, authType);
            const result = await this.spClient.callApi(url, {
                ...optionsWithOutHeaders,
                headers: signHeaders,
            }, duration, {
                code: -1,
                message: 'Get create object approval error.',
            });
            const signedMsgString = result.headers.get('X-Gnfd-Signed-Msg') || '';
            const signedMsg = JSON.parse(bytesToUtf8(hexToBytes$1(signedMsgString)));
            return {
                code: 0,
                message: 'Get create object approval success.',
                body: result.headers.get('X-Gnfd-Signed-Msg') ?? '',
                statusCode: result.status,
                signedMsg,
            };
        }
        catch (error) {
            throw {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async createObjectTx(msg, signedMsg) {
        return await this.txClient.tx(MsgCreateObjectTypeUrl, msg.creator, MsgCreateObjectSDKTypeEIP712, {
            ...signedMsg,
            type: MsgCreateObjectTypeUrl,
            primary_sp_approval: {
                expired_height: signedMsg.primary_sp_approval.expired_height,
                global_virtual_group_family_id: signedMsg.primary_sp_approval.global_virtual_group_family_id,
                sig: signedMsg.primary_sp_approval.sig,
            },
        }, MsgCreateObject.encode(msg).finish());
    }
    async createObject(getApprovalParams, authType) {
        const { signedMsg } = await this.getCreateObjectApproval(getApprovalParams, authType);
        if (!signedMsg) {
            throw new Error('Get create object approval error');
        }
        const msg = {
            bucketName: signedMsg.bucket_name,
            creator: signedMsg.creator,
            objectName: signedMsg.object_name,
            contentType: signedMsg.content_type,
            payloadSize: Long.fromString(signedMsg.payload_size),
            visibility: visibilityTypeFromJSON(signedMsg.visibility),
            expectChecksums: signedMsg.expect_checksums.map((e) => bytesFromBase64(e)),
            redundancyType: redundancyTypeFromJSON(signedMsg.redundancy_type),
            primarySpApproval: {
                expiredHeight: Long.fromString(signedMsg.primary_sp_approval.expired_height),
                sig: bytesFromBase64(signedMsg.primary_sp_approval.sig || ''),
                globalVirtualGroupFamilyId: signedMsg.primary_sp_approval.global_virtual_group_family_id,
            },
        };
        return await this.createObjectTx(msg, signedMsg);
    }
    async uploadObject(params, authType) {
        const { bucketName, objectName, txnHash, body, duration = 30000 } = params;
        if (!isValidBucketName(bucketName)) ;
        if (!isValidObjectName(objectName)) ;
        if (!txnHash) {
            throw new Error('Transaction hash is empty, please check.');
        }
        let endpoint = params.endpoint;
        if (!endpoint) {
            endpoint = await this.sp.getSPUrlByBucket(bucketName);
        }
        const { reqMeta, optionsWithOutHeaders, url } = await getPutObjectMetaInfo(endpoint, {
            bucketName,
            objectName,
            contentType: body.type,
            txnHash,
            body,
        });
        const signHeaders = await this.spClient.signHeaders(reqMeta, authType);
        try {
            const result = await this.spClient.callApi(url, {
                ...optionsWithOutHeaders,
                headers: signHeaders,
            }, duration);
            const { status } = result;
            return { code: 0, message: 'Put object success.', statusCode: status };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async cancelCreateObject(msg) {
        return await this.txClient.tx(MsgCancelCreateObjectTypeUrl, msg.operator, MsgCancelCreateObjectSDKTypeEIP712, MsgCancelCreateObject.toSDK(msg), MsgCancelCreateObject.encode(msg).finish());
    }
    async deleteObject(msg) {
        return await this.txClient.tx(MsgDeleteObjectTypeUrl, msg.operator, MsgDeleteObjectSDKTypeEIP712, MsgDeleteObject.toSDK(msg), MsgDeleteObject.encode(msg).finish());
    }
    async updateObjectInfo(msg) {
        return await this.txClient.tx(MsgUpdateObjectInfoTypeUrl, msg.operator, MsgUpdateObjectInfoSDKTypeEIP712, MsgUpdateObjectInfo.toSDK(msg), MsgUpdateObjectInfo.encode(msg).finish());
    }
    async headObject(bucketName, objectName) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return rpc.HeadObject({
            bucketName,
            objectName,
        });
    }
    async headObjectById(objectId) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return rpc.HeadObjectById({
            objectId,
        });
    }
    async headObjectNFT(request) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.HeadObjectNFT(request);
    }
    async getObject(params, authType) {
        try {
            const { bucketName, objectName, duration = 30000 } = params;
            if (!isValidBucketName(bucketName)) ;
            if (!isValidObjectName(objectName)) ;
            let endpoint = params.endpoint;
            if (!endpoint) {
                endpoint = await this.sp.getSPUrlByBucket(bucketName);
            }
            const { reqMeta, optionsWithOutHeaders, url } = await getGetObjectMetaInfo(endpoint, {
                bucketName,
                objectName,
            });
            const headers = await this.spClient.signHeaders(reqMeta, authType);
            const result = await this.spClient.callApi(url, {
                ...optionsWithOutHeaders,
                headers,
            }, duration);
            const { status } = result;
            if (!result.ok) {
                const xmlError = await result.text();
                const { code, message } = await parseError(xmlError);
                return {
                    code: code || -1,
                    message: message || 'Get object error.',
                    statusCode: status,
                };
            }
            const fileBlob = await result.blob();
            return {
                code: 0,
                body: fileBlob,
                message: 'Get object success.',
                statusCode: status,
            };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async getObjectPreviewUrl(params, authType) {
        const { bucketName, objectName, queryMap } = params;
        if (!isValidBucketName(bucketName)) ;
        if (!isValidObjectName(objectName)) ;
        let endpoint = params.endpoint;
        if (!endpoint) {
            endpoint = await this.sp.getSPUrlByBucket(bucketName);
        }
        const path = '/' + encodePath(objectName);
        const url = generateUrlByBucketName(endpoint, bucketName) + path;
        const queryRaw = getSortQuery(queryMap);
        const canonicalRequest = [
            METHOD_GET,
            `/${encodePath(objectName)}`,
            queryRaw,
            new URL(url).host,
            '\n',
        ].join('\n');
        const unsignedMsg = getMsgToSign(utf8ToBytes$1(canonicalRequest));
        let authorization = '';
        if (authType.type === 'ECDSA') {
            const sig = secpSign(unsignedMsg, authType.privateKey);
            authorization = `GNFD1-ECDSA, Signature=${sig.slice(2)}`;
        }
        else {
            const sig = await signSignatureByEddsa(authType.seed, hexlify(unsignedMsg).slice(2));
            authorization = `GNFD1-EDDSA,Signature=${sig}`;
        }
        return `${url}?Authorization=${encodeURIComponent(authorization)}&${queryRaw}`;
    }
    async downloadFile(configParam, authType) {
        try {
            const { objectName } = configParam;
            const getObjectResult = await this.getObject(configParam, authType);
            if (getObjectResult.code !== 0) {
                throw new Error(getObjectResult.message);
            }
            const file = getObjectResult?.body;
            if (file) {
                // const {file} = getObjectResult;
                const fileURL = URL.createObjectURL(file);
                // create <a> tag dynamically
                const fileLink = document.createElement('a');
                fileLink.href = fileURL;
                // it forces the name of the downloaded file
                fileLink.download = objectName;
                // triggers the click event
                fileLink.click();
            }
            return;
        }
        catch (error) {
            throw new Error(error);
        }
    }
    async listObjects(configParam) {
        try {
            const { bucketName, endpoint, duration = 30000, query = new URLSearchParams() } = configParam;
            if (!isValidBucketName(bucketName)) ;
            if (!isValidUrl(endpoint)) {
                throw new Error('Invalid endpoint');
            }
            const url = `${generateUrlByBucketName(endpoint, bucketName)}?${query?.toString()}`;
            const headers = new Headers$1();
            const result = await this.spClient.callApi(url, {
                headers,
                method: METHOD_GET,
            }, duration);
            const { status } = result;
            if (!result.ok) {
                const xmlError = await result.text();
                const { code, message } = await parseError(xmlError);
                return {
                    code: code || -1,
                    message: message || 'List object error.',
                    statusCode: status,
                };
            }
            const xmlData = await result.text();
            const res = await parseListObjectsByBucketNameResponse(xmlData);
            return {
                code: 0,
                message: 'List object success.',
                statusCode: status,
                body: res,
            };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async createFolder(getApprovalParams, authType) {
        if (!getApprovalParams.objectName.endsWith('/')) {
            throw new Error('failed to create folder. Folder names must end with a forward slash (/) character');
        }
        /**
         * const file = new File([], 'scc', { type: 'text/plain' });
          const fileBytes = await file.arrayBuffer();
          console.log('fileBytes', fileBytes);
          const hashResult = await FileHandler.getPieceHashRoots(new Uint8Array(fileBytes));
          console.log('hashResult', hashResult);
          const { contentLength, expectCheckSums } = hashResult;
         */
        const params = {
            bucketName: getApprovalParams.bucketName,
            objectName: getApprovalParams.objectName,
            contentLength: 0,
            fileType: 'text/plain',
            expectCheckSums: [
                '47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=',
                '47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=',
                '47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=',
                '47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=',
                '47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=',
                '47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=',
                '47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=',
            ],
            creator: getApprovalParams.creator,
        };
        return this.createObject(params, authType);
    }
    async putObjectPolicy(bucketName, objectName, 
    // expirationTime: Date,
    srcMsg) {
        const resource = GRNToString(newObjectGRN(bucketName, objectName));
        const msg = {
            ...srcMsg,
            resource,
            // expirationTime: fromJsonTimestamp(expirationTime),
        };
        return await this.storage.putPolicy(msg);
    }
    async isObjectPermissionAllowed(bucketName, objectName, actionType, operator) {
        const rpc = await this.queryClient.getStorageQueryClient();
        return await rpc.VerifyPermission({
            bucketName,
            objectName,
            actionType,
            operator,
        });
    }
    async getObjectPolicy(bucketName, objectName, principalAddr) {
        const rpc = await this.queryClient.getStorageQueryClient();
        const resource = GRNToString(newObjectGRN(bucketName, objectName));
        return await rpc.QueryPolicyForAccount({
            resource,
            principalAddress: principalAddr,
        });
    }
    async deleteObjectPolicy(operator, bucketName, objectName, principalAddr, principalType) {
        const resource = GRNToString(newObjectGRN(bucketName, objectName));
        const principal = {
            type: principalTypeFromJSON(principalType),
            value: principalAddr,
        };
        const msg = {
            resource,
            principal,
            operator: operator,
        };
        return await this.storage.deletePolicy(msg);
    }
    async getObjectMeta(params) {
        const { bucketName, objectName, endpoint } = params;
        if (!isValidBucketName(bucketName)) ;
        if (!isValidObjectName(objectName)) ;
        const { url } = getObjectMetaInfo(endpoint, params);
        const result = await this.spClient.callApi(url, {
            method: METHOD_GET,
        });
        const xml = await result.text();
        const res = await parseGetObjectMetaResponse(xml);
        return {
            code: 0,
            message: 'get object meta success.',
            statusCode: result.status,
            body: res,
        };
    }
    async listObjectsByIds(params) {
        try {
            const sp = await this.sp.getInServiceSP();
            const { url } = getListObjectsByIDsMetaInfo(sp.endpoint, params);
            const result = await this.spClient.callApi(url, {
                headers: {},
                method: METHOD_GET,
            }, 3000);
            const { status } = result;
            if (!result.ok) {
                const xmlError = await result.text();
                const { code, message } = await parseError(xmlError);
                throw {
                    code: code || -1,
                    message: message || 'error',
                    statusCode: status,
                };
            }
            const xmlData = await result.text();
            const res = await parseListObjectsByIdsResponse(xmlData);
            return {
                code: 0,
                message: 'success',
                statusCode: status,
                body: res,
            };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
    async listObjectPolicies(params) {
        let endpoint = params.endpoint;
        if (!endpoint) {
            endpoint = await this.sp.getSPUrlByBucket(params.bucketName);
        }
        const { url } = getListObjectPoliciesMetaInfo(endpoint, params);
        const result = await this.spClient.callApi(url, {
            headers: {},
            method: METHOD_GET,
        });
        const xml = await result.text();
        const res = parseGetListObjectPoliciesResponse(xml);
        return {
            code: 0,
            message: 'success',
            statusCode: result.status,
            body: res,
        };
    }
};
Objectt = __decorate([
    injectable(),
    __param(0, inject(delay$1(() => TxClient))),
    __param(1, inject(delay$1(() => Storage))),
    __param(2, inject(delay$1(() => Sp))),
    __metadata("design:paramtypes", [TxClient,
        Storage,
        Sp])
], Objectt);

let OffChainAuth = class OffChainAuth {
    async genOffChainAuthKeyPairAndUpload({ sps, address, domain, expirationMs, chainId }, provider) {
        try {
            // 1. first sign, generate seed string and public key
            const spsNonceRaw = await fetchNonces({ sps, address, domain });
            const fetchSpsNonceFailed = spsNonceRaw
                .filter((item) => item.nonce === null)
                .map((item) => item.address);
            if (fetchSpsNonceFailed.length === spsNonceRaw.length) {
                throw new Error(`No SP service is available. Please try again later.`);
            }
            const spsWithNonce = spsNonceRaw.filter((item) => item.nonce !== null);
            // 2. generate signature key pair
            const seedMsg = genLocalSignMsg(spsWithNonce, domain);
            // Uint8Array
            const seed = await getCurrentSeedString({ message: seedMsg, address, chainId, provider });
            const seedString = hexlify(seed);
            const pubKey = await getCurrentAccountPublicKey(seedString);
            // 3. second sign for upload public key to server
            const curUtcZeroTimestamp = getUtcZeroTimestamp();
            const expirationTime = curUtcZeroTimestamp + expirationMs;
            const issuedDate = convertTimeStampToDate(curUtcZeroTimestamp);
            const expireDate = convertTimeStampToDate(expirationTime);
            const signMsg = genSecondSignMsg({
                domain,
                address,
                pubKey,
                chainId,
                issuedDate,
                expireDate,
                sps: spsWithNonce,
            });
            const signRes = await personalSign({ message: signMsg, address, provider });
            const jsonSignMsg = JSON.stringify(signMsg).replace(/\"/g, '');
            const authorization = `GNFD1-ETH-PERSONAL_SIGN,SignedMsg=${jsonSignMsg},Signature=${signRes}`;
            // 4. upload signature and pubKey to server
            const res = await updateSpsPubKey({
                address,
                sps: spsWithNonce,
                domain,
                pubKey,
                expireDate,
                authorization,
            });
            const uploadSpsPubkeyFailed = res
                .filter((item) => item.code !== 0)
                .map((item) => item.data.address);
            if (uploadSpsPubkeyFailed.length === spsWithNonce.length) {
                throw new Error(`No SP service is available. Please try again later.`);
            }
            const successSps = [];
            res.forEach((item) => {
                if (item.code === 0) {
                    successSps.push(item.data.address);
                }
            });
            return {
                code: 0,
                body: {
                    seedString,
                    pubKey,
                    expirationTime,
                    spAddresses: successSps,
                    failedSpAddresses: [...fetchSpsNonceFailed, ...uploadSpsPubkeyFailed],
                },
                message: 'Sign and upload public key success',
            };
        }
        catch (error) {
            return { code: -1, message: error.message, statusCode: error?.status || NORMAL_ERROR_CODE };
        }
    }
};
OffChainAuth = __decorate([
    injectable()
], OffChainAuth);

const getListUserPaymentAccountMetaInfo = (endpoint, params) => {
    const path = '/';
    const queryMap = {
        'user-payments': 'null',
    };
    const query = getSortQuery(queryMap);
    let url = new URL(path, endpoint);
    url = getSortQueryParams(url, queryMap);
    const reqMeta = {
        contentSHA256: EMPTY_STRING_SHA256,
        method: METHOD_GET,
        url: {
            hostname: new URL(url).hostname,
            query,
            path,
        },
        userAddress: params.account,
    };
    const optionsWithOutHeaders = {
        method: METHOD_GET,
    };
    return {
        url: url.href,
        optionsWithOutHeaders,
        reqMeta,
    };
};
const parseListUserPaymentAccountResponse = (data) => {
    const xmlParser = new XMLParser({
        parseTagValue: false,
    });
    const res = xmlParser.parse(data);
    let StreamRecords = res.GfSpListUserPaymentAccountsResponse.StreamRecords || [];
    if (StreamRecords) {
        if (!Array.isArray(StreamRecords)) {
            StreamRecords = [StreamRecords];
        }
    }
    res.GfSpListUserPaymentAccountsResponse.StreamRecords = StreamRecords;
    return res;
};

let Payment = class Payment {
    constructor(txClient, sp) {
        this.txClient = txClient;
        this.sp = sp;
        this.spClient = container.resolve(SpClient);
        this.queryClient = container.resolve(RpcQueryClient);
    }
    async getStreamRecord(account) {
        const rpc = await this.queryClient.getPaymentQueryClient();
        return await rpc.StreamRecord({
            account,
        });
    }
    async getStreamRecordAll(request) {
        const rpc = await this.queryClient.getPaymentQueryClient();
        return await rpc.StreamRecords(request);
    }
    async params() {
        const rpc = await this.queryClient.getPaymentQueryClient();
        return await rpc.Params();
    }
    async paramsByTimestamp(request) {
        const rpc = await this.queryClient.getPaymentQueryClient();
        return await rpc.ParamsByTimestamp(request);
    }
    async getPaymentAccountCount(request) {
        const rpc = await this.queryClient.getPaymentQueryClient();
        return await rpc.PaymentAccountCount(request);
    }
    async getPaymentAccountCounts(request) {
        const rpc = await this.queryClient.getPaymentQueryClient();
        return await rpc.PaymentAccountCounts(request);
    }
    async paymentAccount(request) {
        const rpc = await this.queryClient.getPaymentQueryClient();
        return await rpc.PaymentAccount(request);
    }
    async paymentAccountAll(request) {
        const rpc = await this.queryClient.getPaymentQueryClient();
        return await rpc.PaymentAccounts(request);
    }
    async dynamicBalance(request) {
        const rpc = await this.queryClient.getPaymentQueryClient();
        return await rpc.DynamicBalance(request);
    }
    async getPaymentAccountsByOwner(request) {
        const rpc = await this.queryClient.getPaymentQueryClient();
        return await rpc.PaymentAccountsByOwner(request);
    }
    async getAutoSettleRecords(request) {
        const rpc = await this.queryClient.getPaymentQueryClient();
        return await rpc.AutoSettleRecords(request);
    }
    async getOutFlows(request) {
        const rpc = await this.queryClient.getPaymentQueryClient();
        return await rpc.OutFlows(request);
    }
    async deposit(msg) {
        return await this.txClient.tx(MsgDepositTypeUrl, msg.creator, MsgDepositSDKTypeEIP712, MsgDeposit.toSDK(msg), MsgDeposit.encode(msg).finish());
    }
    async withdraw(msg) {
        return await this.txClient.tx(MsgWithdrawTypeUrl, msg.creator, MsgWithdrawSDKTypeEIP712, MsgWithdraw.toSDK(msg), MsgWithdraw.encode(msg).finish());
    }
    async disableRefund(msg) {
        return await this.txClient.tx(MsgDisableRefundTypeUrl, msg.owner, MsgDisableRefundSDKTypeEIP712, MsgDisableRefund.toSDK(msg), MsgDisableRefund.encode(msg).finish());
    }
    async listUserPaymentAccounts(params, authType) {
        try {
            const sp = await this.sp.getInServiceSP();
            const { url, optionsWithOutHeaders, reqMeta } = getListUserPaymentAccountMetaInfo(sp.endpoint, params);
            const signHeaders = await this.spClient.signHeaders(reqMeta, authType);
            const result = await this.spClient.callApi(url, {
                ...optionsWithOutHeaders,
                headers: signHeaders,
            });
            const xml = await result.text();
            const res = parseListUserPaymentAccountResponse(xml);
            return {
                code: 0,
                message: 'Get bucket success.',
                statusCode: result.status,
                body: res,
            };
        }
        catch (error) {
            return {
                code: -1,
                message: error.message,
                statusCode: error?.statusCode || NORMAL_ERROR_CODE,
            };
        }
    }
};
Payment = __decorate([
    injectable(),
    __param(0, inject(delay$1(() => TxClient))),
    __param(1, inject(delay$1(() => Sp))),
    __metadata("design:paramtypes", [TxClient,
        Sp])
], Payment);

const MsgVoteSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'metadata',
            type: 'string',
        },
        {
            name: 'option',
            type: 'string',
        },
        {
            name: 'proposal_id',
            type: 'uint64',
        },
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'voter',
            type: 'string',
        },
    ],
};

let Proposal = class Proposal {
    constructor(txClient) {
        this.txClient = txClient;
    }
    async voteProposal(msg) {
        return await this.txClient.tx(MsgVoteTypeUrl, msg.voter, MsgVoteSDKTypeEIP712, {
            ...MsgVote.toSDK(msg),
            option: voteOptionToJSON(msg.option),
            proposal_id: msg.proposalId.toNumber(),
        }, MsgVote.encode(msg).finish());
    }
};
Proposal = __decorate([
    injectable(),
    __param(0, inject(delay$1(() => TxClient))),
    __metadata("design:paramtypes", [TxClient])
], Proposal);

const MsgEditValidatorSDKTypeEIP712 = {
    Msg1: [
        {
            name: 'bls_key',
            type: 'string',
        },
        {
            name: 'bls_proof',
            type: 'string',
        },
        {
            name: 'challenger_address',
            type: 'string',
        },
        {
            name: 'commission_rate',
            type: 'string',
        },
        {
            name: 'description',
            type: 'TypeMsg1Description',
        },
        {
            name: 'min_self_delegation',
            type: 'string',
        },
        {
            name: 'relayer_address',
            type: 'string',
        },
        {
            name: 'type',
            type: 'string',
        },
        {
            name: 'validator_address',
            type: 'string',
        },
    ],
    TypeMsg1Description: [
        {
            name: 'details',
            type: 'string',
        },
        {
            name: 'identity',
            type: 'string',
        },
        {
            name: 'moniker',
            type: 'string',
        },
        {
            name: 'security_contact',
            type: 'string',
        },
        {
            name: 'website',
            type: 'string',
        },
    ],
};

let Validator = class Validator {
    constructor(txClient) {
        this.txClient = txClient;
        this.queryClient = container.resolve(RpcQueryClient);
    }
    async listValidators(request) {
        const client = await this.queryClient.getStakingClient();
        return client.Validators(request);
    }
    // public async createValidator(address: string, msg: MsgCreateValidator) {
    //   return await this.txClient.tx(
    //     MsgCreateValidatorTypeUrl,
    //     address,
    //     MsgCreateValidatorSDKTypeEIP712,
    //     MsgCreateValidator.toSDK(msg),
    //     MsgCreateValidator.encode(msg).finish(),
    //   );
    // }
    async editValidator(address, msg) {
        return await this.txClient.tx(MsgEditValidatorTypeUrl, address, MsgEditValidatorSDKTypeEIP712, MsgEditValidator.toSDK(msg), MsgEditValidator.encode(msg).finish());
    }
};
Validator = __decorate([
    injectable(),
    __param(0, inject(delay$1(() => TxClient))),
    __metadata("design:paramtypes", [TxClient])
], Validator);

class Client {
    /**
     * @rpcUrl string
     * @chaidId string
     * @wasmURL optional, need setting only used for browser
     */
    static create(rpcUrl, chainId, wasmURL) {
        container.register('RPC_URL', { useValue: rpcUrl });
        container.register('CHAIN_ID', { useValue: chainId });
        container.register('ZK_CRYPTO', { useValue: wasmURL?.zkCryptoUrl });
        if (wasmURL?.zkCryptoUrl) {
            globalThis.__PUBLIC_ZKCRYPTO_WASM_PATH__ = wasmURL.zkCryptoUrl;
        }
        const account = container.resolve(Account);
        const basic = container.resolve(Basic);
        const bucket = container.resolve(Bucket);
        const challenge = container.resolve(Challenge);
        const crosschain = container.resolve(CrossChain);
        const distribution = container.resolve(Distribution);
        const feegrant = container.resolve(FeeGrant);
        const gashub = container.resolve(Gashub);
        const group = container.resolve(Group);
        const objectt = container.resolve(Objectt);
        const payment = container.resolve(Payment);
        const proposal = container.resolve(Proposal);
        const queryClient = container.resolve(RpcQueryClient);
        const sp = container.resolve(Sp);
        const spClient = container.resolve(SpClient);
        const storage = container.resolve(Storage);
        const txClient = container.resolve(TxClient);
        const offchainauth = container.resolve(OffChainAuth);
        const validator = container.resolve(Validator);
        const virtualGroup = container.resolve(VirtualGroup);
        return new Client(account, basic, bucket, challenge, crosschain, distribution, feegrant, gashub, group, objectt, payment, proposal, queryClient, sp, spClient, storage, txClient, offchainauth, validator, virtualGroup);
    }
    constructor(account, basic, bucket, challenge, crosschain, distribution, feegrant, gashub, group, object, payment, proposal, queryClient, sp, spClient, storage, txClient, offchainauth, validator, virtualGroup) {
        this.account = account;
        this.basic = basic;
        this.bucket = bucket;
        this.challenge = challenge;
        this.crosschain = crosschain;
        this.distribution = distribution;
        this.feegrant = feegrant;
        this.gashub = gashub;
        this.group = group;
        this.object = object;
        this.payment = payment;
        this.proposal = proposal;
        this.queryClient = queryClient;
        this.sp = sp;
        this.spClient = spClient;
        this.storage = storage;
        this.txClient = txClient;
        this.offchainauth = offchainauth;
        this.validator = validator;
        this.virtualGroup = virtualGroup;
    }
}

const SpMetaInfo = {
    getGetObjectMetaInfo,
    getPutObjectMetaInfo,
    getQueryBucketReadQuotaMetaInfo,
};

export { AllowedMsgAllowanceTypeUrl, BasicAllowanceTypeUrl, Client, DEFAULT_DENOM, EMPTY_STRING_SHA256, GRNToString, METHOD_GET, METHOD_POST, METHOD_PUT, MOCK_SIGNATURE, MsgAttestTypeUrl, MsgCancelCreateObjectTypeUrl, MsgClaimTypeUrl, MsgCreateBucketTypeUrl, MsgCreateGroupTypeUrl, MsgCreateObjectTypeUrl, MsgCreatePaymentAccountTypeUrl, MsgCreateValidatorTypeUrl, MsgDeleteBucketTypeUrl, MsgDeleteGroupTypeUrl, MsgDeleteObjectTypeUrl, MsgDeletePolicyTypeUrl, MsgDepositTypeUrl, MsgDisableRefundTypeUrl, MsgEditValidatorTypeUrl, MsgFundCommunityPoolTypeUrl, MsgGrantAllowanceTypeUrl, MsgLeaveGroupTypeUrl, MsgMigrateBucketTypeUrl, MsgMirrorBucketTypeUrl, MsgMirrorGroupTypeUrl, MsgMirrorObjectTypeUrl, MsgMultiSendTypeUrl, MsgPutPolicyTypeUrl, MsgRevokeAllowanceTypeUrl, MsgSendTypeUrl, MsgSetWithdrawAddressTypeUrl, MsgSettleTypeUrl, MsgSubmitTypeUrl, MsgTransferOutTypeUrl, MsgUpdateBucketInfoTypeUrl, MsgUpdateGroupExtraTypeUrl, MsgUpdateGroupMemberTypeUrl, MsgUpdateObjectInfoTypeUrl, MsgVoteTypeUrl, MsgWithdrawDelegatorRewardTypeUrl, MsgWithdrawTypeUrl, MsgWithdrawValidatorCommissionTypeUrl, NORMAL_ERROR_CODE, SpMetaInfo, ZERO_PUBKEY, convertTimeStampToDate, createEIP712, decodeFromHex, decodeObjectFromHexString, eip712Hash, encodeObjectToHexString, encodeToHex, encodeToHexString, generateFee, generateMessage, generateMsg, generateTypes, generateUrlByBucketName, getGasFeeBySimulate, getUtcZeroTimestamp, isValidAddress, isValidBucketName, isValidObjectName, isValidUrl, makeCosmsPubKey, mergeMultiEip712, mergeMultiMessage, newAllowedMsgAllowance, newBasicAllowance, newBucketGRN, newGroupGRN, newMarshal, newMsgGrantAllowance, newObjectGRN, recoverPk, sign712Tx, trimString, typeWrapper };
