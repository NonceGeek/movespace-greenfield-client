/// <reference types="long" />
import { VisibilityType, SourceType, BucketStatus, ObjectStatus, RedundancyType } from "./common";
import { Timestamp, TimestampSDKType } from "../../google/protobuf/timestamp";
import { DeleteInfo, DeleteInfoSDKType } from "./types";
import { Long } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.storage";
/** EventCreateBucket is emitted on MsgCreateBucket */
export interface EventCreateBucket {
    /** owner define the account address of bucket owner */
    owner: string;
    /** bucket_name is a globally unique name of bucket */
    bucketName: string;
    /** visibility defines the highest permissions for bucket. When a bucket is public, everyone can get the object under it. */
    visibility: VisibilityType;
    /** create_at define the block timestamp when the bucket has been created */
    createAt: Long;
    /** bucket_id is the unique u256 for bucket. Not global, only unique in buckets. */
    bucketId: string;
    /** source_type define the source of the bucket. CrossChain or Greenfield origin */
    sourceType: SourceType;
    /** read_quota defines the charged traffic quota for read, not include free quota which provided by each storage provider */
    chargedReadQuota: Long;
    /** payment_address is the address of the payment account */
    paymentAddress: string;
    /** primary_sp_id is the unique id of primary sp. */
    primarySpId: number;
    /** global_virtual_group_family_id defines the unique id of gvg family */
    globalVirtualGroupFamilyId: number;
    /** status define the status of the bucket. */
    status: BucketStatus;
}
/** EventCreateBucket is emitted on MsgCreateBucket */
export interface EventCreateBucketSDKType {
    owner: string;
    bucket_name: string;
    visibility: VisibilityType;
    create_at: Long;
    bucket_id: string;
    source_type: SourceType;
    charged_read_quota: Long;
    payment_address: string;
    primary_sp_id: number;
    global_virtual_group_family_id: number;
    status: BucketStatus;
}
/** EventDeleteBucket is emitted on MsgDeleteBucket */
export interface EventDeleteBucket {
    /** operator define the account address of operator who delete the bucket */
    operator: string;
    /** owner define the account address of the bucket owner */
    owner: string;
    /** bucket_name define the name of the deleted bucket */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
    /** global_virtual_group_family_id defines the unique id of gvg family */
    globalVirtualGroupFamilyId: number;
}
/** EventDeleteBucket is emitted on MsgDeleteBucket */
export interface EventDeleteBucketSDKType {
    operator: string;
    owner: string;
    bucket_name: string;
    bucket_id: string;
    global_virtual_group_family_id: number;
}
/** EventUpdateBucketInfo is emitted on MsgUpdateBucketInfo */
export interface EventUpdateBucketInfo {
    /** operator define the account address of operator who update the bucket */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
    /** charged_read_quota_after define the read quota after updated */
    chargedReadQuota: Long;
    /** payment_address define the payment address after updated */
    paymentAddress: string;
    /** visibility defines the highest permission of object. */
    visibility: VisibilityType;
    /** global_virtual_group_family_id defines the gvg family id after migrated. */
    globalVirtualGroupFamilyId: number;
}
/** EventUpdateBucketInfo is emitted on MsgUpdateBucketInfo */
export interface EventUpdateBucketInfoSDKType {
    operator: string;
    bucket_name: string;
    bucket_id: string;
    charged_read_quota: Long;
    payment_address: string;
    visibility: VisibilityType;
    global_virtual_group_family_id: number;
}
/** EventDiscontinueBucket is emitted on MsgDiscontinueBucket */
export interface EventDiscontinueBucket {
    /** bucket_id define id of the bucket */
    bucketId: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** the reason */
    reason: string;
    /** the timestamp after which the metadata will be deleted */
    deleteAt: Long;
}
/** EventDiscontinueBucket is emitted on MsgDiscontinueBucket */
export interface EventDiscontinueBucketSDKType {
    bucket_id: string;
    bucket_name: string;
    reason: string;
    delete_at: Long;
}
/** EventCreateObject is emitted on MsgCreateObject */
export interface EventCreateObject {
    /** creator define the account address of msg creator */
    creator: string;
    /** owner define the account address of object owner */
    owner: string;
    /** bucket_name define the name of bucket */
    bucketName: string;
    /** object_name define the name of object */
    objectName: string;
    /** bucket_id define an u256 id for object */
    bucketId: string;
    /** object_id define an u256 id for object */
    objectId: string;
    /** primary_sp_id define the unique id of primary sp */
    primarySpId: number;
    /** payload_size define the size of payload data which you want upload */
    payloadSize: Long;
    /** visibility defines the highest permission of object. */
    visibility: VisibilityType;
    /** content_type define the content type of the payload data */
    contentType: string;
    /** create_at define the block timestamp when the object created */
    createAt: Long;
    /** status define the status of the object. INIT or IN_SERVICE or others */
    status: ObjectStatus;
    /** redundancy_type define the type of redundancy. Replication or EC */
    redundancyType: RedundancyType;
    /** source_type define the source of the object.  CrossChain or Greenfield origin */
    sourceType: SourceType;
    /** checksums define the total checksums of the object which generated by redundancy */
    checksums: Uint8Array[];
}
/** EventCreateObject is emitted on MsgCreateObject */
export interface EventCreateObjectSDKType {
    creator: string;
    owner: string;
    bucket_name: string;
    object_name: string;
    bucket_id: string;
    object_id: string;
    primary_sp_id: number;
    payload_size: Long;
    visibility: VisibilityType;
    content_type: string;
    create_at: Long;
    status: ObjectStatus;
    redundancy_type: RedundancyType;
    source_type: SourceType;
    checksums: Uint8Array[];
}
/** EventCancelCreateObject is emitted on MsgCancelCreateObject */
export interface EventCancelCreateObject {
    /** operator define the account address of operator who cancel create object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** primary_sp_id define the unique id of primary sp */
    primarySpId: number;
    /** id define an u256 id for object */
    objectId: string;
}
/** EventCancelCreateObject is emitted on MsgCancelCreateObject */
export interface EventCancelCreateObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    primary_sp_id: number;
    object_id: string;
}
/** EventSealObject is emitted on MsgSealObject */
export interface EventSealObject {
    /** operator define the account address of operator who seal object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** id define an u256 id for object */
    objectId: string;
    /** status define the status of the object. INIT or IN_SERVICE or others */
    status: ObjectStatus;
    /** global_virtual_group_id defines the unique id of gvg which the object stored */
    globalVirtualGroupId: number;
    /** local_virtual_group_id defines the unique id of lvg which the object stored */
    localVirtualGroupId: number;
}
/** EventSealObject is emitted on MsgSealObject */
export interface EventSealObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
    status: ObjectStatus;
    global_virtual_group_id: number;
    local_virtual_group_id: number;
}
/** EventCopyObject is emitted on MsgCopyObject */
export interface EventCopyObject {
    /** operator define the account address of operator who copy the object */
    operator: string;
    /** src_bucket_name define the name of the src bucket */
    srcBucketName: string;
    /** src_object_name define the name of the src object */
    srcObjectName: string;
    /** dst_bucket_name define the name of the dst bucket */
    dstBucketName: string;
    /** dst_object_name define the name of the dst object */
    dstObjectName: string;
    /** src_object_id define the u256 id for src object */
    srcObjectId: string;
    /** dst_object_id define the u256 id for dst object */
    dstObjectId: string;
}
/** EventCopyObject is emitted on MsgCopyObject */
export interface EventCopyObjectSDKType {
    operator: string;
    src_bucket_name: string;
    src_object_name: string;
    dst_bucket_name: string;
    dst_object_name: string;
    src_object_id: string;
    dst_object_id: string;
}
/** EventDeleteObject is emitted on MsgDeleteObject */
export interface EventDeleteObject {
    /** operator define the account address of operator who delete the object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** id define an u256 id for object */
    objectId: string;
    /** local_virtual_group_id defines the unique id of lvg which the object stored */
    localVirtualGroupId: number;
}
/** EventDeleteObject is emitted on MsgDeleteObject */
export interface EventDeleteObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
    local_virtual_group_id: number;
}
/** EventRejectSealObject is emitted on MsgRejectSealObject */
export interface EventRejectSealObject {
    /** operator define the account address of operator who reject seal object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** id define an u256 id for object */
    objectId: string;
}
/** EventRejectSealObject is emitted on MsgRejectSealObject */
export interface EventRejectSealObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
}
/** EventDiscontinueObject is emitted on MsgDiscontinueObject */
export interface EventDiscontinueObject {
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_id defines id of the object */
    objectId: string;
    /** the reason */
    reason: string;
    /** the timestamp after which the metadata will be deleted */
    deleteAt: Long;
}
/** EventDiscontinueObject is emitted on MsgDiscontinueObject */
export interface EventDiscontinueObjectSDKType {
    bucket_name: string;
    object_id: string;
    reason: string;
    delete_at: Long;
}
/** EventUpdateObjectInfo is emitted on MsgUpdateObjectInfo */
export interface EventUpdateObjectInfo {
    /** operator define the account address of operator who update the bucket */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** object_id define an u256 id for object */
    objectId: string;
    /** visibility defines the highest permission of object. */
    visibility: VisibilityType;
}
/** EventUpdateObjectInfo is emitted on MsgUpdateObjectInfo */
export interface EventUpdateObjectInfoSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
    visibility: VisibilityType;
}
/** EventCreateGroup is emitted on MsgCreateGroup */
export interface EventCreateGroup {
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
    /** source_type define the source of the group. CrossChain or Greenfield origin */
    sourceType: SourceType;
    /** extra defines extra info for the group */
    extra: string;
}
/** EventCreateGroup is emitted on MsgCreateGroup */
export interface EventCreateGroupSDKType {
    owner: string;
    group_name: string;
    group_id: string;
    source_type: SourceType;
    extra: string;
}
/** EventDeleteGroup is emitted on MsgDeleteGroup */
export interface EventDeleteGroup {
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
}
/** EventDeleteGroup is emitted on MsgDeleteGroup */
export interface EventDeleteGroupSDKType {
    owner: string;
    group_name: string;
    group_id: string;
}
/** EventLeaveGroup is emitted on MsgLeaveGroup */
export interface EventLeaveGroup {
    /** member_address define the address of the member who leave the group */
    memberAddress: string;
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
}
/** EventLeaveGroup is emitted on MsgLeaveGroup */
export interface EventLeaveGroupSDKType {
    member_address: string;
    owner: string;
    group_name: string;
    group_id: string;
}
/** EventUpdateGroupMember is emitted on MsgUpdateGroupMember */
export interface EventUpdateGroupMember {
    /** operator define the account address of operator who update the group member */
    operator: string;
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
    /** members_to_add defines all the members to be added to the group */
    membersToAdd: EventGroupMemberDetail[];
    /** members_to_add defines all the members to be deleted from the group */
    membersToDelete: string[];
}
/** EventUpdateGroupMember is emitted on MsgUpdateGroupMember */
export interface EventUpdateGroupMemberSDKType {
    operator: string;
    owner: string;
    group_name: string;
    group_id: string;
    members_to_add: EventGroupMemberDetailSDKType[];
    members_to_delete: string[];
}
export interface EventRenewGroupMember {
    /** operator define the account address of operator who update the group member */
    operator: string;
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
    /** source_type define the source of the group. CrossChain or Greenfield origin */
    sourceType: SourceType;
    /** members define the all the address of the members. */
    members: EventGroupMemberDetail[];
}
export interface EventRenewGroupMemberSDKType {
    operator: string;
    owner: string;
    group_name: string;
    group_id: string;
    source_type: SourceType;
    members: EventGroupMemberDetailSDKType[];
}
export interface EventGroupMemberDetail {
    /** member defines the account address of the group member */
    member: string;
    /** expiration_time defines the expiration time of the group member */
    expirationTime: Timestamp;
}
export interface EventGroupMemberDetailSDKType {
    member: string;
    expiration_time: TimestampSDKType;
}
/** EventUpdateGroupExtra is emitted on MsgUpdateGroupExtra */
export interface EventUpdateGroupExtra {
    /** operator define the account address of operator who update the group member */
    operator: string;
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
    /** extra defines extra info for the group to update */
    extra: string;
}
/** EventUpdateGroupExtra is emitted on MsgUpdateGroupExtra */
export interface EventUpdateGroupExtraSDKType {
    operator: string;
    owner: string;
    group_name: string;
    group_id: string;
    extra: string;
}
/** EventMirrorBucket is emitted on MirrorBucket */
export interface EventMirrorBucket {
    /** operator define the account address of operator who mirror the bucket */
    operator: string;
    /** bucket_name defines the name of the bucket */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
    /** chain id of the destination chain */
    destChainId: number;
}
/** EventMirrorBucket is emitted on MirrorBucket */
export interface EventMirrorBucketSDKType {
    operator: string;
    bucket_name: string;
    bucket_id: string;
    dest_chain_id: number;
}
/** EventMirrorBucketResult is emitted on receiving ack package from destination chain */
export interface EventMirrorBucketResult {
    /** status define the status of the result */
    status: number;
    /** bucket_name defines the name of the bucket */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
    /** chain id of the destination chain */
    destChainId: number;
}
/** EventMirrorBucketResult is emitted on receiving ack package from destination chain */
export interface EventMirrorBucketResultSDKType {
    status: number;
    bucket_name: string;
    bucket_id: string;
    dest_chain_id: number;
}
/** EventMirrorObject is emitted on MirrorObject */
export interface EventMirrorObject {
    /** operator define the account address of operator who delete the object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** object_id define an u256 id for object */
    objectId: string;
    /** chain id of the destination chain */
    destChainId: number;
}
/** EventMirrorObject is emitted on MirrorObject */
export interface EventMirrorObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
    dest_chain_id: number;
}
/** EventMirrorObjectResult is emitted on receiving ack package from destination chain */
export interface EventMirrorObjectResult {
    /** status define the status of the result */
    status: number;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** object_id define an u256 id for object */
    objectId: string;
    /** chain id of the destination chain */
    destChainId: number;
}
/** EventMirrorObjectResult is emitted on receiving ack package from destination chain */
export interface EventMirrorObjectResultSDKType {
    status: number;
    bucket_name: string;
    object_name: string;
    object_id: string;
    dest_chain_id: number;
}
/** EventMirrorGroup is emitted on MirrorGroup */
export interface EventMirrorGroup {
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** group_id define an u256 id for group */
    groupId: string;
    /** chain id of the destination chain */
    destChainId: number;
}
/** EventMirrorGroup is emitted on MirrorGroup */
export interface EventMirrorGroupSDKType {
    owner: string;
    group_name: string;
    group_id: string;
    dest_chain_id: number;
}
/** EventMirrorGroupResult is emitted on receiving ack package from destination chain */
export interface EventMirrorGroupResult {
    /** status define the status of the result */
    status: number;
    /** group_name define the name of the group */
    groupName: string;
    /** group_id define an u256 id for group */
    groupId: string;
    /** chain id of the destination chain */
    destChainId: number;
}
/** EventMirrorGroupResult is emitted on receiving ack package from destination chain */
export interface EventMirrorGroupResultSDKType {
    status: number;
    group_name: string;
    group_id: string;
    dest_chain_id: number;
}
/** EventStalePolicyCleanup is emitted when specified block height's stale policies need to be Garbage collected */
export interface EventStalePolicyCleanup {
    blockNum: Long;
    deleteInfo: DeleteInfo;
}
/** EventStalePolicyCleanup is emitted when specified block height's stale policies need to be Garbage collected */
export interface EventStalePolicyCleanupSDKType {
    blockNum: Long;
    delete_info: DeleteInfoSDKType;
}
export interface EventMigrationBucket {
    /**
     * The address of the operator that initiated the bucket migration,
     * usually the owner of the bucket or another account which has permission to operate
     */
    operator: string;
    /** The name of the bucket to be migrated */
    bucketName: string;
    /** bucket_id define an u256 id for object */
    bucketId: string;
    /** The id of the destination primary sp */
    dstPrimarySpId: number;
}
export interface EventMigrationBucketSDKType {
    operator: string;
    bucket_name: string;
    bucket_id: string;
    dst_primary_sp_id: number;
}
export interface EventCancelMigrationBucket {
    /**
     * The address of the operator that canceled the bucket migration,
     * usually the owner of the bucket or another account which has permission to operate
     */
    operator: string;
    /** The name of the bucket to be migrated */
    bucketName: string;
    /** bucket_id define an u256 id for object */
    bucketId: string;
}
export interface EventCancelMigrationBucketSDKType {
    operator: string;
    bucket_name: string;
    bucket_id: string;
}
export interface EventCompleteMigrationBucket {
    /**
     * The address of the operator that initiated the bucket migration,
     * usually the owner of the bucket or another account which has permission to operate
     */
    operator: string;
    /** The name of the bucket to be migrated */
    bucketName: string;
    /** bucket_id define an u256 id for object */
    bucketId: string;
    /** The family id that the bucket to be migrated to */
    globalVirtualGroupFamilyId: number;
    /** The src_primary_sp_id defines the primary sp id of the bucket before migrate. */
    srcPrimarySpId: number;
}
export interface EventCompleteMigrationBucketSDKType {
    operator: string;
    bucket_name: string;
    bucket_id: string;
    global_virtual_group_family_id: number;
    src_primary_sp_id: number;
}
export declare const EventCreateBucket: {
    encode(message: EventCreateBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateBucket;
    fromJSON(object: any): EventCreateBucket;
    toJSON(message: EventCreateBucket): unknown;
    fromPartial<I extends {
        owner?: string;
        bucketName?: string;
        visibility?: VisibilityType;
        createAt?: string | number | Long.Long;
        bucketId?: string;
        sourceType?: SourceType;
        chargedReadQuota?: string | number | Long.Long;
        paymentAddress?: string;
        primarySpId?: number;
        globalVirtualGroupFamilyId?: number;
        status?: BucketStatus;
    } & {
        owner?: string;
        bucketName?: string;
        visibility?: VisibilityType;
        createAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["createAt"], keyof Long.Long>, never>);
        bucketId?: string;
        sourceType?: SourceType;
        chargedReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["chargedReadQuota"], keyof Long.Long>, never>);
        paymentAddress?: string;
        primarySpId?: number;
        globalVirtualGroupFamilyId?: number;
        status?: BucketStatus;
    } & Record<Exclude<keyof I, keyof EventCreateBucket>, never>>(object: I): EventCreateBucket;
    fromSDK(object: EventCreateBucketSDKType): EventCreateBucket;
    toSDK(message: EventCreateBucket): EventCreateBucketSDKType;
};
export declare const EventDeleteBucket: {
    encode(message: EventDeleteBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteBucket;
    fromJSON(object: any): EventDeleteBucket;
    toJSON(message: EventDeleteBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        owner?: string;
        bucketName?: string;
        bucketId?: string;
        globalVirtualGroupFamilyId?: number;
    } & {
        operator?: string;
        owner?: string;
        bucketName?: string;
        bucketId?: string;
        globalVirtualGroupFamilyId?: number;
    } & Record<Exclude<keyof I, keyof EventDeleteBucket>, never>>(object: I): EventDeleteBucket;
    fromSDK(object: EventDeleteBucketSDKType): EventDeleteBucket;
    toSDK(message: EventDeleteBucket): EventDeleteBucketSDKType;
};
export declare const EventUpdateBucketInfo: {
    encode(message: EventUpdateBucketInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateBucketInfo;
    fromJSON(object: any): EventUpdateBucketInfo;
    toJSON(message: EventUpdateBucketInfo): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        chargedReadQuota?: string | number | Long.Long;
        paymentAddress?: string;
        visibility?: VisibilityType;
        globalVirtualGroupFamilyId?: number;
    } & {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        chargedReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["chargedReadQuota"], keyof Long.Long>, never>);
        paymentAddress?: string;
        visibility?: VisibilityType;
        globalVirtualGroupFamilyId?: number;
    } & Record<Exclude<keyof I, keyof EventUpdateBucketInfo>, never>>(object: I): EventUpdateBucketInfo;
    fromSDK(object: EventUpdateBucketInfoSDKType): EventUpdateBucketInfo;
    toSDK(message: EventUpdateBucketInfo): EventUpdateBucketInfoSDKType;
};
export declare const EventDiscontinueBucket: {
    encode(message: EventDiscontinueBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDiscontinueBucket;
    fromJSON(object: any): EventDiscontinueBucket;
    toJSON(message: EventDiscontinueBucket): unknown;
    fromPartial<I extends {
        bucketId?: string;
        bucketName?: string;
        reason?: string;
        deleteAt?: string | number | Long.Long;
    } & {
        bucketId?: string;
        bucketName?: string;
        reason?: string;
        deleteAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["deleteAt"], keyof Long.Long>, never>);
    } & Record<Exclude<keyof I, keyof EventDiscontinueBucket>, never>>(object: I): EventDiscontinueBucket;
    fromSDK(object: EventDiscontinueBucketSDKType): EventDiscontinueBucket;
    toSDK(message: EventDiscontinueBucket): EventDiscontinueBucketSDKType;
};
export declare const EventCreateObject: {
    encode(message: EventCreateObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateObject;
    fromJSON(object: any): EventCreateObject;
    toJSON(message: EventCreateObject): unknown;
    fromPartial<I extends {
        creator?: string;
        owner?: string;
        bucketName?: string;
        objectName?: string;
        bucketId?: string;
        objectId?: string;
        primarySpId?: number;
        payloadSize?: string | number | Long.Long;
        visibility?: VisibilityType;
        contentType?: string;
        createAt?: string | number | Long.Long;
        status?: ObjectStatus;
        redundancyType?: RedundancyType;
        sourceType?: SourceType;
        checksums?: Uint8Array[];
    } & {
        creator?: string;
        owner?: string;
        bucketName?: string;
        objectName?: string;
        bucketId?: string;
        objectId?: string;
        primarySpId?: number;
        payloadSize?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["payloadSize"], keyof Long.Long>, never>);
        visibility?: VisibilityType;
        contentType?: string;
        createAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["createAt"], keyof Long.Long>, never>);
        status?: ObjectStatus;
        redundancyType?: RedundancyType;
        sourceType?: SourceType;
        checksums?: Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["checksums"], keyof Uint8Array[]>, never>;
    } & Record<Exclude<keyof I, keyof EventCreateObject>, never>>(object: I): EventCreateObject;
    fromSDK(object: EventCreateObjectSDKType): EventCreateObject;
    toSDK(message: EventCreateObject): EventCreateObjectSDKType;
};
export declare const EventCancelCreateObject: {
    encode(message: EventCancelCreateObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCancelCreateObject;
    fromJSON(object: any): EventCancelCreateObject;
    toJSON(message: EventCancelCreateObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        primarySpId?: number;
        objectId?: string;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        primarySpId?: number;
        objectId?: string;
    } & Record<Exclude<keyof I, keyof EventCancelCreateObject>, never>>(object: I): EventCancelCreateObject;
    fromSDK(object: EventCancelCreateObjectSDKType): EventCancelCreateObject;
    toSDK(message: EventCancelCreateObject): EventCancelCreateObjectSDKType;
};
export declare const EventSealObject: {
    encode(message: EventSealObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventSealObject;
    fromJSON(object: any): EventSealObject;
    toJSON(message: EventSealObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        status?: ObjectStatus;
        globalVirtualGroupId?: number;
        localVirtualGroupId?: number;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        status?: ObjectStatus;
        globalVirtualGroupId?: number;
        localVirtualGroupId?: number;
    } & Record<Exclude<keyof I, keyof EventSealObject>, never>>(object: I): EventSealObject;
    fromSDK(object: EventSealObjectSDKType): EventSealObject;
    toSDK(message: EventSealObject): EventSealObjectSDKType;
};
export declare const EventCopyObject: {
    encode(message: EventCopyObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCopyObject;
    fromJSON(object: any): EventCopyObject;
    toJSON(message: EventCopyObject): unknown;
    fromPartial<I extends {
        operator?: string;
        srcBucketName?: string;
        srcObjectName?: string;
        dstBucketName?: string;
        dstObjectName?: string;
        srcObjectId?: string;
        dstObjectId?: string;
    } & {
        operator?: string;
        srcBucketName?: string;
        srcObjectName?: string;
        dstBucketName?: string;
        dstObjectName?: string;
        srcObjectId?: string;
        dstObjectId?: string;
    } & Record<Exclude<keyof I, keyof EventCopyObject>, never>>(object: I): EventCopyObject;
    fromSDK(object: EventCopyObjectSDKType): EventCopyObject;
    toSDK(message: EventCopyObject): EventCopyObjectSDKType;
};
export declare const EventDeleteObject: {
    encode(message: EventDeleteObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteObject;
    fromJSON(object: any): EventDeleteObject;
    toJSON(message: EventDeleteObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        localVirtualGroupId?: number;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        localVirtualGroupId?: number;
    } & Record<Exclude<keyof I, keyof EventDeleteObject>, never>>(object: I): EventDeleteObject;
    fromSDK(object: EventDeleteObjectSDKType): EventDeleteObject;
    toSDK(message: EventDeleteObject): EventDeleteObjectSDKType;
};
export declare const EventRejectSealObject: {
    encode(message: EventRejectSealObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventRejectSealObject;
    fromJSON(object: any): EventRejectSealObject;
    toJSON(message: EventRejectSealObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
    } & Record<Exclude<keyof I, keyof EventRejectSealObject>, never>>(object: I): EventRejectSealObject;
    fromSDK(object: EventRejectSealObjectSDKType): EventRejectSealObject;
    toSDK(message: EventRejectSealObject): EventRejectSealObjectSDKType;
};
export declare const EventDiscontinueObject: {
    encode(message: EventDiscontinueObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDiscontinueObject;
    fromJSON(object: any): EventDiscontinueObject;
    toJSON(message: EventDiscontinueObject): unknown;
    fromPartial<I extends {
        bucketName?: string;
        objectId?: string;
        reason?: string;
        deleteAt?: string | number | Long.Long;
    } & {
        bucketName?: string;
        objectId?: string;
        reason?: string;
        deleteAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["deleteAt"], keyof Long.Long>, never>);
    } & Record<Exclude<keyof I, keyof EventDiscontinueObject>, never>>(object: I): EventDiscontinueObject;
    fromSDK(object: EventDiscontinueObjectSDKType): EventDiscontinueObject;
    toSDK(message: EventDiscontinueObject): EventDiscontinueObjectSDKType;
};
export declare const EventUpdateObjectInfo: {
    encode(message: EventUpdateObjectInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateObjectInfo;
    fromJSON(object: any): EventUpdateObjectInfo;
    toJSON(message: EventUpdateObjectInfo): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        visibility?: VisibilityType;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        visibility?: VisibilityType;
    } & Record<Exclude<keyof I, keyof EventUpdateObjectInfo>, never>>(object: I): EventUpdateObjectInfo;
    fromSDK(object: EventUpdateObjectInfoSDKType): EventUpdateObjectInfo;
    toSDK(message: EventUpdateObjectInfo): EventUpdateObjectInfoSDKType;
};
export declare const EventCreateGroup: {
    encode(message: EventCreateGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateGroup;
    fromJSON(object: any): EventCreateGroup;
    toJSON(message: EventCreateGroup): unknown;
    fromPartial<I extends {
        owner?: string;
        groupName?: string;
        groupId?: string;
        sourceType?: SourceType;
        extra?: string;
    } & {
        owner?: string;
        groupName?: string;
        groupId?: string;
        sourceType?: SourceType;
        extra?: string;
    } & Record<Exclude<keyof I, keyof EventCreateGroup>, never>>(object: I): EventCreateGroup;
    fromSDK(object: EventCreateGroupSDKType): EventCreateGroup;
    toSDK(message: EventCreateGroup): EventCreateGroupSDKType;
};
export declare const EventDeleteGroup: {
    encode(message: EventDeleteGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteGroup;
    fromJSON(object: any): EventDeleteGroup;
    toJSON(message: EventDeleteGroup): unknown;
    fromPartial<I extends {
        owner?: string;
        groupName?: string;
        groupId?: string;
    } & {
        owner?: string;
        groupName?: string;
        groupId?: string;
    } & Record<Exclude<keyof I, keyof EventDeleteGroup>, never>>(object: I): EventDeleteGroup;
    fromSDK(object: EventDeleteGroupSDKType): EventDeleteGroup;
    toSDK(message: EventDeleteGroup): EventDeleteGroupSDKType;
};
export declare const EventLeaveGroup: {
    encode(message: EventLeaveGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventLeaveGroup;
    fromJSON(object: any): EventLeaveGroup;
    toJSON(message: EventLeaveGroup): unknown;
    fromPartial<I extends {
        memberAddress?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
    } & {
        memberAddress?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
    } & Record<Exclude<keyof I, keyof EventLeaveGroup>, never>>(object: I): EventLeaveGroup;
    fromSDK(object: EventLeaveGroupSDKType): EventLeaveGroup;
    toSDK(message: EventLeaveGroup): EventLeaveGroupSDKType;
};
export declare const EventUpdateGroupMember: {
    encode(message: EventUpdateGroupMember, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateGroupMember;
    fromJSON(object: any): EventUpdateGroupMember;
    toJSON(message: EventUpdateGroupMember): unknown;
    fromPartial<I extends {
        operator?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
        membersToAdd?: {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[];
        membersToDelete?: string[];
    } & {
        operator?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
        membersToAdd?: {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[] & ({
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        } & {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["membersToAdd"][number]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["membersToAdd"][number]["expirationTime"], keyof Timestamp>, never>;
        } & Record<Exclude<keyof I["membersToAdd"][number], keyof EventGroupMemberDetail>, never>)[] & Record<Exclude<keyof I["membersToAdd"], keyof {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[]>, never>;
        membersToDelete?: string[] & string[] & Record<Exclude<keyof I["membersToDelete"], keyof string[]>, never>;
    } & Record<Exclude<keyof I, keyof EventUpdateGroupMember>, never>>(object: I): EventUpdateGroupMember;
    fromSDK(object: EventUpdateGroupMemberSDKType): EventUpdateGroupMember;
    toSDK(message: EventUpdateGroupMember): EventUpdateGroupMemberSDKType;
};
export declare const EventRenewGroupMember: {
    encode(message: EventRenewGroupMember, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventRenewGroupMember;
    fromJSON(object: any): EventRenewGroupMember;
    toJSON(message: EventRenewGroupMember): unknown;
    fromPartial<I extends {
        operator?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
        sourceType?: SourceType;
        members?: {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[];
    } & {
        operator?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
        sourceType?: SourceType;
        members?: {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[] & ({
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        } & {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["members"][number]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["members"][number]["expirationTime"], keyof Timestamp>, never>;
        } & Record<Exclude<keyof I["members"][number], keyof EventGroupMemberDetail>, never>)[] & Record<Exclude<keyof I["members"], keyof {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[]>, never>;
    } & Record<Exclude<keyof I, keyof EventRenewGroupMember>, never>>(object: I): EventRenewGroupMember;
    fromSDK(object: EventRenewGroupMemberSDKType): EventRenewGroupMember;
    toSDK(message: EventRenewGroupMember): EventRenewGroupMemberSDKType;
};
export declare const EventGroupMemberDetail: {
    encode(message: EventGroupMemberDetail, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventGroupMemberDetail;
    fromJSON(object: any): EventGroupMemberDetail;
    toJSON(message: EventGroupMemberDetail): unknown;
    fromPartial<I extends {
        member?: string;
        expirationTime?: {
            seconds?: string | number | Long.Long;
            nanos?: number;
        };
    } & {
        member?: string;
        expirationTime?: {
            seconds?: string | number | Long.Long;
            nanos?: number;
        } & {
            seconds?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["expirationTime"]["seconds"], keyof Long.Long>, never>);
            nanos?: number;
        } & Record<Exclude<keyof I["expirationTime"], keyof Timestamp>, never>;
    } & Record<Exclude<keyof I, keyof EventGroupMemberDetail>, never>>(object: I): EventGroupMemberDetail;
    fromSDK(object: EventGroupMemberDetailSDKType): EventGroupMemberDetail;
    toSDK(message: EventGroupMemberDetail): EventGroupMemberDetailSDKType;
};
export declare const EventUpdateGroupExtra: {
    encode(message: EventUpdateGroupExtra, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateGroupExtra;
    fromJSON(object: any): EventUpdateGroupExtra;
    toJSON(message: EventUpdateGroupExtra): unknown;
    fromPartial<I extends {
        operator?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
        extra?: string;
    } & {
        operator?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
        extra?: string;
    } & Record<Exclude<keyof I, keyof EventUpdateGroupExtra>, never>>(object: I): EventUpdateGroupExtra;
    fromSDK(object: EventUpdateGroupExtraSDKType): EventUpdateGroupExtra;
    toSDK(message: EventUpdateGroupExtra): EventUpdateGroupExtraSDKType;
};
export declare const EventMirrorBucket: {
    encode(message: EventMirrorBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorBucket;
    fromJSON(object: any): EventMirrorBucket;
    toJSON(message: EventMirrorBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        destChainId?: number;
    } & {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof EventMirrorBucket>, never>>(object: I): EventMirrorBucket;
    fromSDK(object: EventMirrorBucketSDKType): EventMirrorBucket;
    toSDK(message: EventMirrorBucket): EventMirrorBucketSDKType;
};
export declare const EventMirrorBucketResult: {
    encode(message: EventMirrorBucketResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorBucketResult;
    fromJSON(object: any): EventMirrorBucketResult;
    toJSON(message: EventMirrorBucketResult): unknown;
    fromPartial<I extends {
        status?: number;
        bucketName?: string;
        bucketId?: string;
        destChainId?: number;
    } & {
        status?: number;
        bucketName?: string;
        bucketId?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof EventMirrorBucketResult>, never>>(object: I): EventMirrorBucketResult;
    fromSDK(object: EventMirrorBucketResultSDKType): EventMirrorBucketResult;
    toSDK(message: EventMirrorBucketResult): EventMirrorBucketResultSDKType;
};
export declare const EventMirrorObject: {
    encode(message: EventMirrorObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorObject;
    fromJSON(object: any): EventMirrorObject;
    toJSON(message: EventMirrorObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        destChainId?: number;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof EventMirrorObject>, never>>(object: I): EventMirrorObject;
    fromSDK(object: EventMirrorObjectSDKType): EventMirrorObject;
    toSDK(message: EventMirrorObject): EventMirrorObjectSDKType;
};
export declare const EventMirrorObjectResult: {
    encode(message: EventMirrorObjectResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorObjectResult;
    fromJSON(object: any): EventMirrorObjectResult;
    toJSON(message: EventMirrorObjectResult): unknown;
    fromPartial<I extends {
        status?: number;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        destChainId?: number;
    } & {
        status?: number;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof EventMirrorObjectResult>, never>>(object: I): EventMirrorObjectResult;
    fromSDK(object: EventMirrorObjectResultSDKType): EventMirrorObjectResult;
    toSDK(message: EventMirrorObjectResult): EventMirrorObjectResultSDKType;
};
export declare const EventMirrorGroup: {
    encode(message: EventMirrorGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorGroup;
    fromJSON(object: any): EventMirrorGroup;
    toJSON(message: EventMirrorGroup): unknown;
    fromPartial<I extends {
        owner?: string;
        groupName?: string;
        groupId?: string;
        destChainId?: number;
    } & {
        owner?: string;
        groupName?: string;
        groupId?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof EventMirrorGroup>, never>>(object: I): EventMirrorGroup;
    fromSDK(object: EventMirrorGroupSDKType): EventMirrorGroup;
    toSDK(message: EventMirrorGroup): EventMirrorGroupSDKType;
};
export declare const EventMirrorGroupResult: {
    encode(message: EventMirrorGroupResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorGroupResult;
    fromJSON(object: any): EventMirrorGroupResult;
    toJSON(message: EventMirrorGroupResult): unknown;
    fromPartial<I extends {
        status?: number;
        groupName?: string;
        groupId?: string;
        destChainId?: number;
    } & {
        status?: number;
        groupName?: string;
        groupId?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof EventMirrorGroupResult>, never>>(object: I): EventMirrorGroupResult;
    fromSDK(object: EventMirrorGroupResultSDKType): EventMirrorGroupResult;
    toSDK(message: EventMirrorGroupResult): EventMirrorGroupResultSDKType;
};
export declare const EventStalePolicyCleanup: {
    encode(message: EventStalePolicyCleanup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventStalePolicyCleanup;
    fromJSON(object: any): EventStalePolicyCleanup;
    toJSON(message: EventStalePolicyCleanup): unknown;
    fromPartial<I extends {
        blockNum?: string | number | Long.Long;
        deleteInfo?: {
            bucketIds?: {
                id?: string[];
            };
            objectIds?: {
                id?: string[];
            };
            groupIds?: {
                id?: string[];
            };
        };
    } & {
        blockNum?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["blockNum"], keyof Long.Long>, never>);
        deleteInfo?: {
            bucketIds?: {
                id?: string[];
            };
            objectIds?: {
                id?: string[];
            };
            groupIds?: {
                id?: string[];
            };
        } & {
            bucketIds?: {
                id?: string[];
            } & {
                id?: string[] & string[] & Record<Exclude<keyof I["deleteInfo"]["bucketIds"]["id"], keyof string[]>, never>;
            } & Record<Exclude<keyof I["deleteInfo"]["bucketIds"], "id">, never>;
            objectIds?: {
                id?: string[];
            } & {
                id?: string[] & string[] & Record<Exclude<keyof I["deleteInfo"]["objectIds"]["id"], keyof string[]>, never>;
            } & Record<Exclude<keyof I["deleteInfo"]["objectIds"], "id">, never>;
            groupIds?: {
                id?: string[];
            } & {
                id?: string[] & string[] & Record<Exclude<keyof I["deleteInfo"]["groupIds"]["id"], keyof string[]>, never>;
            } & Record<Exclude<keyof I["deleteInfo"]["groupIds"], "id">, never>;
        } & Record<Exclude<keyof I["deleteInfo"], keyof DeleteInfo>, never>;
    } & Record<Exclude<keyof I, keyof EventStalePolicyCleanup>, never>>(object: I): EventStalePolicyCleanup;
    fromSDK(object: EventStalePolicyCleanupSDKType): EventStalePolicyCleanup;
    toSDK(message: EventStalePolicyCleanup): EventStalePolicyCleanupSDKType;
};
export declare const EventMigrationBucket: {
    encode(message: EventMigrationBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMigrationBucket;
    fromJSON(object: any): EventMigrationBucket;
    toJSON(message: EventMigrationBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        dstPrimarySpId?: number;
    } & {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        dstPrimarySpId?: number;
    } & Record<Exclude<keyof I, keyof EventMigrationBucket>, never>>(object: I): EventMigrationBucket;
    fromSDK(object: EventMigrationBucketSDKType): EventMigrationBucket;
    toSDK(message: EventMigrationBucket): EventMigrationBucketSDKType;
};
export declare const EventCancelMigrationBucket: {
    encode(message: EventCancelMigrationBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCancelMigrationBucket;
    fromJSON(object: any): EventCancelMigrationBucket;
    toJSON(message: EventCancelMigrationBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
    } & {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
    } & Record<Exclude<keyof I, keyof EventCancelMigrationBucket>, never>>(object: I): EventCancelMigrationBucket;
    fromSDK(object: EventCancelMigrationBucketSDKType): EventCancelMigrationBucket;
    toSDK(message: EventCancelMigrationBucket): EventCancelMigrationBucketSDKType;
};
export declare const EventCompleteMigrationBucket: {
    encode(message: EventCompleteMigrationBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCompleteMigrationBucket;
    fromJSON(object: any): EventCompleteMigrationBucket;
    toJSON(message: EventCompleteMigrationBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        globalVirtualGroupFamilyId?: number;
        srcPrimarySpId?: number;
    } & {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        globalVirtualGroupFamilyId?: number;
        srcPrimarySpId?: number;
    } & Record<Exclude<keyof I, keyof EventCompleteMigrationBucket>, never>>(object: I): EventCompleteMigrationBucket;
    fromSDK(object: EventCompleteMigrationBucketSDKType): EventCompleteMigrationBucket;
    toSDK(message: EventCompleteMigrationBucket): EventCompleteMigrationBucketSDKType;
};
