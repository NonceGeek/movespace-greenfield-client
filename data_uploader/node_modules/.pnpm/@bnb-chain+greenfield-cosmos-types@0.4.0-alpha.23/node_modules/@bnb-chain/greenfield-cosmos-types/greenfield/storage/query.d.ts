/// <reference types="long" />
import { PageRequest, PageRequestSDKType, PageResponse, PageResponseSDKType } from "../../cosmos/base/query/v1beta1/pagination";
import { ActionType, Effect } from "../permission/common";
import { Params, ParamsSDKType } from "./params";
import { BucketInfo, BucketInfoSDKType, ObjectInfo, ObjectInfoSDKType, BucketMetaData, BucketMetaDataSDKType, ObjectMetaData, ObjectMetaDataSDKType, GroupMetaData, GroupMetaDataSDKType, GroupInfo, GroupInfoSDKType, InternalBucketInfo, InternalBucketInfoSDKType } from "./types";
import { GlobalVirtualGroup, GlobalVirtualGroupSDKType } from "../virtualgroup/types";
import { Policy, PolicySDKType, GroupMember, GroupMemberSDKType } from "../permission/types";
import { Long, Rpc } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.storage";
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequestSDKType {
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
    /** params holds all the parameters of this module. */
    params: Params;
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponseSDKType {
    params: ParamsSDKType;
}
/** QueryVersionedParamsRequest is request type for the Query/Params RPC method with timestamp. */
export interface QueryParamsByTimestampRequest {
    /** the timestamp of the block time you want to query */
    timestamp: Long;
}
/** QueryVersionedParamsRequest is request type for the Query/Params RPC method with timestamp. */
export interface QueryParamsByTimestampRequestSDKType {
    timestamp: Long;
}
/** QueryVersionedParamsResponse is response type for the Query/Params RPC method with timestamp. */
export interface QueryParamsByTimestampResponse {
    /** params holds all the parameters of this module. */
    params: Params;
}
/** QueryVersionedParamsResponse is response type for the Query/Params RPC method with timestamp. */
export interface QueryParamsByTimestampResponseSDKType {
    params: ParamsSDKType;
}
export interface QueryHeadBucketRequest {
    bucketName: string;
}
export interface QueryHeadBucketRequestSDKType {
    bucket_name: string;
}
export interface QueryHeadBucketByIdRequest {
    bucketId: string;
}
export interface QueryHeadBucketByIdRequestSDKType {
    bucket_id: string;
}
export interface QueryHeadBucketResponse {
    bucketInfo: BucketInfo;
}
export interface QueryHeadBucketResponseSDKType {
    bucket_info: BucketInfoSDKType;
}
export interface QueryHeadObjectRequest {
    bucketName: string;
    objectName: string;
}
export interface QueryHeadObjectRequestSDKType {
    bucket_name: string;
    object_name: string;
}
export interface QueryHeadObjectByIdRequest {
    objectId: string;
}
export interface QueryHeadObjectByIdRequestSDKType {
    object_id: string;
}
export interface QueryHeadObjectResponse {
    objectInfo: ObjectInfo;
    globalVirtualGroup: GlobalVirtualGroup;
}
export interface QueryHeadObjectResponseSDKType {
    object_info: ObjectInfoSDKType;
    global_virtual_group: GlobalVirtualGroupSDKType;
}
export interface QueryListBucketsRequest {
    pagination: PageRequest;
}
export interface QueryListBucketsRequestSDKType {
    pagination: PageRequestSDKType;
}
export interface QueryListBucketsResponse {
    bucketInfos: BucketInfo[];
    pagination: PageResponse;
}
export interface QueryListBucketsResponseSDKType {
    bucket_infos: BucketInfoSDKType[];
    pagination: PageResponseSDKType;
}
export interface QueryListObjectsRequest {
    pagination: PageRequest;
    bucketName: string;
}
export interface QueryListObjectsRequestSDKType {
    pagination: PageRequestSDKType;
    bucket_name: string;
}
export interface QueryListObjectsByBucketIdRequest {
    pagination: PageRequest;
    bucketId: string;
}
export interface QueryListObjectsByBucketIdRequestSDKType {
    pagination: PageRequestSDKType;
    bucket_id: string;
}
export interface QueryListObjectsResponse {
    objectInfos: ObjectInfo[];
    pagination: PageResponse;
}
export interface QueryListObjectsResponseSDKType {
    object_infos: ObjectInfoSDKType[];
    pagination: PageResponseSDKType;
}
export interface QueryNFTRequest {
    tokenId: string;
}
export interface QueryNFTRequestSDKType {
    token_id: string;
}
export interface QueryBucketNFTResponse {
    metaData: BucketMetaData;
}
export interface QueryBucketNFTResponseSDKType {
    meta_data: BucketMetaDataSDKType;
}
export interface QueryObjectNFTResponse {
    metaData: ObjectMetaData;
}
export interface QueryObjectNFTResponseSDKType {
    meta_data: ObjectMetaDataSDKType;
}
export interface QueryGroupNFTResponse {
    metaData: GroupMetaData;
}
export interface QueryGroupNFTResponseSDKType {
    meta_data: GroupMetaDataSDKType;
}
export interface QueryPolicyForAccountRequest {
    resource: string;
    principalAddress: string;
}
export interface QueryPolicyForAccountRequestSDKType {
    resource: string;
    principal_address: string;
}
export interface QueryPolicyForAccountResponse {
    policy: Policy;
}
export interface QueryPolicyForAccountResponseSDKType {
    policy: PolicySDKType;
}
export interface QueryVerifyPermissionRequest {
    operator: string;
    bucketName: string;
    objectName: string;
    actionType: ActionType;
}
export interface QueryVerifyPermissionRequestSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    action_type: ActionType;
}
export interface QueryVerifyPermissionResponse {
    effect: Effect;
}
export interface QueryVerifyPermissionResponseSDKType {
    effect: Effect;
}
export interface QueryHeadGroupRequest {
    groupOwner: string;
    groupName: string;
}
export interface QueryHeadGroupRequestSDKType {
    group_owner: string;
    group_name: string;
}
export interface QueryHeadGroupResponse {
    groupInfo: GroupInfo;
}
export interface QueryHeadGroupResponseSDKType {
    group_info: GroupInfoSDKType;
}
export interface QueryListGroupsRequest {
    pagination: PageRequest;
    groupOwner: string;
}
export interface QueryListGroupsRequestSDKType {
    pagination: PageRequestSDKType;
    group_owner: string;
}
export interface QueryListGroupsResponse {
    pagination: PageResponse;
    groupInfos: GroupInfo[];
}
export interface QueryListGroupsResponseSDKType {
    pagination: PageResponseSDKType;
    group_infos: GroupInfoSDKType[];
}
export interface QueryHeadGroupMemberRequest {
    member: string;
    groupOwner: string;
    groupName: string;
}
export interface QueryHeadGroupMemberRequestSDKType {
    member: string;
    group_owner: string;
    group_name: string;
}
export interface QueryHeadGroupMemberResponse {
    groupMember: GroupMember;
}
export interface QueryHeadGroupMemberResponseSDKType {
    group_member: GroupMemberSDKType;
}
export interface QueryPolicyForGroupRequest {
    resource: string;
    principalGroupId: string;
}
export interface QueryPolicyForGroupRequestSDKType {
    resource: string;
    principal_group_id: string;
}
export interface QueryPolicyForGroupResponse {
    policy: Policy;
}
export interface QueryPolicyForGroupResponseSDKType {
    policy: PolicySDKType;
}
export interface QueryPolicyByIdRequest {
    policyId: string;
}
export interface QueryPolicyByIdRequestSDKType {
    policy_id: string;
}
export interface QueryPolicyByIdResponse {
    policy: Policy;
}
export interface QueryPolicyByIdResponseSDKType {
    policy: PolicySDKType;
}
export interface QueryLockFeeRequest {
    /** primary_sp_address is the address of the primary sp. */
    primarySpAddress: string;
    /** create_at define the block timestamp when the object created. */
    createAt: Long;
    /** payloadSize is the total size of the object payload */
    payloadSize: Long;
}
export interface QueryLockFeeRequestSDKType {
    primary_sp_address: string;
    create_at: Long;
    payload_size: Long;
}
export interface QueryLockFeeResponse {
    amount: string;
}
export interface QueryLockFeeResponseSDKType {
    amount: string;
}
export interface QueryHeadBucketExtraRequest {
    bucketName: string;
}
export interface QueryHeadBucketExtraRequestSDKType {
    bucket_name: string;
}
export interface QueryHeadBucketExtraResponse {
    extraInfo: InternalBucketInfo;
}
export interface QueryHeadBucketExtraResponseSDKType {
    extra_info: InternalBucketInfoSDKType;
}
export interface QueryIsPriceChangedRequest {
    bucketName: string;
}
export interface QueryIsPriceChangedRequestSDKType {
    bucket_name: string;
}
export interface QueryIsPriceChangedResponse {
    changed: boolean;
    currentReadPrice: string;
    currentPrimaryStorePrice: string;
    currentSecondaryStorePrice: string;
    currentValidatorTaxRate: string;
    newReadPrice: string;
    newPrimaryStorePrice: string;
    newSecondaryStorePrice: string;
    newValidatorTaxRate: string;
}
export interface QueryIsPriceChangedResponseSDKType {
    changed: boolean;
    current_read_price: string;
    current_primary_store_price: string;
    current_secondary_store_price: string;
    current_validator_tax_rate: string;
    new_read_price: string;
    new_primary_store_price: string;
    new_secondary_store_price: string;
    new_validator_tax_rate: string;
}
export interface QueryQuoteUpdateTimeRequest {
    bucketName: string;
}
export interface QueryQuoteUpdateTimeRequestSDKType {
    bucket_name: string;
}
export interface QueryQuoteUpdateTimeResponse {
    updateAt: Long;
}
export interface QueryQuoteUpdateTimeResponseSDKType {
    update_at: Long;
}
export interface QueryGroupMembersExistRequest {
    groupId: string;
    members: string[];
}
export interface QueryGroupMembersExistRequestSDKType {
    group_id: string;
    members: string[];
}
export interface QueryGroupMembersExistResponse_ExistsEntry {
    key: string;
    value: boolean;
}
export interface QueryGroupMembersExistResponse_ExistsEntrySDKType {
    key: string;
    value: boolean;
}
export interface QueryGroupMembersExistResponse {
    exists: {
        [key: string]: boolean;
    };
}
export interface QueryGroupMembersExistResponseSDKType {
    exists: {
        [key: string]: boolean;
    };
}
export interface QueryGroupsExistRequest {
    groupOwner: string;
    groupNames: string[];
}
export interface QueryGroupsExistRequestSDKType {
    group_owner: string;
    group_names: string[];
}
export interface QueryGroupsExistByIdRequest {
    groupIds: string[];
}
export interface QueryGroupsExistByIdRequestSDKType {
    group_ids: string[];
}
export interface QueryGroupsExistResponse_ExistsEntry {
    key: string;
    value: boolean;
}
export interface QueryGroupsExistResponse_ExistsEntrySDKType {
    key: string;
    value: boolean;
}
export interface QueryGroupsExistResponse {
    exists: {
        [key: string]: boolean;
    };
}
export interface QueryGroupsExistResponseSDKType {
    exists: {
        [key: string]: boolean;
    };
}
export declare const QueryParamsRequest: {
    encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
    fromJSON(_: any): QueryParamsRequest;
    toJSON(_: QueryParamsRequest): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
    fromSDK(_: QueryParamsRequestSDKType): QueryParamsRequest;
    toSDK(_: QueryParamsRequest): QueryParamsRequestSDKType;
};
export declare const QueryParamsResponse: {
    encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
    fromJSON(object: any): QueryParamsResponse;
    toJSON(message: QueryParamsResponse): unknown;
    fromPartial<I extends {
        params?: {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            };
            maxPayloadSize?: string | number | Long.Long;
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | Long.Long;
            discontinueObjectMax?: string | number | Long.Long;
            discontinueBucketMax?: string | number | Long.Long;
            discontinueConfirmPeriod?: string | number | Long.Long;
            discontinueDeletionMax?: string | number | Long.Long;
            stalePolicyCleanupMax?: string | number | Long.Long;
            minQuotaUpdateInterval?: string | number | Long.Long;
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        };
    } & {
        params?: {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            };
            maxPayloadSize?: string | number | Long.Long;
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | Long.Long;
            discontinueObjectMax?: string | number | Long.Long;
            discontinueBucketMax?: string | number | Long.Long;
            discontinueConfirmPeriod?: string | number | Long.Long;
            discontinueDeletionMax?: string | number | Long.Long;
            stalePolicyCleanupMax?: string | number | Long.Long;
            minQuotaUpdateInterval?: string | number | Long.Long;
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        } & {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            } & {
                maxSegmentSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["maxSegmentSize"], keyof Long.Long>, never>);
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["minChargeSize"], keyof Long.Long>, never>);
            } & Record<Exclude<keyof I["params"]["versionedParams"], keyof import("./params").VersionedParams>, never>;
            maxPayloadSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["maxPayloadSize"], keyof Long.Long>, never>);
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueCountingWindow"], keyof Long.Long>, never>);
            discontinueObjectMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueObjectMax"], keyof Long.Long>, never>);
            discontinueBucketMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueBucketMax"], keyof Long.Long>, never>);
            discontinueConfirmPeriod?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueConfirmPeriod"], keyof Long.Long>, never>);
            discontinueDeletionMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueDeletionMax"], keyof Long.Long>, never>);
            stalePolicyCleanupMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["stalePolicyCleanupMax"], keyof Long.Long>, never>);
            minQuotaUpdateInterval?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["minQuotaUpdateInterval"], keyof Long.Long>, never>);
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        } & Record<Exclude<keyof I["params"], keyof Params>, never>;
    } & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
    fromSDK(object: QueryParamsResponseSDKType): QueryParamsResponse;
    toSDK(message: QueryParamsResponse): QueryParamsResponseSDKType;
};
export declare const QueryParamsByTimestampRequest: {
    encode(message: QueryParamsByTimestampRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsByTimestampRequest;
    fromJSON(object: any): QueryParamsByTimestampRequest;
    toJSON(message: QueryParamsByTimestampRequest): unknown;
    fromPartial<I extends {
        timestamp?: string | number | Long.Long;
    } & {
        timestamp?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["timestamp"], keyof Long.Long>, never>);
    } & Record<Exclude<keyof I, "timestamp">, never>>(object: I): QueryParamsByTimestampRequest;
    fromSDK(object: QueryParamsByTimestampRequestSDKType): QueryParamsByTimestampRequest;
    toSDK(message: QueryParamsByTimestampRequest): QueryParamsByTimestampRequestSDKType;
};
export declare const QueryParamsByTimestampResponse: {
    encode(message: QueryParamsByTimestampResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsByTimestampResponse;
    fromJSON(object: any): QueryParamsByTimestampResponse;
    toJSON(message: QueryParamsByTimestampResponse): unknown;
    fromPartial<I extends {
        params?: {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            };
            maxPayloadSize?: string | number | Long.Long;
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | Long.Long;
            discontinueObjectMax?: string | number | Long.Long;
            discontinueBucketMax?: string | number | Long.Long;
            discontinueConfirmPeriod?: string | number | Long.Long;
            discontinueDeletionMax?: string | number | Long.Long;
            stalePolicyCleanupMax?: string | number | Long.Long;
            minQuotaUpdateInterval?: string | number | Long.Long;
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        };
    } & {
        params?: {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            };
            maxPayloadSize?: string | number | Long.Long;
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | Long.Long;
            discontinueObjectMax?: string | number | Long.Long;
            discontinueBucketMax?: string | number | Long.Long;
            discontinueConfirmPeriod?: string | number | Long.Long;
            discontinueDeletionMax?: string | number | Long.Long;
            stalePolicyCleanupMax?: string | number | Long.Long;
            minQuotaUpdateInterval?: string | number | Long.Long;
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        } & {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            } & {
                maxSegmentSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["maxSegmentSize"], keyof Long.Long>, never>);
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["minChargeSize"], keyof Long.Long>, never>);
            } & Record<Exclude<keyof I["params"]["versionedParams"], keyof import("./params").VersionedParams>, never>;
            maxPayloadSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["maxPayloadSize"], keyof Long.Long>, never>);
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueCountingWindow"], keyof Long.Long>, never>);
            discontinueObjectMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueObjectMax"], keyof Long.Long>, never>);
            discontinueBucketMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueBucketMax"], keyof Long.Long>, never>);
            discontinueConfirmPeriod?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueConfirmPeriod"], keyof Long.Long>, never>);
            discontinueDeletionMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueDeletionMax"], keyof Long.Long>, never>);
            stalePolicyCleanupMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["stalePolicyCleanupMax"], keyof Long.Long>, never>);
            minQuotaUpdateInterval?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["minQuotaUpdateInterval"], keyof Long.Long>, never>);
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        } & Record<Exclude<keyof I["params"], keyof Params>, never>;
    } & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsByTimestampResponse;
    fromSDK(object: QueryParamsByTimestampResponseSDKType): QueryParamsByTimestampResponse;
    toSDK(message: QueryParamsByTimestampResponse): QueryParamsByTimestampResponseSDKType;
};
export declare const QueryHeadBucketRequest: {
    encode(message: QueryHeadBucketRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadBucketRequest;
    fromJSON(object: any): QueryHeadBucketRequest;
    toJSON(message: QueryHeadBucketRequest): unknown;
    fromPartial<I extends {
        bucketName?: string;
    } & {
        bucketName?: string;
    } & Record<Exclude<keyof I, "bucketName">, never>>(object: I): QueryHeadBucketRequest;
    fromSDK(object: QueryHeadBucketRequestSDKType): QueryHeadBucketRequest;
    toSDK(message: QueryHeadBucketRequest): QueryHeadBucketRequestSDKType;
};
export declare const QueryHeadBucketByIdRequest: {
    encode(message: QueryHeadBucketByIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadBucketByIdRequest;
    fromJSON(object: any): QueryHeadBucketByIdRequest;
    toJSON(message: QueryHeadBucketByIdRequest): unknown;
    fromPartial<I extends {
        bucketId?: string;
    } & {
        bucketId?: string;
    } & Record<Exclude<keyof I, "bucketId">, never>>(object: I): QueryHeadBucketByIdRequest;
    fromSDK(object: QueryHeadBucketByIdRequestSDKType): QueryHeadBucketByIdRequest;
    toSDK(message: QueryHeadBucketByIdRequest): QueryHeadBucketByIdRequestSDKType;
};
export declare const QueryHeadBucketResponse: {
    encode(message: QueryHeadBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadBucketResponse;
    fromJSON(object: any): QueryHeadBucketResponse;
    toJSON(message: QueryHeadBucketResponse): unknown;
    fromPartial<I extends {
        bucketInfo?: {
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | Long.Long;
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | Long.Long;
            bucketStatus?: import("./common").BucketStatus;
        };
    } & {
        bucketInfo?: {
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | Long.Long;
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | Long.Long;
            bucketStatus?: import("./common").BucketStatus;
        } & {
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["bucketInfo"]["createAt"], keyof Long.Long>, never>);
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["bucketInfo"]["chargedReadQuota"], keyof Long.Long>, never>);
            bucketStatus?: import("./common").BucketStatus;
        } & Record<Exclude<keyof I["bucketInfo"], keyof BucketInfo>, never>;
    } & Record<Exclude<keyof I, "bucketInfo">, never>>(object: I): QueryHeadBucketResponse;
    fromSDK(object: QueryHeadBucketResponseSDKType): QueryHeadBucketResponse;
    toSDK(message: QueryHeadBucketResponse): QueryHeadBucketResponseSDKType;
};
export declare const QueryHeadObjectRequest: {
    encode(message: QueryHeadObjectRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadObjectRequest;
    fromJSON(object: any): QueryHeadObjectRequest;
    toJSON(message: QueryHeadObjectRequest): unknown;
    fromPartial<I extends {
        bucketName?: string;
        objectName?: string;
    } & {
        bucketName?: string;
        objectName?: string;
    } & Record<Exclude<keyof I, keyof QueryHeadObjectRequest>, never>>(object: I): QueryHeadObjectRequest;
    fromSDK(object: QueryHeadObjectRequestSDKType): QueryHeadObjectRequest;
    toSDK(message: QueryHeadObjectRequest): QueryHeadObjectRequestSDKType;
};
export declare const QueryHeadObjectByIdRequest: {
    encode(message: QueryHeadObjectByIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadObjectByIdRequest;
    fromJSON(object: any): QueryHeadObjectByIdRequest;
    toJSON(message: QueryHeadObjectByIdRequest): unknown;
    fromPartial<I extends {
        objectId?: string;
    } & {
        objectId?: string;
    } & Record<Exclude<keyof I, "objectId">, never>>(object: I): QueryHeadObjectByIdRequest;
    fromSDK(object: QueryHeadObjectByIdRequestSDKType): QueryHeadObjectByIdRequest;
    toSDK(message: QueryHeadObjectByIdRequest): QueryHeadObjectByIdRequestSDKType;
};
export declare const QueryHeadObjectResponse: {
    encode(message: QueryHeadObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadObjectResponse;
    fromJSON(object: any): QueryHeadObjectResponse;
    toJSON(message: QueryHeadObjectResponse): unknown;
    fromPartial<I extends {
        objectInfo?: {
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | Long.Long;
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | Long.Long;
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[];
        };
        globalVirtualGroup?: {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | Long.Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        };
    } & {
        objectInfo?: {
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | Long.Long;
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | Long.Long;
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[];
        } & {
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["objectInfo"]["payloadSize"], keyof Long.Long>, never>);
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["objectInfo"]["createAt"], keyof Long.Long>, never>);
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["objectInfo"]["checksums"], keyof Uint8Array[]>, never>;
        } & Record<Exclude<keyof I["objectInfo"], keyof ObjectInfo>, never>;
        globalVirtualGroup?: {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | Long.Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        } & {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[] & number[] & Record<Exclude<keyof I["globalVirtualGroup"]["secondarySpIds"], keyof number[]>, never>;
            storedSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["globalVirtualGroup"]["storedSize"], keyof Long.Long>, never>);
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        } & Record<Exclude<keyof I["globalVirtualGroup"], keyof GlobalVirtualGroup>, never>;
    } & Record<Exclude<keyof I, keyof QueryHeadObjectResponse>, never>>(object: I): QueryHeadObjectResponse;
    fromSDK(object: QueryHeadObjectResponseSDKType): QueryHeadObjectResponse;
    toSDK(message: QueryHeadObjectResponse): QueryHeadObjectResponseSDKType;
};
export declare const QueryListBucketsRequest: {
    encode(message: QueryListBucketsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListBucketsRequest;
    fromJSON(object: any): QueryListBucketsRequest;
    toJSON(message: QueryListBucketsRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
            limit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
    } & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryListBucketsRequest;
    fromSDK(object: QueryListBucketsRequestSDKType): QueryListBucketsRequest;
    toSDK(message: QueryListBucketsRequest): QueryListBucketsRequestSDKType;
};
export declare const QueryListBucketsResponse: {
    encode(message: QueryListBucketsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListBucketsResponse;
    fromJSON(object: any): QueryListBucketsResponse;
    toJSON(message: QueryListBucketsResponse): unknown;
    fromPartial<I extends {
        bucketInfos?: {
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | Long.Long;
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | Long.Long;
            bucketStatus?: import("./common").BucketStatus;
        }[];
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        };
    } & {
        bucketInfos?: {
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | Long.Long;
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | Long.Long;
            bucketStatus?: import("./common").BucketStatus;
        }[] & ({
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | Long.Long;
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | Long.Long;
            bucketStatus?: import("./common").BucketStatus;
        } & {
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["bucketInfos"][number]["createAt"], keyof Long.Long>, never>);
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["bucketInfos"][number]["chargedReadQuota"], keyof Long.Long>, never>);
            bucketStatus?: import("./common").BucketStatus;
        } & Record<Exclude<keyof I["bucketInfos"][number], keyof BucketInfo>, never>)[] & Record<Exclude<keyof I["bucketInfos"], keyof {
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | Long.Long;
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | Long.Long;
            bucketStatus?: import("./common").BucketStatus;
        }[]>, never>;
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
    } & Record<Exclude<keyof I, keyof QueryListBucketsResponse>, never>>(object: I): QueryListBucketsResponse;
    fromSDK(object: QueryListBucketsResponseSDKType): QueryListBucketsResponse;
    toSDK(message: QueryListBucketsResponse): QueryListBucketsResponseSDKType;
};
export declare const QueryListObjectsRequest: {
    encode(message: QueryListObjectsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListObjectsRequest;
    fromJSON(object: any): QueryListObjectsRequest;
    toJSON(message: QueryListObjectsRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
        bucketName?: string;
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
            limit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
        bucketName?: string;
    } & Record<Exclude<keyof I, keyof QueryListObjectsRequest>, never>>(object: I): QueryListObjectsRequest;
    fromSDK(object: QueryListObjectsRequestSDKType): QueryListObjectsRequest;
    toSDK(message: QueryListObjectsRequest): QueryListObjectsRequestSDKType;
};
export declare const QueryListObjectsByBucketIdRequest: {
    encode(message: QueryListObjectsByBucketIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListObjectsByBucketIdRequest;
    fromJSON(object: any): QueryListObjectsByBucketIdRequest;
    toJSON(message: QueryListObjectsByBucketIdRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
        bucketId?: string;
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
            limit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
        bucketId?: string;
    } & Record<Exclude<keyof I, keyof QueryListObjectsByBucketIdRequest>, never>>(object: I): QueryListObjectsByBucketIdRequest;
    fromSDK(object: QueryListObjectsByBucketIdRequestSDKType): QueryListObjectsByBucketIdRequest;
    toSDK(message: QueryListObjectsByBucketIdRequest): QueryListObjectsByBucketIdRequestSDKType;
};
export declare const QueryListObjectsResponse: {
    encode(message: QueryListObjectsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListObjectsResponse;
    fromJSON(object: any): QueryListObjectsResponse;
    toJSON(message: QueryListObjectsResponse): unknown;
    fromPartial<I extends {
        objectInfos?: {
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | Long.Long;
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | Long.Long;
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[];
        }[];
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        };
    } & {
        objectInfos?: {
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | Long.Long;
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | Long.Long;
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[];
        }[] & ({
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | Long.Long;
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | Long.Long;
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[];
        } & {
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["objectInfos"][number]["payloadSize"], keyof Long.Long>, never>);
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["objectInfos"][number]["createAt"], keyof Long.Long>, never>);
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["objectInfos"][number]["checksums"], keyof Uint8Array[]>, never>;
        } & Record<Exclude<keyof I["objectInfos"][number], keyof ObjectInfo>, never>)[] & Record<Exclude<keyof I["objectInfos"], keyof {
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | Long.Long;
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | Long.Long;
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[];
        }[]>, never>;
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
    } & Record<Exclude<keyof I, keyof QueryListObjectsResponse>, never>>(object: I): QueryListObjectsResponse;
    fromSDK(object: QueryListObjectsResponseSDKType): QueryListObjectsResponse;
    toSDK(message: QueryListObjectsResponse): QueryListObjectsResponseSDKType;
};
export declare const QueryNFTRequest: {
    encode(message: QueryNFTRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryNFTRequest;
    fromJSON(object: any): QueryNFTRequest;
    toJSON(message: QueryNFTRequest): unknown;
    fromPartial<I extends {
        tokenId?: string;
    } & {
        tokenId?: string;
    } & Record<Exclude<keyof I, "tokenId">, never>>(object: I): QueryNFTRequest;
    fromSDK(object: QueryNFTRequestSDKType): QueryNFTRequest;
    toSDK(message: QueryNFTRequest): QueryNFTRequestSDKType;
};
export declare const QueryBucketNFTResponse: {
    encode(message: QueryBucketNFTResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryBucketNFTResponse;
    fromJSON(object: any): QueryBucketNFTResponse;
    toJSON(message: QueryBucketNFTResponse): unknown;
    fromPartial<I extends {
        metaData?: {
            description?: string;
            externalUrl?: string;
            bucketName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[];
        };
    } & {
        metaData?: {
            description?: string;
            externalUrl?: string;
            bucketName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[];
        } & {
            description?: string;
            externalUrl?: string;
            bucketName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[] & ({
                traitType?: string;
                value?: string;
            } & {
                traitType?: string;
                value?: string;
            } & Record<Exclude<keyof I["metaData"]["attributes"][number], keyof import("./types").Trait>, never>)[] & Record<Exclude<keyof I["metaData"]["attributes"], keyof {
                traitType?: string;
                value?: string;
            }[]>, never>;
        } & Record<Exclude<keyof I["metaData"], keyof BucketMetaData>, never>;
    } & Record<Exclude<keyof I, "metaData">, never>>(object: I): QueryBucketNFTResponse;
    fromSDK(object: QueryBucketNFTResponseSDKType): QueryBucketNFTResponse;
    toSDK(message: QueryBucketNFTResponse): QueryBucketNFTResponseSDKType;
};
export declare const QueryObjectNFTResponse: {
    encode(message: QueryObjectNFTResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryObjectNFTResponse;
    fromJSON(object: any): QueryObjectNFTResponse;
    toJSON(message: QueryObjectNFTResponse): unknown;
    fromPartial<I extends {
        metaData?: {
            description?: string;
            externalUrl?: string;
            objectName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[];
        };
    } & {
        metaData?: {
            description?: string;
            externalUrl?: string;
            objectName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[];
        } & {
            description?: string;
            externalUrl?: string;
            objectName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[] & ({
                traitType?: string;
                value?: string;
            } & {
                traitType?: string;
                value?: string;
            } & Record<Exclude<keyof I["metaData"]["attributes"][number], keyof import("./types").Trait>, never>)[] & Record<Exclude<keyof I["metaData"]["attributes"], keyof {
                traitType?: string;
                value?: string;
            }[]>, never>;
        } & Record<Exclude<keyof I["metaData"], keyof ObjectMetaData>, never>;
    } & Record<Exclude<keyof I, "metaData">, never>>(object: I): QueryObjectNFTResponse;
    fromSDK(object: QueryObjectNFTResponseSDKType): QueryObjectNFTResponse;
    toSDK(message: QueryObjectNFTResponse): QueryObjectNFTResponseSDKType;
};
export declare const QueryGroupNFTResponse: {
    encode(message: QueryGroupNFTResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupNFTResponse;
    fromJSON(object: any): QueryGroupNFTResponse;
    toJSON(message: QueryGroupNFTResponse): unknown;
    fromPartial<I extends {
        metaData?: {
            description?: string;
            externalUrl?: string;
            groupName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[];
        };
    } & {
        metaData?: {
            description?: string;
            externalUrl?: string;
            groupName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[];
        } & {
            description?: string;
            externalUrl?: string;
            groupName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[] & ({
                traitType?: string;
                value?: string;
            } & {
                traitType?: string;
                value?: string;
            } & Record<Exclude<keyof I["metaData"]["attributes"][number], keyof import("./types").Trait>, never>)[] & Record<Exclude<keyof I["metaData"]["attributes"], keyof {
                traitType?: string;
                value?: string;
            }[]>, never>;
        } & Record<Exclude<keyof I["metaData"], keyof GroupMetaData>, never>;
    } & Record<Exclude<keyof I, "metaData">, never>>(object: I): QueryGroupNFTResponse;
    fromSDK(object: QueryGroupNFTResponseSDKType): QueryGroupNFTResponse;
    toSDK(message: QueryGroupNFTResponse): QueryGroupNFTResponseSDKType;
};
export declare const QueryPolicyForAccountRequest: {
    encode(message: QueryPolicyForAccountRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyForAccountRequest;
    fromJSON(object: any): QueryPolicyForAccountRequest;
    toJSON(message: QueryPolicyForAccountRequest): unknown;
    fromPartial<I extends {
        resource?: string;
        principalAddress?: string;
    } & {
        resource?: string;
        principalAddress?: string;
    } & Record<Exclude<keyof I, keyof QueryPolicyForAccountRequest>, never>>(object: I): QueryPolicyForAccountRequest;
    fromSDK(object: QueryPolicyForAccountRequestSDKType): QueryPolicyForAccountRequest;
    toSDK(message: QueryPolicyForAccountRequest): QueryPolicyForAccountRequestSDKType;
};
export declare const QueryPolicyForAccountResponse: {
    encode(message: QueryPolicyForAccountResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyForAccountResponse;
    fromJSON(object: any): QueryPolicyForAccountResponse;
    toJSON(message: QueryPolicyForAccountResponse): unknown;
    fromPartial<I extends {
        policy?: {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            };
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        };
    } & {
        policy?: {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            };
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        } & {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            } & {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            } & Record<Exclude<keyof I["policy"]["principal"], keyof import("../permission/common").Principal>, never>;
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[] & ({
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            } & {
                effect?: Effect;
                actions?: ActionType[] & ActionType[] & Record<Exclude<keyof I["policy"]["statements"][number]["actions"], keyof ActionType[]>, never>;
                resources?: string[] & string[] & Record<Exclude<keyof I["policy"]["statements"][number]["resources"], keyof string[]>, never>;
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                } & {
                    seconds?: string | number | (Long.Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | Long.Long) => Long.Long;
                        and: (other: string | number | Long.Long) => Long.Long;
                        compare: (other: string | number | Long.Long) => number;
                        comp: (other: string | number | Long.Long) => number;
                        divide: (divisor: string | number | Long.Long) => Long.Long;
                        div: (divisor: string | number | Long.Long) => Long.Long;
                        equals: (other: string | number | Long.Long) => boolean;
                        eq: (other: string | number | Long.Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | Long.Long) => boolean;
                        gt: (other: string | number | Long.Long) => boolean;
                        greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                        gte: (other: string | number | Long.Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | Long.Long) => boolean;
                        lt: (other: string | number | Long.Long) => boolean;
                        lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                        lte: (other: string | number | Long.Long) => boolean;
                        modulo: (other: string | number | Long.Long) => Long.Long;
                        mod: (other: string | number | Long.Long) => Long.Long;
                        multiply: (multiplier: string | number | Long.Long) => Long.Long;
                        mul: (multiplier: string | number | Long.Long) => Long.Long;
                        negate: () => Long.Long;
                        neg: () => Long.Long;
                        not: () => Long.Long;
                        notEquals: (other: string | number | Long.Long) => boolean;
                        neq: (other: string | number | Long.Long) => boolean;
                        or: (other: string | number | Long.Long) => Long.Long;
                        shiftLeft: (numBits: number | Long.Long) => Long.Long;
                        shl: (numBits: number | Long.Long) => Long.Long;
                        shiftRight: (numBits: number | Long.Long) => Long.Long;
                        shr: (numBits: number | Long.Long) => Long.Long;
                        shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                        shru: (numBits: number | Long.Long) => Long.Long;
                        subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                        sub: (subtrahend: string | number | Long.Long) => Long.Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => Long.Long;
                        toString: (radix?: number) => string;
                        toUnsigned: () => Long.Long;
                        xor: (other: string | number | Long.Long) => Long.Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                    nanos?: number;
                } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>;
                limitSize?: {
                    value?: string | number | Long.Long;
                } & {
                    value?: string | number | (Long.Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | Long.Long) => Long.Long;
                        and: (other: string | number | Long.Long) => Long.Long;
                        compare: (other: string | number | Long.Long) => number;
                        comp: (other: string | number | Long.Long) => number;
                        divide: (divisor: string | number | Long.Long) => Long.Long;
                        div: (divisor: string | number | Long.Long) => Long.Long;
                        equals: (other: string | number | Long.Long) => boolean;
                        eq: (other: string | number | Long.Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | Long.Long) => boolean;
                        gt: (other: string | number | Long.Long) => boolean;
                        greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                        gte: (other: string | number | Long.Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | Long.Long) => boolean;
                        lt: (other: string | number | Long.Long) => boolean;
                        lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                        lte: (other: string | number | Long.Long) => boolean;
                        modulo: (other: string | number | Long.Long) => Long.Long;
                        mod: (other: string | number | Long.Long) => Long.Long;
                        multiply: (multiplier: string | number | Long.Long) => Long.Long;
                        mul: (multiplier: string | number | Long.Long) => Long.Long;
                        negate: () => Long.Long;
                        neg: () => Long.Long;
                        not: () => Long.Long;
                        notEquals: (other: string | number | Long.Long) => boolean;
                        neq: (other: string | number | Long.Long) => boolean;
                        or: (other: string | number | Long.Long) => Long.Long;
                        shiftLeft: (numBits: number | Long.Long) => Long.Long;
                        shl: (numBits: number | Long.Long) => Long.Long;
                        shiftRight: (numBits: number | Long.Long) => Long.Long;
                        shr: (numBits: number | Long.Long) => Long.Long;
                        shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                        shru: (numBits: number | Long.Long) => Long.Long;
                        subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                        sub: (subtrahend: string | number | Long.Long) => Long.Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => Long.Long;
                        toString: (radix?: number) => string;
                        toUnsigned: () => Long.Long;
                        xor: (other: string | number | Long.Long) => Long.Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"]["value"], keyof Long.Long>, never>);
                } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"], "value">, never>;
            } & Record<Exclude<keyof I["policy"]["statements"][number], keyof import("../permission/common").Statement>, never>)[] & Record<Exclude<keyof I["policy"]["statements"], keyof {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[]>, never>;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["policy"]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["policy"]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>;
        } & Record<Exclude<keyof I["policy"], keyof Policy>, never>;
    } & Record<Exclude<keyof I, "policy">, never>>(object: I): QueryPolicyForAccountResponse;
    fromSDK(object: QueryPolicyForAccountResponseSDKType): QueryPolicyForAccountResponse;
    toSDK(message: QueryPolicyForAccountResponse): QueryPolicyForAccountResponseSDKType;
};
export declare const QueryVerifyPermissionRequest: {
    encode(message: QueryVerifyPermissionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryVerifyPermissionRequest;
    fromJSON(object: any): QueryVerifyPermissionRequest;
    toJSON(message: QueryVerifyPermissionRequest): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        actionType?: ActionType;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        actionType?: ActionType;
    } & Record<Exclude<keyof I, keyof QueryVerifyPermissionRequest>, never>>(object: I): QueryVerifyPermissionRequest;
    fromSDK(object: QueryVerifyPermissionRequestSDKType): QueryVerifyPermissionRequest;
    toSDK(message: QueryVerifyPermissionRequest): QueryVerifyPermissionRequestSDKType;
};
export declare const QueryVerifyPermissionResponse: {
    encode(message: QueryVerifyPermissionResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryVerifyPermissionResponse;
    fromJSON(object: any): QueryVerifyPermissionResponse;
    toJSON(message: QueryVerifyPermissionResponse): unknown;
    fromPartial<I extends {
        effect?: Effect;
    } & {
        effect?: Effect;
    } & Record<Exclude<keyof I, "effect">, never>>(object: I): QueryVerifyPermissionResponse;
    fromSDK(object: QueryVerifyPermissionResponseSDKType): QueryVerifyPermissionResponse;
    toSDK(message: QueryVerifyPermissionResponse): QueryVerifyPermissionResponseSDKType;
};
export declare const QueryHeadGroupRequest: {
    encode(message: QueryHeadGroupRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadGroupRequest;
    fromJSON(object: any): QueryHeadGroupRequest;
    toJSON(message: QueryHeadGroupRequest): unknown;
    fromPartial<I extends {
        groupOwner?: string;
        groupName?: string;
    } & {
        groupOwner?: string;
        groupName?: string;
    } & Record<Exclude<keyof I, keyof QueryHeadGroupRequest>, never>>(object: I): QueryHeadGroupRequest;
    fromSDK(object: QueryHeadGroupRequestSDKType): QueryHeadGroupRequest;
    toSDK(message: QueryHeadGroupRequest): QueryHeadGroupRequestSDKType;
};
export declare const QueryHeadGroupResponse: {
    encode(message: QueryHeadGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadGroupResponse;
    fromJSON(object: any): QueryHeadGroupResponse;
    toJSON(message: QueryHeadGroupResponse): unknown;
    fromPartial<I extends {
        groupInfo?: {
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
        };
    } & {
        groupInfo?: {
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
        } & {
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
        } & Record<Exclude<keyof I["groupInfo"], keyof GroupInfo>, never>;
    } & Record<Exclude<keyof I, "groupInfo">, never>>(object: I): QueryHeadGroupResponse;
    fromSDK(object: QueryHeadGroupResponseSDKType): QueryHeadGroupResponse;
    toSDK(message: QueryHeadGroupResponse): QueryHeadGroupResponseSDKType;
};
export declare const QueryListGroupsRequest: {
    encode(message: QueryListGroupsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListGroupsRequest;
    fromJSON(object: any): QueryListGroupsRequest;
    toJSON(message: QueryListGroupsRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
        groupOwner?: string;
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
            limit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
        groupOwner?: string;
    } & Record<Exclude<keyof I, keyof QueryListGroupsRequest>, never>>(object: I): QueryListGroupsRequest;
    fromSDK(object: QueryListGroupsRequestSDKType): QueryListGroupsRequest;
    toSDK(message: QueryListGroupsRequest): QueryListGroupsRequestSDKType;
};
export declare const QueryListGroupsResponse: {
    encode(message: QueryListGroupsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListGroupsResponse;
    fromJSON(object: any): QueryListGroupsResponse;
    toJSON(message: QueryListGroupsResponse): unknown;
    fromPartial<I extends {
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        };
        groupInfos?: {
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
        }[];
    } & {
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
        groupInfos?: {
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
        }[] & ({
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
        } & {
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
        } & Record<Exclude<keyof I["groupInfos"][number], keyof GroupInfo>, never>)[] & Record<Exclude<keyof I["groupInfos"], keyof {
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
        }[]>, never>;
    } & Record<Exclude<keyof I, keyof QueryListGroupsResponse>, never>>(object: I): QueryListGroupsResponse;
    fromSDK(object: QueryListGroupsResponseSDKType): QueryListGroupsResponse;
    toSDK(message: QueryListGroupsResponse): QueryListGroupsResponseSDKType;
};
export declare const QueryHeadGroupMemberRequest: {
    encode(message: QueryHeadGroupMemberRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadGroupMemberRequest;
    fromJSON(object: any): QueryHeadGroupMemberRequest;
    toJSON(message: QueryHeadGroupMemberRequest): unknown;
    fromPartial<I extends {
        member?: string;
        groupOwner?: string;
        groupName?: string;
    } & {
        member?: string;
        groupOwner?: string;
        groupName?: string;
    } & Record<Exclude<keyof I, keyof QueryHeadGroupMemberRequest>, never>>(object: I): QueryHeadGroupMemberRequest;
    fromSDK(object: QueryHeadGroupMemberRequestSDKType): QueryHeadGroupMemberRequest;
    toSDK(message: QueryHeadGroupMemberRequest): QueryHeadGroupMemberRequestSDKType;
};
export declare const QueryHeadGroupMemberResponse: {
    encode(message: QueryHeadGroupMemberResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadGroupMemberResponse;
    fromJSON(object: any): QueryHeadGroupMemberResponse;
    toJSON(message: QueryHeadGroupMemberResponse): unknown;
    fromPartial<I extends {
        groupMember?: {
            id?: string;
            groupId?: string;
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        };
    } & {
        groupMember?: {
            id?: string;
            groupId?: string;
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        } & {
            id?: string;
            groupId?: string;
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["groupMember"]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["groupMember"]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>;
        } & Record<Exclude<keyof I["groupMember"], keyof GroupMember>, never>;
    } & Record<Exclude<keyof I, "groupMember">, never>>(object: I): QueryHeadGroupMemberResponse;
    fromSDK(object: QueryHeadGroupMemberResponseSDKType): QueryHeadGroupMemberResponse;
    toSDK(message: QueryHeadGroupMemberResponse): QueryHeadGroupMemberResponseSDKType;
};
export declare const QueryPolicyForGroupRequest: {
    encode(message: QueryPolicyForGroupRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyForGroupRequest;
    fromJSON(object: any): QueryPolicyForGroupRequest;
    toJSON(message: QueryPolicyForGroupRequest): unknown;
    fromPartial<I extends {
        resource?: string;
        principalGroupId?: string;
    } & {
        resource?: string;
        principalGroupId?: string;
    } & Record<Exclude<keyof I, keyof QueryPolicyForGroupRequest>, never>>(object: I): QueryPolicyForGroupRequest;
    fromSDK(object: QueryPolicyForGroupRequestSDKType): QueryPolicyForGroupRequest;
    toSDK(message: QueryPolicyForGroupRequest): QueryPolicyForGroupRequestSDKType;
};
export declare const QueryPolicyForGroupResponse: {
    encode(message: QueryPolicyForGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyForGroupResponse;
    fromJSON(object: any): QueryPolicyForGroupResponse;
    toJSON(message: QueryPolicyForGroupResponse): unknown;
    fromPartial<I extends {
        policy?: {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            };
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        };
    } & {
        policy?: {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            };
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        } & {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            } & {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            } & Record<Exclude<keyof I["policy"]["principal"], keyof import("../permission/common").Principal>, never>;
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[] & ({
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            } & {
                effect?: Effect;
                actions?: ActionType[] & ActionType[] & Record<Exclude<keyof I["policy"]["statements"][number]["actions"], keyof ActionType[]>, never>;
                resources?: string[] & string[] & Record<Exclude<keyof I["policy"]["statements"][number]["resources"], keyof string[]>, never>;
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                } & {
                    seconds?: string | number | (Long.Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | Long.Long) => Long.Long;
                        and: (other: string | number | Long.Long) => Long.Long;
                        compare: (other: string | number | Long.Long) => number;
                        comp: (other: string | number | Long.Long) => number;
                        divide: (divisor: string | number | Long.Long) => Long.Long;
                        div: (divisor: string | number | Long.Long) => Long.Long;
                        equals: (other: string | number | Long.Long) => boolean;
                        eq: (other: string | number | Long.Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | Long.Long) => boolean;
                        gt: (other: string | number | Long.Long) => boolean;
                        greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                        gte: (other: string | number | Long.Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | Long.Long) => boolean;
                        lt: (other: string | number | Long.Long) => boolean;
                        lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                        lte: (other: string | number | Long.Long) => boolean;
                        modulo: (other: string | number | Long.Long) => Long.Long;
                        mod: (other: string | number | Long.Long) => Long.Long;
                        multiply: (multiplier: string | number | Long.Long) => Long.Long;
                        mul: (multiplier: string | number | Long.Long) => Long.Long;
                        negate: () => Long.Long;
                        neg: () => Long.Long;
                        not: () => Long.Long;
                        notEquals: (other: string | number | Long.Long) => boolean;
                        neq: (other: string | number | Long.Long) => boolean;
                        or: (other: string | number | Long.Long) => Long.Long;
                        shiftLeft: (numBits: number | Long.Long) => Long.Long;
                        shl: (numBits: number | Long.Long) => Long.Long;
                        shiftRight: (numBits: number | Long.Long) => Long.Long;
                        shr: (numBits: number | Long.Long) => Long.Long;
                        shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                        shru: (numBits: number | Long.Long) => Long.Long;
                        subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                        sub: (subtrahend: string | number | Long.Long) => Long.Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => Long.Long;
                        toString: (radix?: number) => string;
                        toUnsigned: () => Long.Long;
                        xor: (other: string | number | Long.Long) => Long.Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                    nanos?: number;
                } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>;
                limitSize?: {
                    value?: string | number | Long.Long;
                } & {
                    value?: string | number | (Long.Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | Long.Long) => Long.Long;
                        and: (other: string | number | Long.Long) => Long.Long;
                        compare: (other: string | number | Long.Long) => number;
                        comp: (other: string | number | Long.Long) => number;
                        divide: (divisor: string | number | Long.Long) => Long.Long;
                        div: (divisor: string | number | Long.Long) => Long.Long;
                        equals: (other: string | number | Long.Long) => boolean;
                        eq: (other: string | number | Long.Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | Long.Long) => boolean;
                        gt: (other: string | number | Long.Long) => boolean;
                        greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                        gte: (other: string | number | Long.Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | Long.Long) => boolean;
                        lt: (other: string | number | Long.Long) => boolean;
                        lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                        lte: (other: string | number | Long.Long) => boolean;
                        modulo: (other: string | number | Long.Long) => Long.Long;
                        mod: (other: string | number | Long.Long) => Long.Long;
                        multiply: (multiplier: string | number | Long.Long) => Long.Long;
                        mul: (multiplier: string | number | Long.Long) => Long.Long;
                        negate: () => Long.Long;
                        neg: () => Long.Long;
                        not: () => Long.Long;
                        notEquals: (other: string | number | Long.Long) => boolean;
                        neq: (other: string | number | Long.Long) => boolean;
                        or: (other: string | number | Long.Long) => Long.Long;
                        shiftLeft: (numBits: number | Long.Long) => Long.Long;
                        shl: (numBits: number | Long.Long) => Long.Long;
                        shiftRight: (numBits: number | Long.Long) => Long.Long;
                        shr: (numBits: number | Long.Long) => Long.Long;
                        shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                        shru: (numBits: number | Long.Long) => Long.Long;
                        subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                        sub: (subtrahend: string | number | Long.Long) => Long.Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => Long.Long;
                        toString: (radix?: number) => string;
                        toUnsigned: () => Long.Long;
                        xor: (other: string | number | Long.Long) => Long.Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"]["value"], keyof Long.Long>, never>);
                } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"], "value">, never>;
            } & Record<Exclude<keyof I["policy"]["statements"][number], keyof import("../permission/common").Statement>, never>)[] & Record<Exclude<keyof I["policy"]["statements"], keyof {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[]>, never>;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["policy"]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["policy"]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>;
        } & Record<Exclude<keyof I["policy"], keyof Policy>, never>;
    } & Record<Exclude<keyof I, "policy">, never>>(object: I): QueryPolicyForGroupResponse;
    fromSDK(object: QueryPolicyForGroupResponseSDKType): QueryPolicyForGroupResponse;
    toSDK(message: QueryPolicyForGroupResponse): QueryPolicyForGroupResponseSDKType;
};
export declare const QueryPolicyByIdRequest: {
    encode(message: QueryPolicyByIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyByIdRequest;
    fromJSON(object: any): QueryPolicyByIdRequest;
    toJSON(message: QueryPolicyByIdRequest): unknown;
    fromPartial<I extends {
        policyId?: string;
    } & {
        policyId?: string;
    } & Record<Exclude<keyof I, "policyId">, never>>(object: I): QueryPolicyByIdRequest;
    fromSDK(object: QueryPolicyByIdRequestSDKType): QueryPolicyByIdRequest;
    toSDK(message: QueryPolicyByIdRequest): QueryPolicyByIdRequestSDKType;
};
export declare const QueryPolicyByIdResponse: {
    encode(message: QueryPolicyByIdResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyByIdResponse;
    fromJSON(object: any): QueryPolicyByIdResponse;
    toJSON(message: QueryPolicyByIdResponse): unknown;
    fromPartial<I extends {
        policy?: {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            };
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        };
    } & {
        policy?: {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            };
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        } & {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            } & {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            } & Record<Exclude<keyof I["policy"]["principal"], keyof import("../permission/common").Principal>, never>;
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[] & ({
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            } & {
                effect?: Effect;
                actions?: ActionType[] & ActionType[] & Record<Exclude<keyof I["policy"]["statements"][number]["actions"], keyof ActionType[]>, never>;
                resources?: string[] & string[] & Record<Exclude<keyof I["policy"]["statements"][number]["resources"], keyof string[]>, never>;
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                } & {
                    seconds?: string | number | (Long.Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | Long.Long) => Long.Long;
                        and: (other: string | number | Long.Long) => Long.Long;
                        compare: (other: string | number | Long.Long) => number;
                        comp: (other: string | number | Long.Long) => number;
                        divide: (divisor: string | number | Long.Long) => Long.Long;
                        div: (divisor: string | number | Long.Long) => Long.Long;
                        equals: (other: string | number | Long.Long) => boolean;
                        eq: (other: string | number | Long.Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | Long.Long) => boolean;
                        gt: (other: string | number | Long.Long) => boolean;
                        greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                        gte: (other: string | number | Long.Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | Long.Long) => boolean;
                        lt: (other: string | number | Long.Long) => boolean;
                        lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                        lte: (other: string | number | Long.Long) => boolean;
                        modulo: (other: string | number | Long.Long) => Long.Long;
                        mod: (other: string | number | Long.Long) => Long.Long;
                        multiply: (multiplier: string | number | Long.Long) => Long.Long;
                        mul: (multiplier: string | number | Long.Long) => Long.Long;
                        negate: () => Long.Long;
                        neg: () => Long.Long;
                        not: () => Long.Long;
                        notEquals: (other: string | number | Long.Long) => boolean;
                        neq: (other: string | number | Long.Long) => boolean;
                        or: (other: string | number | Long.Long) => Long.Long;
                        shiftLeft: (numBits: number | Long.Long) => Long.Long;
                        shl: (numBits: number | Long.Long) => Long.Long;
                        shiftRight: (numBits: number | Long.Long) => Long.Long;
                        shr: (numBits: number | Long.Long) => Long.Long;
                        shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                        shru: (numBits: number | Long.Long) => Long.Long;
                        subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                        sub: (subtrahend: string | number | Long.Long) => Long.Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => Long.Long;
                        toString: (radix?: number) => string;
                        toUnsigned: () => Long.Long;
                        xor: (other: string | number | Long.Long) => Long.Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                    nanos?: number;
                } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>;
                limitSize?: {
                    value?: string | number | Long.Long;
                } & {
                    value?: string | number | (Long.Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | Long.Long) => Long.Long;
                        and: (other: string | number | Long.Long) => Long.Long;
                        compare: (other: string | number | Long.Long) => number;
                        comp: (other: string | number | Long.Long) => number;
                        divide: (divisor: string | number | Long.Long) => Long.Long;
                        div: (divisor: string | number | Long.Long) => Long.Long;
                        equals: (other: string | number | Long.Long) => boolean;
                        eq: (other: string | number | Long.Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | Long.Long) => boolean;
                        gt: (other: string | number | Long.Long) => boolean;
                        greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                        gte: (other: string | number | Long.Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | Long.Long) => boolean;
                        lt: (other: string | number | Long.Long) => boolean;
                        lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                        lte: (other: string | number | Long.Long) => boolean;
                        modulo: (other: string | number | Long.Long) => Long.Long;
                        mod: (other: string | number | Long.Long) => Long.Long;
                        multiply: (multiplier: string | number | Long.Long) => Long.Long;
                        mul: (multiplier: string | number | Long.Long) => Long.Long;
                        negate: () => Long.Long;
                        neg: () => Long.Long;
                        not: () => Long.Long;
                        notEquals: (other: string | number | Long.Long) => boolean;
                        neq: (other: string | number | Long.Long) => boolean;
                        or: (other: string | number | Long.Long) => Long.Long;
                        shiftLeft: (numBits: number | Long.Long) => Long.Long;
                        shl: (numBits: number | Long.Long) => Long.Long;
                        shiftRight: (numBits: number | Long.Long) => Long.Long;
                        shr: (numBits: number | Long.Long) => Long.Long;
                        shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                        shru: (numBits: number | Long.Long) => Long.Long;
                        subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                        sub: (subtrahend: string | number | Long.Long) => Long.Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => Long.Long;
                        toString: (radix?: number) => string;
                        toUnsigned: () => Long.Long;
                        xor: (other: string | number | Long.Long) => Long.Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"]["value"], keyof Long.Long>, never>);
                } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"], "value">, never>;
            } & Record<Exclude<keyof I["policy"]["statements"][number], keyof import("../permission/common").Statement>, never>)[] & Record<Exclude<keyof I["policy"]["statements"], keyof {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[]>, never>;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["policy"]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["policy"]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>;
        } & Record<Exclude<keyof I["policy"], keyof Policy>, never>;
    } & Record<Exclude<keyof I, "policy">, never>>(object: I): QueryPolicyByIdResponse;
    fromSDK(object: QueryPolicyByIdResponseSDKType): QueryPolicyByIdResponse;
    toSDK(message: QueryPolicyByIdResponse): QueryPolicyByIdResponseSDKType;
};
export declare const QueryLockFeeRequest: {
    encode(message: QueryLockFeeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryLockFeeRequest;
    fromJSON(object: any): QueryLockFeeRequest;
    toJSON(message: QueryLockFeeRequest): unknown;
    fromPartial<I extends {
        primarySpAddress?: string;
        createAt?: string | number | Long.Long;
        payloadSize?: string | number | Long.Long;
    } & {
        primarySpAddress?: string;
        createAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["createAt"], keyof Long.Long>, never>);
        payloadSize?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["payloadSize"], keyof Long.Long>, never>);
    } & Record<Exclude<keyof I, keyof QueryLockFeeRequest>, never>>(object: I): QueryLockFeeRequest;
    fromSDK(object: QueryLockFeeRequestSDKType): QueryLockFeeRequest;
    toSDK(message: QueryLockFeeRequest): QueryLockFeeRequestSDKType;
};
export declare const QueryLockFeeResponse: {
    encode(message: QueryLockFeeResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryLockFeeResponse;
    fromJSON(object: any): QueryLockFeeResponse;
    toJSON(message: QueryLockFeeResponse): unknown;
    fromPartial<I extends {
        amount?: string;
    } & {
        amount?: string;
    } & Record<Exclude<keyof I, "amount">, never>>(object: I): QueryLockFeeResponse;
    fromSDK(object: QueryLockFeeResponseSDKType): QueryLockFeeResponse;
    toSDK(message: QueryLockFeeResponse): QueryLockFeeResponseSDKType;
};
export declare const QueryHeadBucketExtraRequest: {
    encode(message: QueryHeadBucketExtraRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadBucketExtraRequest;
    fromJSON(object: any): QueryHeadBucketExtraRequest;
    toJSON(message: QueryHeadBucketExtraRequest): unknown;
    fromPartial<I extends {
        bucketName?: string;
    } & {
        bucketName?: string;
    } & Record<Exclude<keyof I, "bucketName">, never>>(object: I): QueryHeadBucketExtraRequest;
    fromSDK(object: QueryHeadBucketExtraRequestSDKType): QueryHeadBucketExtraRequest;
    toSDK(message: QueryHeadBucketExtraRequest): QueryHeadBucketExtraRequestSDKType;
};
export declare const QueryHeadBucketExtraResponse: {
    encode(message: QueryHeadBucketExtraResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadBucketExtraResponse;
    fromJSON(object: any): QueryHeadBucketExtraResponse;
    toJSON(message: QueryHeadBucketExtraResponse): unknown;
    fromPartial<I extends {
        extraInfo?: {
            priceTime?: string | number | Long.Long;
            totalChargeSize?: string | number | Long.Long;
            localVirtualGroups?: {
                id?: number;
                globalVirtualGroupId?: number;
                storedSize?: string | number | Long.Long;
                totalChargeSize?: string | number | Long.Long;
            }[];
            nextLocalVirtualGroupId?: number;
        };
    } & {
        extraInfo?: {
            priceTime?: string | number | Long.Long;
            totalChargeSize?: string | number | Long.Long;
            localVirtualGroups?: {
                id?: number;
                globalVirtualGroupId?: number;
                storedSize?: string | number | Long.Long;
                totalChargeSize?: string | number | Long.Long;
            }[];
            nextLocalVirtualGroupId?: number;
        } & {
            priceTime?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["extraInfo"]["priceTime"], keyof Long.Long>, never>);
            totalChargeSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["extraInfo"]["totalChargeSize"], keyof Long.Long>, never>);
            localVirtualGroups?: {
                id?: number;
                globalVirtualGroupId?: number;
                storedSize?: string | number | Long.Long;
                totalChargeSize?: string | number | Long.Long;
            }[] & ({
                id?: number;
                globalVirtualGroupId?: number;
                storedSize?: string | number | Long.Long;
                totalChargeSize?: string | number | Long.Long;
            } & {
                id?: number;
                globalVirtualGroupId?: number;
                storedSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["extraInfo"]["localVirtualGroups"][number]["storedSize"], keyof Long.Long>, never>);
                totalChargeSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["extraInfo"]["localVirtualGroups"][number]["totalChargeSize"], keyof Long.Long>, never>);
            } & Record<Exclude<keyof I["extraInfo"]["localVirtualGroups"][number], keyof import("./common").LocalVirtualGroup>, never>)[] & Record<Exclude<keyof I["extraInfo"]["localVirtualGroups"], keyof {
                id?: number;
                globalVirtualGroupId?: number;
                storedSize?: string | number | Long.Long;
                totalChargeSize?: string | number | Long.Long;
            }[]>, never>;
            nextLocalVirtualGroupId?: number;
        } & Record<Exclude<keyof I["extraInfo"], keyof InternalBucketInfo>, never>;
    } & Record<Exclude<keyof I, "extraInfo">, never>>(object: I): QueryHeadBucketExtraResponse;
    fromSDK(object: QueryHeadBucketExtraResponseSDKType): QueryHeadBucketExtraResponse;
    toSDK(message: QueryHeadBucketExtraResponse): QueryHeadBucketExtraResponseSDKType;
};
export declare const QueryIsPriceChangedRequest: {
    encode(message: QueryIsPriceChangedRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryIsPriceChangedRequest;
    fromJSON(object: any): QueryIsPriceChangedRequest;
    toJSON(message: QueryIsPriceChangedRequest): unknown;
    fromPartial<I extends {
        bucketName?: string;
    } & {
        bucketName?: string;
    } & Record<Exclude<keyof I, "bucketName">, never>>(object: I): QueryIsPriceChangedRequest;
    fromSDK(object: QueryIsPriceChangedRequestSDKType): QueryIsPriceChangedRequest;
    toSDK(message: QueryIsPriceChangedRequest): QueryIsPriceChangedRequestSDKType;
};
export declare const QueryIsPriceChangedResponse: {
    encode(message: QueryIsPriceChangedResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryIsPriceChangedResponse;
    fromJSON(object: any): QueryIsPriceChangedResponse;
    toJSON(message: QueryIsPriceChangedResponse): unknown;
    fromPartial<I extends {
        changed?: boolean;
        currentReadPrice?: string;
        currentPrimaryStorePrice?: string;
        currentSecondaryStorePrice?: string;
        currentValidatorTaxRate?: string;
        newReadPrice?: string;
        newPrimaryStorePrice?: string;
        newSecondaryStorePrice?: string;
        newValidatorTaxRate?: string;
    } & {
        changed?: boolean;
        currentReadPrice?: string;
        currentPrimaryStorePrice?: string;
        currentSecondaryStorePrice?: string;
        currentValidatorTaxRate?: string;
        newReadPrice?: string;
        newPrimaryStorePrice?: string;
        newSecondaryStorePrice?: string;
        newValidatorTaxRate?: string;
    } & Record<Exclude<keyof I, keyof QueryIsPriceChangedResponse>, never>>(object: I): QueryIsPriceChangedResponse;
    fromSDK(object: QueryIsPriceChangedResponseSDKType): QueryIsPriceChangedResponse;
    toSDK(message: QueryIsPriceChangedResponse): QueryIsPriceChangedResponseSDKType;
};
export declare const QueryQuoteUpdateTimeRequest: {
    encode(message: QueryQuoteUpdateTimeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryQuoteUpdateTimeRequest;
    fromJSON(object: any): QueryQuoteUpdateTimeRequest;
    toJSON(message: QueryQuoteUpdateTimeRequest): unknown;
    fromPartial<I extends {
        bucketName?: string;
    } & {
        bucketName?: string;
    } & Record<Exclude<keyof I, "bucketName">, never>>(object: I): QueryQuoteUpdateTimeRequest;
    fromSDK(object: QueryQuoteUpdateTimeRequestSDKType): QueryQuoteUpdateTimeRequest;
    toSDK(message: QueryQuoteUpdateTimeRequest): QueryQuoteUpdateTimeRequestSDKType;
};
export declare const QueryQuoteUpdateTimeResponse: {
    encode(message: QueryQuoteUpdateTimeResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryQuoteUpdateTimeResponse;
    fromJSON(object: any): QueryQuoteUpdateTimeResponse;
    toJSON(message: QueryQuoteUpdateTimeResponse): unknown;
    fromPartial<I extends {
        updateAt?: string | number | Long.Long;
    } & {
        updateAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["updateAt"], keyof Long.Long>, never>);
    } & Record<Exclude<keyof I, "updateAt">, never>>(object: I): QueryQuoteUpdateTimeResponse;
    fromSDK(object: QueryQuoteUpdateTimeResponseSDKType): QueryQuoteUpdateTimeResponse;
    toSDK(message: QueryQuoteUpdateTimeResponse): QueryQuoteUpdateTimeResponseSDKType;
};
export declare const QueryGroupMembersExistRequest: {
    encode(message: QueryGroupMembersExistRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupMembersExistRequest;
    fromJSON(object: any): QueryGroupMembersExistRequest;
    toJSON(message: QueryGroupMembersExistRequest): unknown;
    fromPartial<I extends {
        groupId?: string;
        members?: string[];
    } & {
        groupId?: string;
        members?: string[] & string[] & Record<Exclude<keyof I["members"], keyof string[]>, never>;
    } & Record<Exclude<keyof I, keyof QueryGroupMembersExistRequest>, never>>(object: I): QueryGroupMembersExistRequest;
    fromSDK(object: QueryGroupMembersExistRequestSDKType): QueryGroupMembersExistRequest;
    toSDK(message: QueryGroupMembersExistRequest): QueryGroupMembersExistRequestSDKType;
};
export declare const QueryGroupMembersExistResponse_ExistsEntry: {
    encode(message: QueryGroupMembersExistResponse_ExistsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupMembersExistResponse_ExistsEntry;
    fromJSON(object: any): QueryGroupMembersExistResponse_ExistsEntry;
    toJSON(message: QueryGroupMembersExistResponse_ExistsEntry): unknown;
    fromPartial<I extends {
        key?: string;
        value?: boolean;
    } & {
        key?: string;
        value?: boolean;
    } & Record<Exclude<keyof I, keyof QueryGroupMembersExistResponse_ExistsEntry>, never>>(object: I): QueryGroupMembersExistResponse_ExistsEntry;
    fromSDK(object: QueryGroupMembersExistResponse_ExistsEntrySDKType): QueryGroupMembersExistResponse_ExistsEntry;
    toSDK(message: QueryGroupMembersExistResponse_ExistsEntry): QueryGroupMembersExistResponse_ExistsEntrySDKType;
};
export declare const QueryGroupMembersExistResponse: {
    encode(message: QueryGroupMembersExistResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupMembersExistResponse;
    fromJSON(object: any): QueryGroupMembersExistResponse;
    toJSON(message: QueryGroupMembersExistResponse): unknown;
    fromPartial<I extends {
        exists?: {
            [x: string]: boolean;
        };
    } & {
        exists?: {
            [x: string]: boolean;
        } & {
            [x: string]: boolean;
        } & Record<Exclude<keyof I["exists"], string | number>, never>;
    } & Record<Exclude<keyof I, "exists">, never>>(object: I): QueryGroupMembersExistResponse;
    fromSDK(object: QueryGroupMembersExistResponseSDKType): QueryGroupMembersExistResponse;
    toSDK(message: QueryGroupMembersExistResponse): QueryGroupMembersExistResponseSDKType;
};
export declare const QueryGroupsExistRequest: {
    encode(message: QueryGroupsExistRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupsExistRequest;
    fromJSON(object: any): QueryGroupsExistRequest;
    toJSON(message: QueryGroupsExistRequest): unknown;
    fromPartial<I extends {
        groupOwner?: string;
        groupNames?: string[];
    } & {
        groupOwner?: string;
        groupNames?: string[] & string[] & Record<Exclude<keyof I["groupNames"], keyof string[]>, never>;
    } & Record<Exclude<keyof I, keyof QueryGroupsExistRequest>, never>>(object: I): QueryGroupsExistRequest;
    fromSDK(object: QueryGroupsExistRequestSDKType): QueryGroupsExistRequest;
    toSDK(message: QueryGroupsExistRequest): QueryGroupsExistRequestSDKType;
};
export declare const QueryGroupsExistByIdRequest: {
    encode(message: QueryGroupsExistByIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupsExistByIdRequest;
    fromJSON(object: any): QueryGroupsExistByIdRequest;
    toJSON(message: QueryGroupsExistByIdRequest): unknown;
    fromPartial<I extends {
        groupIds?: string[];
    } & {
        groupIds?: string[] & string[] & Record<Exclude<keyof I["groupIds"], keyof string[]>, never>;
    } & Record<Exclude<keyof I, "groupIds">, never>>(object: I): QueryGroupsExistByIdRequest;
    fromSDK(object: QueryGroupsExistByIdRequestSDKType): QueryGroupsExistByIdRequest;
    toSDK(message: QueryGroupsExistByIdRequest): QueryGroupsExistByIdRequestSDKType;
};
export declare const QueryGroupsExistResponse_ExistsEntry: {
    encode(message: QueryGroupsExistResponse_ExistsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupsExistResponse_ExistsEntry;
    fromJSON(object: any): QueryGroupsExistResponse_ExistsEntry;
    toJSON(message: QueryGroupsExistResponse_ExistsEntry): unknown;
    fromPartial<I extends {
        key?: string;
        value?: boolean;
    } & {
        key?: string;
        value?: boolean;
    } & Record<Exclude<keyof I, keyof QueryGroupsExistResponse_ExistsEntry>, never>>(object: I): QueryGroupsExistResponse_ExistsEntry;
    fromSDK(object: QueryGroupsExistResponse_ExistsEntrySDKType): QueryGroupsExistResponse_ExistsEntry;
    toSDK(message: QueryGroupsExistResponse_ExistsEntry): QueryGroupsExistResponse_ExistsEntrySDKType;
};
export declare const QueryGroupsExistResponse: {
    encode(message: QueryGroupsExistResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupsExistResponse;
    fromJSON(object: any): QueryGroupsExistResponse;
    toJSON(message: QueryGroupsExistResponse): unknown;
    fromPartial<I extends {
        exists?: {
            [x: string]: boolean;
        };
    } & {
        exists?: {
            [x: string]: boolean;
        } & {
            [x: string]: boolean;
        } & Record<Exclude<keyof I["exists"], string | number>, never>;
    } & Record<Exclude<keyof I, "exists">, never>>(object: I): QueryGroupsExistResponse;
    fromSDK(object: QueryGroupsExistResponseSDKType): QueryGroupsExistResponse;
    toSDK(message: QueryGroupsExistResponse): QueryGroupsExistResponseSDKType;
};
/** Query defines the gRPC querier service. */
export interface Query {
    /** Parameters queries the parameters of the module. */
    Params(request?: QueryParamsRequest): Promise<QueryParamsResponse>;
    /** Parameters queries the parameters of the module. */
    QueryParamsByTimestamp(request: QueryParamsByTimestampRequest): Promise<QueryParamsByTimestampResponse>;
    /** Queries a bucket with specify name. */
    HeadBucket(request: QueryHeadBucketRequest): Promise<QueryHeadBucketResponse>;
    /** Queries a bucket by id */
    HeadBucketById(request: QueryHeadBucketByIdRequest): Promise<QueryHeadBucketResponse>;
    /** Queries a bucket with EIP712 standard metadata info */
    HeadBucketNFT(request: QueryNFTRequest): Promise<QueryBucketNFTResponse>;
    /** Queries a object with specify name. */
    HeadObject(request: QueryHeadObjectRequest): Promise<QueryHeadObjectResponse>;
    /** Queries an object by id */
    HeadObjectById(request: QueryHeadObjectByIdRequest): Promise<QueryHeadObjectResponse>;
    /** Queries a object with EIP712 standard metadata info */
    HeadObjectNFT(request: QueryNFTRequest): Promise<QueryObjectNFTResponse>;
    /** Queries a list of bucket items. */
    ListBuckets(request?: QueryListBucketsRequest): Promise<QueryListBucketsResponse>;
    /** Queries a list of object items under the bucket. */
    ListObjects(request: QueryListObjectsRequest): Promise<QueryListObjectsResponse>;
    /** Queries a list of object items under the bucket. */
    ListObjectsByBucketId(request: QueryListObjectsByBucketIdRequest): Promise<QueryListObjectsResponse>;
    /** Queries a group with EIP712 standard metadata info */
    HeadGroupNFT(request: QueryNFTRequest): Promise<QueryGroupNFTResponse>;
    /** Queries a policy which grants permission to account */
    QueryPolicyForAccount(request: QueryPolicyForAccountRequest): Promise<QueryPolicyForAccountResponse>;
    /** Queries a list of VerifyPermission items. */
    VerifyPermission(request: QueryVerifyPermissionRequest): Promise<QueryVerifyPermissionResponse>;
    /** Queries a group with specify owner and name . */
    HeadGroup(request: QueryHeadGroupRequest): Promise<QueryHeadGroupResponse>;
    /** Queries a list of ListGroup items. */
    ListGroups(request: QueryListGroupsRequest): Promise<QueryListGroupsResponse>;
    /** Queries a list of HeadGroupMember items. */
    HeadGroupMember(request: QueryHeadGroupMemberRequest): Promise<QueryHeadGroupMemberResponse>;
    /** Queries a policy that grants permission to a group */
    QueryPolicyForGroup(request: QueryPolicyForGroupRequest): Promise<QueryPolicyForGroupResponse>;
    /** Queries a policy by policy id */
    QueryPolicyById(request: QueryPolicyByIdRequest): Promise<QueryPolicyByIdResponse>;
    /** Queries lock fee for storing an object */
    QueryLockFee(request: QueryLockFeeRequest): Promise<QueryLockFeeResponse>;
    /** Queries a bucket extra info (with gvg bindings and price time) with specify name. */
    HeadBucketExtra(request: QueryHeadBucketExtraRequest): Promise<QueryHeadBucketExtraResponse>;
    /** Queries whether read and storage prices changed for the bucket. */
    QueryIsPriceChanged(request: QueryIsPriceChangedRequest): Promise<QueryIsPriceChangedResponse>;
    /** Queries whether read and storage prices changed for the bucket. */
    QueryQuotaUpdateTime(request: QueryQuoteUpdateTimeRequest): Promise<QueryQuoteUpdateTimeResponse>;
    /** Queries whether some members are in the group. */
    QueryGroupMembersExist(request: QueryGroupMembersExistRequest): Promise<QueryGroupMembersExistResponse>;
    /** Queries whether some groups are exist. */
    QueryGroupsExist(request: QueryGroupsExistRequest): Promise<QueryGroupsExistResponse>;
    /** Queries whether some groups are exist by id. */
    QueryGroupsExistById(request: QueryGroupsExistByIdRequest): Promise<QueryGroupsExistResponse>;
}
export declare class QueryClientImpl implements Query {
    private readonly rpc;
    constructor(rpc: Rpc);
    Params(request?: QueryParamsRequest): Promise<QueryParamsResponse>;
    QueryParamsByTimestamp(request: QueryParamsByTimestampRequest): Promise<QueryParamsByTimestampResponse>;
    HeadBucket(request: QueryHeadBucketRequest): Promise<QueryHeadBucketResponse>;
    HeadBucketById(request: QueryHeadBucketByIdRequest): Promise<QueryHeadBucketResponse>;
    HeadBucketNFT(request: QueryNFTRequest): Promise<QueryBucketNFTResponse>;
    HeadObject(request: QueryHeadObjectRequest): Promise<QueryHeadObjectResponse>;
    HeadObjectById(request: QueryHeadObjectByIdRequest): Promise<QueryHeadObjectResponse>;
    HeadObjectNFT(request: QueryNFTRequest): Promise<QueryObjectNFTResponse>;
    ListBuckets(request?: QueryListBucketsRequest): Promise<QueryListBucketsResponse>;
    ListObjects(request: QueryListObjectsRequest): Promise<QueryListObjectsResponse>;
    ListObjectsByBucketId(request: QueryListObjectsByBucketIdRequest): Promise<QueryListObjectsResponse>;
    HeadGroupNFT(request: QueryNFTRequest): Promise<QueryGroupNFTResponse>;
    QueryPolicyForAccount(request: QueryPolicyForAccountRequest): Promise<QueryPolicyForAccountResponse>;
    VerifyPermission(request: QueryVerifyPermissionRequest): Promise<QueryVerifyPermissionResponse>;
    HeadGroup(request: QueryHeadGroupRequest): Promise<QueryHeadGroupResponse>;
    ListGroups(request: QueryListGroupsRequest): Promise<QueryListGroupsResponse>;
    HeadGroupMember(request: QueryHeadGroupMemberRequest): Promise<QueryHeadGroupMemberResponse>;
    QueryPolicyForGroup(request: QueryPolicyForGroupRequest): Promise<QueryPolicyForGroupResponse>;
    QueryPolicyById(request: QueryPolicyByIdRequest): Promise<QueryPolicyByIdResponse>;
    QueryLockFee(request: QueryLockFeeRequest): Promise<QueryLockFeeResponse>;
    HeadBucketExtra(request: QueryHeadBucketExtraRequest): Promise<QueryHeadBucketExtraResponse>;
    QueryIsPriceChanged(request: QueryIsPriceChangedRequest): Promise<QueryIsPriceChangedResponse>;
    QueryQuotaUpdateTime(request: QueryQuoteUpdateTimeRequest): Promise<QueryQuoteUpdateTimeResponse>;
    QueryGroupMembersExist(request: QueryGroupMembersExistRequest): Promise<QueryGroupMembersExistResponse>;
    QueryGroupsExist(request: QueryGroupsExistRequest): Promise<QueryGroupsExistResponse>;
    QueryGroupsExistById(request: QueryGroupsExistByIdRequest): Promise<QueryGroupsExistResponse>;
}
