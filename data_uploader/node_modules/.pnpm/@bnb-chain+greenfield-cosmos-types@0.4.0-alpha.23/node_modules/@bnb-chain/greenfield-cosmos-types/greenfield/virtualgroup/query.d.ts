import { PageRequest, PageRequestSDKType, PageResponse, PageResponseSDKType } from "../../cosmos/base/query/v1beta1/pagination";
import { Params, ParamsSDKType } from "./params";
import { GlobalVirtualGroup, GlobalVirtualGroupSDKType, GlobalVirtualGroupFamily, GlobalVirtualGroupFamilySDKType } from "./types";
import * as _m0 from "protobufjs/minimal";
import { Rpc } from "../../helpers";
export declare const protobufPackage = "greenfield.virtualgroup";
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequestSDKType {
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
    /** params holds all the parameters of this module. */
    params: Params;
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponseSDKType {
    params: ParamsSDKType;
}
export interface QueryGlobalVirtualGroupRequest {
    globalVirtualGroupId: number;
}
export interface QueryGlobalVirtualGroupRequestSDKType {
    global_virtual_group_id: number;
}
export interface QueryGlobalVirtualGroupResponse {
    globalVirtualGroup: GlobalVirtualGroup;
}
export interface QueryGlobalVirtualGroupResponseSDKType {
    global_virtual_group: GlobalVirtualGroupSDKType;
}
export interface QueryGlobalVirtualGroupByFamilyIDRequest {
    globalVirtualGroupFamilyId: number;
}
export interface QueryGlobalVirtualGroupByFamilyIDRequestSDKType {
    global_virtual_group_family_id: number;
}
export interface QueryGlobalVirtualGroupByFamilyIDResponse {
    globalVirtualGroups: GlobalVirtualGroup[];
}
export interface QueryGlobalVirtualGroupByFamilyIDResponseSDKType {
    global_virtual_groups: GlobalVirtualGroupSDKType[];
}
export interface QueryGlobalVirtualGroupFamilyRequest {
    familyId: number;
}
export interface QueryGlobalVirtualGroupFamilyRequestSDKType {
    family_id: number;
}
export interface QueryGlobalVirtualGroupFamilyResponse {
    globalVirtualGroupFamily: GlobalVirtualGroupFamily;
}
export interface QueryGlobalVirtualGroupFamilyResponseSDKType {
    global_virtual_group_family: GlobalVirtualGroupFamilySDKType;
}
/** this line is used by starport scaffolding # 3 */
export interface QueryGlobalVirtualGroupFamiliesRequest {
    pagination: PageRequest;
}
/** this line is used by starport scaffolding # 3 */
export interface QueryGlobalVirtualGroupFamiliesRequestSDKType {
    pagination: PageRequestSDKType;
}
export interface QueryGlobalVirtualGroupFamiliesResponse {
    gvgFamilies: GlobalVirtualGroupFamily[];
    pagination: PageResponse;
}
export interface QueryGlobalVirtualGroupFamiliesResponseSDKType {
    gvg_families: GlobalVirtualGroupFamilySDKType[];
    pagination: PageResponseSDKType;
}
export interface AvailableGlobalVirtualGroupFamiliesRequest {
    globalVirtualGroupFamilyIds: number[];
}
export interface AvailableGlobalVirtualGroupFamiliesRequestSDKType {
    global_virtual_group_family_ids: number[];
}
export interface AvailableGlobalVirtualGroupFamiliesResponse {
    globalVirtualGroupFamilyIds: number[];
}
export interface AvailableGlobalVirtualGroupFamiliesResponseSDKType {
    global_virtual_group_family_ids: number[];
}
export declare const QueryParamsRequest: {
    encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
    fromJSON(_: any): QueryParamsRequest;
    toJSON(_: QueryParamsRequest): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
    fromSDK(_: QueryParamsRequestSDKType): QueryParamsRequest;
    toSDK(_: QueryParamsRequest): QueryParamsRequestSDKType;
};
export declare const QueryParamsResponse: {
    encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
    fromJSON(object: any): QueryParamsResponse;
    toJSON(message: QueryParamsResponse): unknown;
    fromPartial<I extends {
        params?: {
            depositDenom?: string;
            gvgStakingPerBytes?: string;
            maxLocalVirtualGroupNumPerBucket?: number;
            maxGlobalVirtualGroupNumPerFamily?: number;
            maxStoreSizePerFamily?: string | number | import("long").Long;
        };
    } & {
        params?: {
            depositDenom?: string;
            gvgStakingPerBytes?: string;
            maxLocalVirtualGroupNumPerBucket?: number;
            maxGlobalVirtualGroupNumPerFamily?: number;
            maxStoreSizePerFamily?: string | number | import("long").Long;
        } & {
            depositDenom?: string;
            gvgStakingPerBytes?: string;
            maxLocalVirtualGroupNumPerBucket?: number;
            maxGlobalVirtualGroupNumPerFamily?: number;
            maxStoreSizePerFamily?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["params"]["maxStoreSizePerFamily"], keyof import("long").Long>, never>);
        } & Record<Exclude<keyof I["params"], keyof Params>, never>;
    } & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
    fromSDK(object: QueryParamsResponseSDKType): QueryParamsResponse;
    toSDK(message: QueryParamsResponse): QueryParamsResponseSDKType;
};
export declare const QueryGlobalVirtualGroupRequest: {
    encode(message: QueryGlobalVirtualGroupRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupRequest;
    fromJSON(object: any): QueryGlobalVirtualGroupRequest;
    toJSON(message: QueryGlobalVirtualGroupRequest): unknown;
    fromPartial<I extends {
        globalVirtualGroupId?: number;
    } & {
        globalVirtualGroupId?: number;
    } & Record<Exclude<keyof I, "globalVirtualGroupId">, never>>(object: I): QueryGlobalVirtualGroupRequest;
    fromSDK(object: QueryGlobalVirtualGroupRequestSDKType): QueryGlobalVirtualGroupRequest;
    toSDK(message: QueryGlobalVirtualGroupRequest): QueryGlobalVirtualGroupRequestSDKType;
};
export declare const QueryGlobalVirtualGroupResponse: {
    encode(message: QueryGlobalVirtualGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupResponse;
    fromJSON(object: any): QueryGlobalVirtualGroupResponse;
    toJSON(message: QueryGlobalVirtualGroupResponse): unknown;
    fromPartial<I extends {
        globalVirtualGroup?: {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | import("long").Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        };
    } & {
        globalVirtualGroup?: {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | import("long").Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        } & {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[] & number[] & Record<Exclude<keyof I["globalVirtualGroup"]["secondarySpIds"], keyof number[]>, never>;
            storedSize?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["globalVirtualGroup"]["storedSize"], keyof import("long").Long>, never>);
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        } & Record<Exclude<keyof I["globalVirtualGroup"], keyof GlobalVirtualGroup>, never>;
    } & Record<Exclude<keyof I, "globalVirtualGroup">, never>>(object: I): QueryGlobalVirtualGroupResponse;
    fromSDK(object: QueryGlobalVirtualGroupResponseSDKType): QueryGlobalVirtualGroupResponse;
    toSDK(message: QueryGlobalVirtualGroupResponse): QueryGlobalVirtualGroupResponseSDKType;
};
export declare const QueryGlobalVirtualGroupByFamilyIDRequest: {
    encode(message: QueryGlobalVirtualGroupByFamilyIDRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupByFamilyIDRequest;
    fromJSON(object: any): QueryGlobalVirtualGroupByFamilyIDRequest;
    toJSON(message: QueryGlobalVirtualGroupByFamilyIDRequest): unknown;
    fromPartial<I extends {
        globalVirtualGroupFamilyId?: number;
    } & {
        globalVirtualGroupFamilyId?: number;
    } & Record<Exclude<keyof I, "globalVirtualGroupFamilyId">, never>>(object: I): QueryGlobalVirtualGroupByFamilyIDRequest;
    fromSDK(object: QueryGlobalVirtualGroupByFamilyIDRequestSDKType): QueryGlobalVirtualGroupByFamilyIDRequest;
    toSDK(message: QueryGlobalVirtualGroupByFamilyIDRequest): QueryGlobalVirtualGroupByFamilyIDRequestSDKType;
};
export declare const QueryGlobalVirtualGroupByFamilyIDResponse: {
    encode(message: QueryGlobalVirtualGroupByFamilyIDResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupByFamilyIDResponse;
    fromJSON(object: any): QueryGlobalVirtualGroupByFamilyIDResponse;
    toJSON(message: QueryGlobalVirtualGroupByFamilyIDResponse): unknown;
    fromPartial<I extends {
        globalVirtualGroups?: {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | import("long").Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        }[];
    } & {
        globalVirtualGroups?: {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | import("long").Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        }[] & ({
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | import("long").Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        } & {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[] & number[] & Record<Exclude<keyof I["globalVirtualGroups"][number]["secondarySpIds"], keyof number[]>, never>;
            storedSize?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["globalVirtualGroups"][number]["storedSize"], keyof import("long").Long>, never>);
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        } & Record<Exclude<keyof I["globalVirtualGroups"][number], keyof GlobalVirtualGroup>, never>)[] & Record<Exclude<keyof I["globalVirtualGroups"], keyof {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | import("long").Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        }[]>, never>;
    } & Record<Exclude<keyof I, "globalVirtualGroups">, never>>(object: I): QueryGlobalVirtualGroupByFamilyIDResponse;
    fromSDK(object: QueryGlobalVirtualGroupByFamilyIDResponseSDKType): QueryGlobalVirtualGroupByFamilyIDResponse;
    toSDK(message: QueryGlobalVirtualGroupByFamilyIDResponse): QueryGlobalVirtualGroupByFamilyIDResponseSDKType;
};
export declare const QueryGlobalVirtualGroupFamilyRequest: {
    encode(message: QueryGlobalVirtualGroupFamilyRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupFamilyRequest;
    fromJSON(object: any): QueryGlobalVirtualGroupFamilyRequest;
    toJSON(message: QueryGlobalVirtualGroupFamilyRequest): unknown;
    fromPartial<I extends {
        familyId?: number;
    } & {
        familyId?: number;
    } & Record<Exclude<keyof I, "familyId">, never>>(object: I): QueryGlobalVirtualGroupFamilyRequest;
    fromSDK(object: QueryGlobalVirtualGroupFamilyRequestSDKType): QueryGlobalVirtualGroupFamilyRequest;
    toSDK(message: QueryGlobalVirtualGroupFamilyRequest): QueryGlobalVirtualGroupFamilyRequestSDKType;
};
export declare const QueryGlobalVirtualGroupFamilyResponse: {
    encode(message: QueryGlobalVirtualGroupFamilyResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupFamilyResponse;
    fromJSON(object: any): QueryGlobalVirtualGroupFamilyResponse;
    toJSON(message: QueryGlobalVirtualGroupFamilyResponse): unknown;
    fromPartial<I extends {
        globalVirtualGroupFamily?: {
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[];
            virtualPaymentAddress?: string;
        };
    } & {
        globalVirtualGroupFamily?: {
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[];
            virtualPaymentAddress?: string;
        } & {
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[] & number[] & Record<Exclude<keyof I["globalVirtualGroupFamily"]["globalVirtualGroupIds"], keyof number[]>, never>;
            virtualPaymentAddress?: string;
        } & Record<Exclude<keyof I["globalVirtualGroupFamily"], keyof GlobalVirtualGroupFamily>, never>;
    } & Record<Exclude<keyof I, "globalVirtualGroupFamily">, never>>(object: I): QueryGlobalVirtualGroupFamilyResponse;
    fromSDK(object: QueryGlobalVirtualGroupFamilyResponseSDKType): QueryGlobalVirtualGroupFamilyResponse;
    toSDK(message: QueryGlobalVirtualGroupFamilyResponse): QueryGlobalVirtualGroupFamilyResponseSDKType;
};
export declare const QueryGlobalVirtualGroupFamiliesRequest: {
    encode(message: QueryGlobalVirtualGroupFamiliesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupFamiliesRequest;
    fromJSON(object: any): QueryGlobalVirtualGroupFamiliesRequest;
    toJSON(message: QueryGlobalVirtualGroupFamiliesRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | import("long").Long;
            limit?: string | number | import("long").Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | import("long").Long;
            limit?: string | number | import("long").Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof import("long").Long>, never>);
            limit?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof import("long").Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
    } & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryGlobalVirtualGroupFamiliesRequest;
    fromSDK(object: QueryGlobalVirtualGroupFamiliesRequestSDKType): QueryGlobalVirtualGroupFamiliesRequest;
    toSDK(message: QueryGlobalVirtualGroupFamiliesRequest): QueryGlobalVirtualGroupFamiliesRequestSDKType;
};
export declare const QueryGlobalVirtualGroupFamiliesResponse: {
    encode(message: QueryGlobalVirtualGroupFamiliesResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupFamiliesResponse;
    fromJSON(object: any): QueryGlobalVirtualGroupFamiliesResponse;
    toJSON(message: QueryGlobalVirtualGroupFamiliesResponse): unknown;
    fromPartial<I extends {
        gvgFamilies?: {
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[];
            virtualPaymentAddress?: string;
        }[];
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | import("long").Long;
        };
    } & {
        gvgFamilies?: {
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[];
            virtualPaymentAddress?: string;
        }[] & ({
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[];
            virtualPaymentAddress?: string;
        } & {
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[] & number[] & Record<Exclude<keyof I["gvgFamilies"][number]["globalVirtualGroupIds"], keyof number[]>, never>;
            virtualPaymentAddress?: string;
        } & Record<Exclude<keyof I["gvgFamilies"][number], keyof GlobalVirtualGroupFamily>, never>)[] & Record<Exclude<keyof I["gvgFamilies"], keyof {
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[];
            virtualPaymentAddress?: string;
        }[]>, never>;
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | import("long").Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof import("long").Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
    } & Record<Exclude<keyof I, keyof QueryGlobalVirtualGroupFamiliesResponse>, never>>(object: I): QueryGlobalVirtualGroupFamiliesResponse;
    fromSDK(object: QueryGlobalVirtualGroupFamiliesResponseSDKType): QueryGlobalVirtualGroupFamiliesResponse;
    toSDK(message: QueryGlobalVirtualGroupFamiliesResponse): QueryGlobalVirtualGroupFamiliesResponseSDKType;
};
export declare const AvailableGlobalVirtualGroupFamiliesRequest: {
    encode(message: AvailableGlobalVirtualGroupFamiliesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AvailableGlobalVirtualGroupFamiliesRequest;
    fromJSON(object: any): AvailableGlobalVirtualGroupFamiliesRequest;
    toJSON(message: AvailableGlobalVirtualGroupFamiliesRequest): unknown;
    fromPartial<I extends {
        globalVirtualGroupFamilyIds?: number[];
    } & {
        globalVirtualGroupFamilyIds?: number[] & number[] & Record<Exclude<keyof I["globalVirtualGroupFamilyIds"], keyof number[]>, never>;
    } & Record<Exclude<keyof I, "globalVirtualGroupFamilyIds">, never>>(object: I): AvailableGlobalVirtualGroupFamiliesRequest;
    fromSDK(object: AvailableGlobalVirtualGroupFamiliesRequestSDKType): AvailableGlobalVirtualGroupFamiliesRequest;
    toSDK(message: AvailableGlobalVirtualGroupFamiliesRequest): AvailableGlobalVirtualGroupFamiliesRequestSDKType;
};
export declare const AvailableGlobalVirtualGroupFamiliesResponse: {
    encode(message: AvailableGlobalVirtualGroupFamiliesResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AvailableGlobalVirtualGroupFamiliesResponse;
    fromJSON(object: any): AvailableGlobalVirtualGroupFamiliesResponse;
    toJSON(message: AvailableGlobalVirtualGroupFamiliesResponse): unknown;
    fromPartial<I extends {
        globalVirtualGroupFamilyIds?: number[];
    } & {
        globalVirtualGroupFamilyIds?: number[] & number[] & Record<Exclude<keyof I["globalVirtualGroupFamilyIds"], keyof number[]>, never>;
    } & Record<Exclude<keyof I, "globalVirtualGroupFamilyIds">, never>>(object: I): AvailableGlobalVirtualGroupFamiliesResponse;
    fromSDK(object: AvailableGlobalVirtualGroupFamiliesResponseSDKType): AvailableGlobalVirtualGroupFamiliesResponse;
    toSDK(message: AvailableGlobalVirtualGroupFamiliesResponse): AvailableGlobalVirtualGroupFamiliesResponseSDKType;
};
/** Query defines the gRPC query service. */
export interface Query {
    /** Parameters queries the parameters of the module. */
    Params(request?: QueryParamsRequest): Promise<QueryParamsResponse>;
    /** Queries a global virtual group by its id. */
    GlobalVirtualGroup(request: QueryGlobalVirtualGroupRequest): Promise<QueryGlobalVirtualGroupResponse>;
    /** Queries a list of global virtual groups by family id. */
    GlobalVirtualGroupByFamilyID(request: QueryGlobalVirtualGroupByFamilyIDRequest): Promise<QueryGlobalVirtualGroupByFamilyIDResponse>;
    /** Queries a global virtual group family by its id. */
    GlobalVirtualGroupFamily(request: QueryGlobalVirtualGroupFamilyRequest): Promise<QueryGlobalVirtualGroupFamilyResponse>;
    /** Queries a list of GlobalVirtualGroupFamilies items. */
    GlobalVirtualGroupFamilies(request?: QueryGlobalVirtualGroupFamiliesRequest): Promise<QueryGlobalVirtualGroupFamiliesResponse>;
    /** AvailableGlobalVirtualGroupFamilies filters a list of GlobalVirtualGroupFamilies ID which are qualified to create bucket on */
    AvailableGlobalVirtualGroupFamilies(request: AvailableGlobalVirtualGroupFamiliesRequest): Promise<AvailableGlobalVirtualGroupFamiliesResponse>;
}
export declare class QueryClientImpl implements Query {
    private readonly rpc;
    constructor(rpc: Rpc);
    Params(request?: QueryParamsRequest): Promise<QueryParamsResponse>;
    GlobalVirtualGroup(request: QueryGlobalVirtualGroupRequest): Promise<QueryGlobalVirtualGroupResponse>;
    GlobalVirtualGroupByFamilyID(request: QueryGlobalVirtualGroupByFamilyIDRequest): Promise<QueryGlobalVirtualGroupByFamilyIDResponse>;
    GlobalVirtualGroupFamily(request: QueryGlobalVirtualGroupFamilyRequest): Promise<QueryGlobalVirtualGroupFamilyResponse>;
    GlobalVirtualGroupFamilies(request?: QueryGlobalVirtualGroupFamiliesRequest): Promise<QueryGlobalVirtualGroupFamiliesResponse>;
    AvailableGlobalVirtualGroupFamilies(request: AvailableGlobalVirtualGroupFamiliesRequest): Promise<AvailableGlobalVirtualGroupFamiliesResponse>;
}
